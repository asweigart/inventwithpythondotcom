<div id="calibre_link-396" class="calibre">
<h2 class="h2a1" id="calibre_link-65"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-990" class="calibre1"></span><span class="big">22</span><br class="calibre15" />FINDING AND GENERATING PRIME NUMBERS</h2>
<p class="epigraph"><em class="calibre7">“Mathematicians have tried in vain to this day to discover some order in the sequence of prime numbers, and we have reason to believe that it is a mystery into which the human mind will never penetrate.”<br class="calibre9" />&mdash;Leonhard Euler, 18th-century mathematician</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">All the ciphers described in this book so far have been in existence for hundreds of years. These ciphers worked well when hackers had to rely on pencil and paper, but they’re more vulnerable now that computers can manipulate data trillions of times faster than a person can. Another problem with these classical ciphers is that they use the same key for encryption and decryption. Using one key causes problems when you’re trying to send an encrypted message: for example, how can you securely send the key to decrypt it?</p>
<p class="indent">In <a href="#calibre_link-53" class="calibre8">Chapter 23</a>, you’ll learn how the public key cipher improves on the old ciphers by using very large prime numbers to create two keys: a public key for encryption and a private key for decryption. To generate prime numbers for the public key cipher’s keys, you’ll need to learn about some properties of prime numbers (and the difficulty of factoring large numbers) that make the cipher possible. In this chapter, you’ll exploit these features of prime numbers to create the <em class="calibre7">primeNum.py</em> module, which can generate keys by quickly determining whether or not a number is prime.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-229"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Prime and composite numbers</p>
<p class="bull">• The trial division primality test</p>
<p class="bull">• The sieve of Eratosthenes</p>
<p class="bull">• The Rabin-Miller primality test</p>
</div>
<h3 class="h1" id="calibre_link-779"><strong class="calibre3">What Is a Prime Number?</strong></h3>
<p class="noindent">A <em class="calibre7">prime number</em> is an integer that is greater than 1 and has only two factors: 1 and itself. Recall that the factors of a number are those numbers that can be multiplied to equal the original number. For example, the numbers 3 and 7 are factors of 21. The number 12 has factors 2 and 6 as well as 3 and 4.</p>
<p class="indent">Every number has factors of 1 and itself because 1 multiplied by any number will always equal that number. For example, 1 and 21 are factors of 21, and the numbers 1 and 12 are factors of 12. If no other factors exist for a number, the number is prime. For example, 2 is a prime number because it has only 1 and 2 as its factors.</p>
<p class="indent">Here is a short list of prime numbers (note that 1 is not considered a prime number): 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, and so on.</p>
<p class="indent">There is an infinite number of prime numbers, which means there is no such thing as the largest prime number. They continue to get bigger and bigger, just like regular numbers. The public key cipher uses large prime numbers to make the key too big to brute-force.</p>
<p class="indent">Prime numbers can be difficult to find, and large prime numbers, such as those used for public keys, are even harder to find. To generate large prime numbers as public keys, we’ll find a random large number and then check whether the number is prime by using a <em class="calibre7">primality test</em>. If the number is prime according to the primality test, we’ll use it; otherwise, we’ll continue creating and testing large numbers until we find one that is prime.</p>
<p class="indent">Let’s look at some very large numbers to illustrate how big the prime numbers used in the public key cipher can be.</p>
<p class="indent">A <em class="calibre7">googol</em> is 10 raised to the power of 100 and is written as a 1 followed by 100 zeros:</p>
<p class="block-quote">10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,<br class="calibre9" />000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,<br class="calibre9" />000,000,000,000</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-172"></span>A billion billion billion googols have 27 more zeros than a googol:</p>
<p class="block-quote">10,000,000,000,000,000,000,000,000,000,000,000,000,000,000,<br class="calibre9" />000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,<br class="calibre9" />000,000,000,000,000,000,000,000,000,000,000,000,000</p>
<p class="indent">But these are tiny numbers compared to the prime numbers the public key cipher uses. For example, a typical prime number used in the public key program has hundreds of digits and might look something like this:</p>
<p class="block-quote">112,829,754,900,439,506,175,719,191,782,841,802,172,556,768,<br class="calibre9" />253,593,054,977,186,2355,84,979,780,304,652,423,405,148,425,<br class="calibre9" />447,063,090,165,759,070,742,102,132,335,103,295,947,000,718,<br class="calibre9" />386,333,756,395,799,633,478,227,612,244,071,875,721,006,813,<br class="calibre9" />307,628,061,280,861,610,153,485,352,017,238,548,269,452,852,<br class="calibre9" />733,818,231,045,171,038,838,387,845,888,589,411,762,622,041,<br class="calibre9" />204,120,706,150,518,465,720,862,068,595,814,264,819</p>
<p class="indent">This number is so big that I bet you didn’t even notice the typo in it.</p>
<p class="indent">A few other interesting features of prime numbers are also useful to know. Because all even numbers are multiples of two, 2 is the only possible even prime number. Also, multiplying two prime numbers should result in a number whose only factors are 1, itself, and the two prime numbers that were multiplied. (For example, multiplying prime numbers 3 and 7 results in 21, whose only factors are 1, 21, 3, and 7.)</p>
<p class="indent">Integers that are not prime are called <em class="calibre7">composite numbers</em> because they’re composed of at least two factors besides 1 and the number. Every composite number has a <em class="calibre7">prime factorization</em>, which is a factorization composed of only prime numbers. For example, the composite number 1386 is composed of the prime numbers 2, 3, 7, and 11, because 2 × 3 × 3 × 7 × 11 = 1386. Each composite number’s prime factorization is unique to that composite number.</p>
<p class="indentb">We’ll use this information about what makes a number prime to write a module that can determine whether a small number is prime and generate prime numbers. The module, <em class="calibre7">primeNum.py</em>, will define the following functions:</p>
<p class="list-plain"><span class="codestrong">isPrimeTrialDiv()</span> uses the trial division algorithm to return <span class="literal">True</span> if the number passed to it is prime or <span class="literal">False</span> if the number passed to it is not prime.</p>
<p class="list-plain"><span class="codestrong">primeSieve()</span> uses the sieve of Eratosthenes algorithm to generate prime numbers.</p>
<p class="list-plain"><span class="codestrong">rabinMiller()</span> uses the Rabin-Miller algorithm to check whether the number passed to it is prime. This algorithm, unlike the trial division algorithm, can work quickly on very large numbers. This function is called not directly but rather by <span class="literal">isPrime()</span>.</p>
<p class="list-plain"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-301"></span><span class="codestrong">isPrime()</span> is called when the user must determine whether a large integer is prime or not.</p>
<p class="list-plain"><span class="codestrong">generateLargePrime()</span> returns a large prime number that is hundreds of digits long. This function will be used in the <em class="calibre7">makePublicPrivateKeys.py</em> program in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>.</p>
<h3 class="h1" id="calibre_link-780"><strong class="calibre3">Source Code for the Prime Numbers Module</strong></h3>
<p class="noindent">Like <em class="calibre7">cryptomath.py</em>, introduced in <a href="#calibre_link-59" class="calibre8">Chapter 13</a>, the <em class="calibre7">primeNum.py</em> program is meant to be imported as a module by other programs and doesn’t do anything when run on its own. The <em class="calibre7">primeNum.py</em> module imports Python’s <span class="literal">math</span> and <span class="literal">random</span> modules to use when generating prime numbers.</p>
<p class="indent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and then save it as <em class="calibre7">primeNum.py</em>.</p>
<p class="noindentz"><em class="calibre7">primeNum.py</em></p>
<p class="programs1">&nbsp;1. # Prime Number Sieve<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import math, random<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6.<br class="calibre9" />&nbsp;7. def isPrimeTrialDiv(num):<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns True if num is a prime number, otherwise False.<br class="calibre9" />&nbsp;9.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Uses the trial division algorithm for testing primality.<br class="calibre9" />11.<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# All numbers less than 2 are not prime:<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num &lt; 2:<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />15.<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See if num is divisible by any number up to the square root of num:<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, int(math.sqrt(num)) + 1):<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % i == 0:<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre9" />21.<br class="calibre9" />22.<br class="calibre9" />23. def primeSieve(sieveSize):<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a list of prime numbers calculated using<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the Sieve of Eratosthenes algorithm.<br class="calibre9" />26.<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve = [True] * sieveSize<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[0] = False # Zero and one are not prime numbers.<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[1] = False<br class="calibre9" />30.<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create the sieve:<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, int(math.sqrt(sieveSize)) + 1):<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer = i * 2<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while pointer &lt; sieveSize:<br class="calibre9" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[pointer] = False<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer += i<br class="calibre9" />37.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-991"></span>38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Compile the list of primes:<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primes = []<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(sieveSize):<br class="calibre9" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sieve[i] == True:<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primes.append(i)<br class="calibre9" />43.<br class="calibre9" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return primes<br class="calibre9" />45.<br class="calibre9" />46. def rabinMiller(num):<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns True if num is a prime number.<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % 2 == 0 or num &lt; 2:<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False # Rabin-Miller doesn't work on even integers.<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num == 3:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = num - 1<br class="calibre9" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = 0<br class="calibre9" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while s % 2 == 0:<br class="calibre9" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep halving s until it is odd (and use t<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# to count how many times we halve s):<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s // 2<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t += 1<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for trials in range(5): # Try to falsify num's primality 5 times.<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = random.randrange(2, num - 1)<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = pow(a, s, num)<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v != 1: # This test does not apply if v is 1.<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while v != (num - 1):<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if i == t - 1:<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1<br class="calibre9" />69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = (v ** 2) % num<br class="calibre9" />70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre9" />71.<br class="calibre9" />72. # Most of the time we can quickly determine if num is not prime<br class="calibre9" />73. # by dividing by the first few dozen prime numbers. This is quicker<br class="calibre9" />74. # than rabinMiller() but does not detect all composites.<br class="calibre9" />75. LOW_PRIMES = primeSieve(100)<br class="calibre9" />76.<br class="calibre9" />77.<br class="calibre9" />78. def isPrime(num):<br class="calibre9" />79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if num is a prime number. This function does a quicker<br class="calibre9" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# prime number check before calling rabinMiller().<br class="calibre9" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (num &lt; 2):<br class="calibre9" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False # 0, 1, and negative numbers are not prime.<br class="calibre9" />83.<br class="calibre9" />84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See if any of the low prime numbers can divide num:<br class="calibre9" />85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for prime in LOW_PRIMES:<br class="calibre9" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (num % prime == 0):<br class="calibre9" />87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />88.<br class="calibre9" />89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If all else fails, call rabinMiller() to determine if num is prime:<br class="calibre9" />90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return rabinMiller(num)<br class="calibre9" />91.<br class="calibre9" />92.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-173"></span>93. def generateLargePrime(keysize=1024):<br class="calibre9" />94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a random prime number that is keysize bits in size:<br class="calibre9" />95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = random.randrange(2**(keysize-1), 2**(keysize))<br class="calibre9" />97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isPrime(num):<br class="calibre9" />98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return num</p>
<h3 class="h1" id="calibre_link-781"><strong class="calibre3">Sample Run of the Prime Numbers Module</strong></h3>
<p class="noindent">To see sample output of the <em class="calibre7">primeNum.py</em> module, enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import primeNum</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">primeNum.generateLargePrime()</span><br class="calibre9" />122881168342211041030523683515443239007484290600701555369488271748378054744009<br class="calibre9" />463751312511471291011945732413378446666809140502037003673211052153493607681619<br class="calibre9" />990563076859566835016382556518967124921538212397036345815983641146000671635019<br class="calibre9" />637218348455544435908428400192565849620509600312468757953899553441648428119<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">primeNum.isPrime(45943208739848451)</span><br class="calibre9" />False<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">primeNum.isPrime(13)</span><br class="calibre9" />True</p>
<p class="indent">Importing the <em class="calibre7">primeNum.py</em> module lets us generate a very large prime number using the <span class="literal">generateLargePrime()</span> function. It also lets us pass any number, large or small, to the <span class="literal">isPrime()</span> function to determine whether it’s a prime number.</p>
<h3 class="h1" id="calibre_link-782"><strong class="calibre3">How the Trial Division Algorithm Works</strong></h3>
<p class="noindentb">To find out whether or not a given number is prime, we use the <em class="calibre7">trial division algorithm</em>. The algorithm continues to divide a number by integers (starting with 2, 3, and so on) to see whether any of them evenly divides the number with 0 as the remainder. For example, to test whether 49 is prime, we can try dividing it by integers starting with 2:</p>
<p class="indent">49 ÷ 2 = 24 remainder 1</p>
<p class="indent">49 ÷ 3 = 16 remainder 1</p>
<p class="indent">49 ÷ 4 = 12 remainder 1</p>
<p class="indent">49 ÷ 5 = 9 remainder 4</p>
<p class="indent">49 ÷ 6 = 8 remainder 1</p>
<p class="indentb">49 ÷ 7 = 7 remainder 0</p>
<p class="indent">Because 7 evenly divides 49 with a remainder of 0, we know that 7 is a factor of 49. This means that 49 can’t be a prime number, because it has at least one factor other than 1 and itself.</p>
<p class="indent">We can expedite this process by dividing by prime numbers only, not composite numbers. As mentioned earlier, composite numbers are nothing more than <em class="calibre7">composites</em> of prime numbers. This means that if 2 can’t divide 49 evenly, then a composite number such as 6, whose factors include 2, won’t <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-174"></span>be able to divide 49 evenly either. In other words, <em class="calibre7">any</em> number that 6 divides evenly can also be divided by 2 evenly, because 2 is a factor of 6. <a href="#calibre_link-397" class="calibre8">Figure 22-1</a> illustrates this concept.</p>
<div class="image"><img src="images/00044.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-397" class="calibre8"></a><em class="calibre7">Figure 22-1: Any number that divides evenly by 6 also divides evenly by 2.</em></p>
<p class="indentb">As another example, let’s test whether 13 is prime:</p>
<p class="indent">13 ÷ 2 = 6 remainder 1</p>
<p class="indentb">13 ÷ 3 = 4 remainder 1</p>
<p class="indent">We only have to test integers up to (and including) the square root of the number we’re testing for primality. The <em class="calibre7">square root</em> of a number refers to the number that when multiplied by itself results in that original number. For example, the square root of 25 is 5 because 5 × 5 = 25. Because a number can’t have two factors greater than its square root, we can limit the trial division algorithm test to integers less than the number’s square root. The square root of 13 is about 3.6, so we only need to divide by 2 and 3 to determine that 13 is prime.</p>
<p class="indent">As another example, the number 16 has a square root of 4. Multiplying two numbers greater than 4 will always result in a number greater than 16, and any factors of 16 greater than 4 will always be paired with factors smaller than 4, such as 8 × 2. Therefore, you’ll find all the factors greater than the square root by finding any factors less than the square root.</p>
<p class="indent">To find a number’s square root in Python, you can use the <span class="literal">math.sqrt()</span> function. Enter the following into the interactive shell to see some examples of how this function works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import math</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">5 * 5</span><br class="calibre9" />25<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">math.sqrt(25)</span><br class="calibre9" />5.0<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">math.sqrt(10)</span><br class="calibre9" />3.1622776601683795</p>
<p class="indent">Notice that <span class="literal">math.sqrt()</span> always returns a floating-point value.</p>
<h3 class="h1" id="calibre_link-783"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-218" class="calibre1"></span>Implementing the Trial Division Algorithm Test</h3>
<p class="noindent">The <span class="literal">isPrimeTrialDiv()</span> function on line 7 in <em class="calibre7">primeNum.py</em> takes a number as the parameter <span class="literal">num</span> and uses the trial division algorithm test to check whether the number is prime. The function returns <span class="literal">False</span> if <span class="literal">num</span> is a composite number and <span class="literal">True</span> if <span class="literal">num</span> is a prime number.</p>
<p class="programs1">&nbsp;7. def isPrimeTrialDiv(num):<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns True if num is a prime number, otherwise False.<br class="calibre9" />&nbsp;9.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Uses the trial division algorithm for testing primality.<br class="calibre9" />11.<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# All numbers less than 2 are not prime:<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num &lt; 2:<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False</p>
<p class="indent">Line 13 checks whether <span class="literal">num</span> is less than <span class="literal">2</span>, and if it is, the function returns <span class="literal">False</span>, because a number less than 2 cannot be prime.</p>
<p class="indent">Line 17 begins the <span class="literal">for</span> loop that implements the trial division algorithm. It also takes the square root of <span class="literal">num</span> using <span class="literal">math.sqrt()</span> and uses the returned floating-point value to set the upper limit of the range of integers we’ll test.</p>
<p class="programs1">16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See if num is divisible by any number up to the square root of num:<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, int(math.sqrt(num)) + 1):<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % i == 0:<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</p>
<p class="indent">Line 18 checks whether the remainder is 0 using the mod operator (<span class="literal">%</span>). If the remainder is 0, <span class="literal">num</span> is divisible by <span class="literal">i</span> and is therefore not a prime number, and the loop returns <span class="literal">False</span>. If the <span class="literal">for</span> loop on line 17 never returns <span class="literal">False</span>, the function returns <span class="literal">True</span> on line 20 to indicate that <span class="literal">num</span> is likely a prime number.</p>
<p class="indent">The trial division algorithm in the <span class="literal">isPrimeTrialDiv()</span> function is useful, but it’s not the only way to test for primality. You can also find prime numbers using the sieve of Eratosthenes.</p>
<h3 class="h1" id="calibre_link-784">The Sieve of Eratosthenes</h3>
<p class="noindent">The <em class="calibre7">sieve of Eratosthenes</em> (pronounced “era-taws-thuh-knees”) is an algorithm that finds all the prime numbers within a range of numbers. To see how this algorithm works, imagine a group of boxes. Each box holds an integer from 1 to 50, all marked as prime, as shown in <a href="#calibre_link-398" class="calibre8">Figure 22-2</a>.</p>
<p class="indent">To implement the sieve of Eratosthenes, we eliminate non-prime numbers from our range until only prime numbers remain. Because 1 is never prime, let’s start by marking number 1 as “not prime.” Then let’s mark all the multiples of two (except for 2) as “not prime.” This means we’ll mark the integers 4 (2 × 2), 6 (2 × 3), 8 (2 × 4), 10, 12, and so on up to 50 as “not prime,” as shown in <a href="#calibre_link-399" class="calibre8">Figure 22-3</a>.</p>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-992"></span>
<div class="image"><img src="images/00058.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-398" class="calibre8"></a><em class="calibre7">Figure 22-2: Setting up the sieve of Eratosthenes for numbers 1 through 50</em></p>
<div class="image"><img src="images/00004.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-399" class="calibre8"></a><em class="calibre7">Figure 22-3: Eliminating the number 1 and all even numbers</em></p>
<p class="indent">Then we repeat the process using multiples of three: we exclude 3 and mark 6, 9, 12, 15, 18, 21, and so on as “not prime.” We repeat this process for the multiples of four excluding 4, the multiples of five except for 5, and so on until we get through multiples of eight. We stop at 8 because it is larger than 7.071, which is the square root of 50. All the multiples of 9, 10, 11, and so on will already have been marked, because any number that is a factor larger than the square root will be paired with a factor smaller than the square root, which we’ve already marked.</p>
<p class="indent">The completed sieve should look like <a href="#calibre_link-400" class="calibre8">Figure 22-4</a>, with prime numbers shown in white boxes.</p>
<div class="image"><img src="images/00041.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-400" class="calibre8"></a><em class="calibre7">Figure 22-4: Prime numbers found using the sieve of Eratosthenes</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-300"></span>Using the sieve of Eratosthenes, we found that the prime numbers less than 50 are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, and 47. This sieve algorithm is best used when you want to quickly find all the prime numbers <em class="calibre7">in a certain range</em> of numbers. It’s much faster than using the previous trial division algorithm to check each number individually.</p>
<h3 class="h1" id="calibre_link-785">Generating Prime Numbers with the Sieve of Eratosthenes</h3>
<p class="noindent">The <span class="literal">primeSieve()</span> function on line 23 of the <em class="calibre7">primeNum.py</em> module uses the sieve of Eratosthenes algorithm to return a list of all prime numbers between <span class="literal">1</span> and <span class="literal">sieveSize</span>:</p>
<p class="programs1">23. def primeSieve(sieveSize):<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a list of prime numbers calculated using<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the Sieve of Eratosthenes algorithm.<br class="calibre9" />26.<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve = [True] * sieveSize<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[0] = False # Zero and one are not prime numbers.<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[1] = False</p>
<p class="indent">Line 27 creates a list of Boolean <span class="literal">True</span> values that represent the length of <span class="literal">sieveSize</span>. The <span class="literal">0</span> and <span class="literal">1</span> indexes are marked as <span class="literal">False</span> because <span class="literal">0</span> and <span class="literal">1</span> are not prime numbers.</p>
<p class="indent">The <span class="literal">for</span> loop on line 32 goes through each integer from <span class="literal">2</span> up to the square root of <span class="literal">sieveSize</span>:</p>
<p class="programs1">31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create the sieve:<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, int(math.sqrt(sieveSize)) + 1):<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer = i * 2<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while pointer &lt; sieveSize:<br class="calibre9" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sieve[pointer] = False<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pointer += i</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-219"></span>The variable <span class="literal">pointer</span> starts at the first multiple of <span class="literal">i</span> after <span class="literal">i</span>, which is <span class="literal">i * 2</span> on line 33. Then the <span class="literal">while</span> loop sets the <span class="literal">pointer</span> index in the <span class="literal">sieve</span> list to <span class="literal">False</span>, and line 36 changes <span class="literal">pointer</span> to point to the next multiple of <span class="literal">i</span>.</p>
<p class="indent">After the <span class="literal">for</span> loop on line 32 finishes, the <span class="literal">sieve</span> list should now contain <span class="literal">True</span> for each index that is a prime number. We create a new list, which starts as an empty list in <span class="literal">primes</span>, loop over the entire <span class="literal">sieve</span> list, and append numbers when <span class="literal">sieve[i]</span> is <span class="literal">True</span> or when <span class="literal">i</span> is prime:</p>
<p class="programs1">38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Compile the list of primes:<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primes = []<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(sieveSize):<br class="calibre9" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sieve[i] == True:<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primes.append(i)</p>
<p class="indent">Line 44 returns the list of prime numbers:</p>
<p class="programs1">44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return primes</p>
<p class="indent">The <span class="literal">primeSieve()</span> function can find all prime numbers within a small range, and the <span class="literal">isPrimeTrialDiv()</span> function can quickly determine whether a small number is prime. But what about a large integer that is hundreds of digits long?</p>
<p class="indent">If we pass a large integer to <span class="literal">isPrimeTrialDiv()</span>, it would take several seconds to determine whether or not it’s prime. And if the number is hundreds of digits long, like the prime numbers we’ll use for the public key cipher program in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>, it would take more than a trillion years just to figure out whether that number is prime.</p>
<p class="indent">In the next section, you’ll learn how to determine whether a very large number is prime using the Rabin-Miller primality test.</p>
<h3 class="h1" id="calibre_link-786"><strong class="calibre3">The Rabin-Miller Primality Algorithm</strong></h3>
<p class="noindent">The main benefit of the Rabin-Miller algorithm is that it is a relatively simple primality test and takes only a few seconds to run on a normal computer. Even though the algorithm’s Python code is just a few lines long, the explanation of the mathematical proof for why it works would be too long for this book. The Rabin-Miller algorithm is not a surefire test for primality. Instead, it finds numbers that are very likely to be prime but are not guaranteed to be prime. But the chance of a false positive is small enough that this approach is good enough for the purposes of this book. To learn more about how the Rabin-Miller algorithm works, you can read about it at <a href="https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test" class="calibre8"><em class="calibre7">https://en.wikipedia.org/wiki/Miller-Rabin_primality_test</em></a>.</p>
<p class="indent">The <span class="literal">rabinMiller()</span> function implements this algorithm to find prime numbers:</p>
<p class="programs1">46. def rabinMiller(num):<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns True if num is a prime number.<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % 2 == 0 or num &lt; 2:<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False # Rabin-Miller doesn't work on even integers.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-993"></span>50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num == 3:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = num - 1<br class="calibre9" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = 0<br class="calibre9" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while s % 2 == 0:<br class="calibre9" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep halving s until it is odd (and use t<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# to count how many times we halve s):<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s = s // 2<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t += 1<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for trials in range(5): # Try to falsify num's primality 5 times.<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = random.randrange(2, num - 1)<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = pow(a, s, num)<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if v != 1: # This test does not apply if v is 1.<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = 0<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while v != (num - 1):<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if i == t - 1:<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = i + 1<br class="calibre9" />69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = (v ** 2) % num<br class="calibre9" />70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</p>
<p class="indent">Don’t worry about how this code works. The important concept to keep in mind is that if the <span class="literal">rabinMiller()</span> function returns <span class="literal">True</span>, the <span class="literal">num</span> argument is very likely to be prime. If <span class="literal">rabinMiller()</span> returns <span class="literal">False</span>, <span class="literal">num</span> is definitely composite.</p>
<h3 class="h1" id="calibre_link-787"><strong class="calibre3">Finding Large Prime Numbers</strong></h3>
<p class="noindent">We’ll create another function named <span class="literal">isPrime()</span> that will call <span class="literal">rabinMiller()</span>. The Rabin-Miller algorithm isn’t always the most efficient way to check whether a number is prime; therefore, at the beginning of the <span class="literal">isPrime()</span> function, we’ll do some simple checks as shortcuts to figure out whether the number stored in the parameter <span class="literal">num</span> is prime. Let’s store a list of all the primes less than 100 in the constant variable <span class="literal">LOW_PRIMES</span>. We can use the <span class="literal">primeSieve</span><span class="literal">()</span> function to calculate this list:</p>
<p class="programs1">72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Most of the time we can quickly determine if num is not prime<br class="calibre9" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# by dividing by the first few dozen prime numbers. This is quicker<br class="calibre9" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# than rabinMiller() but does not detect all composites.<br class="calibre9" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOW_PRIMES = primeSieve(100)</p>
<p class="indent">We’ll use this list just as we did in <span class="literal">isPrimeTrialDiv()</span> and discount any numbers less than 2 (lines 81 and 82):</p>
<p class="programs1">78. def isPrime(num):<br class="calibre9" />79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if num is a prime number. This function does a quicker<br class="calibre9" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# prime number check before calling rabinMiller().<br class="calibre9" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (num &lt; 2):<br class="calibre9" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False # 0, 1, and negative numbers are not prime.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-306"></span>When <span class="literal">num</span> isn’t less than <span class="literal">2</span>, we can use the <span class="literal">LOW_PRIMES</span> list as a shortcut to test <span class="literal">num</span>, too. Checking whether <span class="literal">num</span> is divisible by all the primes less than 100 won’t definitively tell us whether the number is prime, but it might help us find composite numbers. About 90 percent of large integers passed to <span class="literal">isPrime()</span> can be detected as composite by dividing by the prime numbers less than 100. The reason is that if the number can be evenly divided by a prime number, such as 3, you don’t have to check whether the number can be evenly divided by composite numbers 6, 9, 12, 15, or any other multiple of 3. Dividing the number by smaller primes is much faster than executing the slower Rabin-Miller algorithm on the number, so this shortcut helps the program execute more quickly about 90 percent of the time <span class="literal">isPrime()</span> is called.</p>
<p class="indent">Line 85 loops through each of the prime numbers in the <span class="literal">LOW_PRIMES</span> list:</p>
<p class="programs1">84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See if any of the low prime numbers can divide num:<br class="calibre9" />85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for prime in LOW_PRIMES:<br class="calibre9" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (num % prime == 0):<br class="calibre9" />87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False</p>
<p class="indent">The integer in <span class="literal">num</span> is modded by each prime number using the mod operator on line 86, and if the result evaluates to <span class="literal">0</span>, we know that <span class="literal">prime</span> divides <span class="literal">num</span> so <span class="literal">num</span> is not prime. In that case, line 87 returns <span class="literal">False</span>.</p>
<p class="indent">Those are the two quick tests we’ll perform to determine whether a number is prime. If the execution continues past line 87, the <span class="literal">rabinMiller()</span> function checks <span class="literal">num</span>’s primality.</p>
<p class="indent">Line 90 calls the <span class="literal">rabinMiller()</span> function to determine whether the number is prime; then the <span class="literal">rabinMiller()</span> function takes its return value and returns it from the <span class="literal">isPrime()</span> function:</p>
<p class="programs1">89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If all else fails, call rabinMiller() to determine if num is prime:<br class="calibre9" />90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return rabinMiller(num)</p>
<p class="indent">Now that you know how to determine whether a number is prime, we’ll use these primality tests to generate prime numbers. These will be used by the public key program in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>.</p>
<h3 class="h1" id="calibre_link-788"><strong class="calibre3">Generating Large Prime Numbers</strong></h3>
<p class="noindent">Using an infinite loop, the <span class="literal">generateLargePrime()</span> function on line 93 returns an integer that is prime. It does this by generating a large random number, storing it in <span class="literal">num</span>, and then passing <span class="literal">num</span> to <span class="literal">isPrime()</span>. The <span class="literal">isPrime()</span> function then tests whether <span class="literal">num</span> is prime.</p>
<p class="programs1">93. def generateLargePrime(keysize=1024):<br class="calibre9" />94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a random prime number that is keysize bits in size:<br class="calibre9" />95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = random.randrange(2**(keysize-1), 2**(keysize))<br class="calibre9" />97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isPrime(num):<br class="calibre9" />98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return num</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-994"></span>If <span class="literal">num</span> is prime, line 98 returns <span class="literal">num</span>. Otherwise, the infinite loop goes back to line 96 to try a new random number. This loop continues until it finds a number that the <span class="literal">isPrime()</span> function determines is prime.</p>
<p class="indent">The <span class="literal">generateLargePrime()</span> function’s <span class="literal">keysize</span> parameter has a default value of <span class="literal">1024</span>. The larger the <span class="literal">keysize</span>, the more possible keys there are and the harder the cipher is to brute-force. Public key sizes are usually calculated in terms of numbers called <em class="calibre7">bits</em>, which you’ll learn more about in <a href="#calibre_link-53" class="calibre8">Chapters 23</a> and <a href="#calibre_link-54" class="calibre8">24</a>. For now, just know that a 1024-bit number is very large: it’s about 300 digits!</p>
<h3 class="h1" id="calibre_link-789">Summary</h3>
<p class="noindent">Prime numbers have fascinating properties in mathematics. As you’ll learn in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>, they’re also the backbone of ciphers used in professional encryption software. The definition of a prime number is simple enough: it’s a number that has only 1 and itself as factors. But determining which numbers are prime takes some clever code.</p>
<p class="indent">In this chapter, we wrote the <span class="literal">isPrimeTrialDiv()</span> function to determine whether or not a number is prime by modding a number by all the numbers between 2 and the square root of the number. This is the trial division algorithm. A prime number should never have a remainder of 0 when modded by any number other than its factors, 1 and itself. So we know that a number that has a 0 remainder is not prime.</p>
<p class="indent">You learned that the sieve of Eratosthenes can quickly find all prime numbers in a range of numbers, though it uses too much memory for finding large primes.</p>
<p class="indent">Because the sieve of Eratosthenes and the trial division algorithm in <em class="calibre7">primeNum.py</em> aren’t fast enough to find large prime numbers, we needed another algorithm for the public key cipher, which uses extremely large prime numbers that are hundreds of digits long. As a workaround, you learned to use the Rabin-Miller algorithm, which uses complex mathematical reasoning to determine whether a very large number is prime.</p>
<p class="indent">In <a href="#calibre_link-53" class="calibre8">Chapter 23</a>, you’ll use the <em class="calibre7">primeNum.py</em> module to write the public key cipher program. At last, you’ll create a cipher that’s easier to use than the one-time pad cipher but cannot be hacked by the simple hacker techniques introduced in this book!</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-790"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">How many prime numbers are there?</p></li>
<li value="2" class="calibre11"><p class="noindent">What are integers that are not prime called?</p></li>
<li value="3" class="calibre11"><p class="noindent">What are two algorithms for finding prime numbers?</p></li>
</ol>
</div>
</div>