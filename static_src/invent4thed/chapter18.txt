
<div id="calibre_link-119" class="calibre">
<h2 class="h1" id="calibre_link-96"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-925" class="calibre1"></span><span class="big"><strong class="calibre2">18</strong></span><br class="calibre9" /><strong class="calibre2">ANIMATING GRAPHICS</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">Now that you’ve learned some <span class="literal1">pygame</span> skills, we’ll write a program to animate boxes that bounce around a window. The boxes are different colors and sizes and move only in diagonal directions. To animate the boxes, we’ll move them a few pixels on each iteration through the game loop. This will make it look like the boxes are moving around the screen.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Animating objects with the game loop</p>
<p class="bull">• Changing the direction of an object</p>
</div>
<h3 class="h2" id="calibre_link-723"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-187" class="calibre1"></span><strong class="calibre2">Sample Run of the Animation Program</strong></h3>
<p class="noindent">When you run the Animation program, it will look something like <a href="#calibre_link-120" class="calibre4">Figure 18-1</a>. The blocks will be bouncing off the edges of the window.</p>
<div class="image"><img src="images/00076.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-120" class="calibre4"></a><em class="calibre6">Figure 18-1: A screenshot of the Animation program</em></p>
<h3 class="h2" id="calibre_link-724"><strong class="calibre2">Source Code for the Animation Program</strong></h3>
<p class="noindent">Enter the following program into the file editor and save it as <em class="calibre6">animation.py</em>. If you get errors after typing in this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="sidenote"><em class="calibre6">animation.py</em></p>
<p class="programs">&nbsp;1. import pygame, sys, time<br class="calibre7" />&nbsp;2. from pygame.locals import *<br class="calibre7" />&nbsp;3.<br class="calibre7" />&nbsp;4. # Set up pygame.<br class="calibre7" />&nbsp;5. pygame.init()<br class="calibre7" />&nbsp;6.<br class="calibre7" />&nbsp;7. # Set up the window.<br class="calibre7" />&nbsp;8. WINDOWWIDTH = 400<br class="calibre7" />&nbsp;9. WINDOWHEIGHT = 400<br class="calibre7" />10. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, 32)<br class="calibre7" />11. pygame.display.set_caption('Animation')<br class="calibre7" />12.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-926"></span>13. # Set up direction variables.<br class="calibre7" />14. DOWNLEFT = 'downleft'<br class="calibre7" />15. DOWNRIGHT = 'downright'<br class="calibre7" />16. UPLEFT = 'upleft'<br class="calibre7" />17. UPRIGHT = 'upright'<br class="calibre7" />18.<br class="calibre7" />19. MOVESPEED = 4<br class="calibre7" />20.<br class="calibre7" />21. # Set up the colors.<br class="calibre7" />22. WHITE = (255, 255, 255)<br class="calibre7" />23. RED = (255, 0, 0)<br class="calibre7" />24. GREEN = (0, 255, 0)<br class="calibre7" />25. BLUE = (0, 0, 255)<br class="calibre7" />26.<br class="calibre7" />27. # Set up the box data structure.<br class="calibre7" />28. b1 = {'rect':pygame.Rect(300, 80, 50, 100), 'color':RED, 'dir':UPRIGHT}<br class="calibre7" />29. b2 = {'rect':pygame.Rect(200, 200, 20, 20), 'color':GREEN, 'dir':UPLEFT}<br class="calibre7" />30. b3 = {'rect':pygame.Rect(100, 150, 60, 60), 'color':BLUE, 'dir':DOWNLEFT}<br class="calibre7" />31. boxes = [b1, b2, b3]<br class="calibre7" />32.<br class="calibre7" />33. # Run the game loop.<br class="calibre7" />34. while True:<br class="calibre7" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check for the QUIT event.<br class="calibre7" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.quit()<br class="calibre7" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()<br class="calibre7" />40.<br class="calibre7" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the white background onto the surface.<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.fill(WHITE)<br class="calibre7" />43.<br class="calibre7" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in boxes:<br class="calibre7" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the box data structure.<br class="calibre7" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left -= MOVESPEED<br class="calibre7" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top += MOVESPEED<br class="calibre7" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left += MOVESPEED<br class="calibre7" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top += MOVESPEED<br class="calibre7" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left -= MOVESPEED<br class="calibre7" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top -= MOVESPEED<br class="calibre7" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left += MOVESPEED<br class="calibre7" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top -= MOVESPEED<br class="calibre7" />58.<br class="calibre7" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check whether the box has moved out of the window.<br class="calibre7" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].top &lt; 0:<br class="calibre7" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the top.<br class="calibre7" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNLEFT<br class="calibre7" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNRIGHT<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-186"></span><br class="calibre7" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].bottom &gt; WINDOWHEIGHT:<br class="calibre7" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the bottom.<br class="calibre7" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPLEFT<br class="calibre7" />70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPRIGHT<br class="calibre7" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].left &lt; 0:<br class="calibre7" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the left side.<br class="calibre7" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNRIGHT<br class="calibre7" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPRIGHT<br class="calibre7" />78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].right &gt; WINDOWWIDTH:<br class="calibre7" />79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the right side.<br class="calibre7" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNLEFT<br class="calibre7" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPLEFT<br class="calibre7" />84.<br class="calibre7" />85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the box onto the surface.<br class="calibre7" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.draw.rect(windowSurface, b['color'], b['rect'])<br class="calibre7" />87.<br class="calibre7" />88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the window onto the screen.<br class="calibre7" />89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()<br class="calibre7" />90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(0.02)</p>
<h3 class="h2" id="calibre_link-725"><strong class="calibre2">Moving and Bouncing the Boxes</strong></h3>
<p class="noindent">In this program, we’ll have three boxes of different colors moving around and bouncing off the walls of a window. In the next chapters, we’ll use this program as a base to make a game in which we control one of the boxes. To do this, first we need to consider how we want the boxes to move.</p>
<p class="indent">Each box will move in one of four diagonal directions. When a box hits the side of the window, it should bounce off and move in a new diagonal direction. The boxes will bounce as shown in <a href="#calibre_link-121" class="calibre4">Figure 18-2</a>.</p>
<div class="image"><img src="images/00005.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-121" class="calibre4"></a><em class="calibre6">Figure 18-2: How boxes will bounce</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-185"></span>The new direction that a box moves after it bounces depends on two things: which direction it was moving before the bounce and which wall it bounced off. There are eight possible ways a box can bounce: two different ways for each of the four walls. For example, if a box is moving down and right and then bounces off the bottom edge of the window, we want the box’s new direction to be up and right.</p>
<p class="indent">We can use a <span class="literal1">Rect</span> object to represent the position and size of the box, a tuple of three integers to represent the color of the box, and an integer to represent which of the four diagonal directions the box is currently moving in.</p>
<p class="indent">The game loop will adjust the x- and y-position of the box in the <span class="literal1">Rect</span> object and draw all the boxes on the screen at their current position on each iteration. As the program execution iterates over the loop, the boxes will gradually move across the screen so that it looks like they’re smoothly moving and bouncing around.</p>
<h3 class="h2" id="calibre_link-726"><strong class="calibre2">Setting Up the Constant Variables</strong></h3>
<p class="noindent">Lines 1 to 5 are just setting up our modules and initializing <span class="literal1">pygame</span> as we did in <a href="#calibre_link-95" class="calibre4">Chapter 17</a>:</p>
<p class="programs">&nbsp;1. import pygame, sys, time<br class="calibre7" />&nbsp;2. from pygame.locals import *<br class="calibre7" />&nbsp;3.<br class="calibre7" />&nbsp;4. # Set up pygame.<br class="calibre7" />&nbsp;5. pygame.init()<br class="calibre7" />&nbsp;6.<br class="calibre7" />&nbsp;7. # Set up the window.<br class="calibre7" />&nbsp;8. WINDOWWIDTH = 400<br class="calibre7" />&nbsp;9. WINDOWHEIGHT = 400<br class="calibre7" />10. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0, 32)<br class="calibre7" />11. pygame.display.set_caption('Animation')</p>
<p class="indent">At lines 8 and 9, we define the two constants for the window width and height, and then in line 10, we use those constants to set up <span class="literal1">windowSurface</span>, which will represent our <span class="literal1">pygame</span> window. Line 11 uses <span class="literal1">set_caption()</span> to set the window’s caption to <span class="literal1">'Animation'</span>.</p>
<p class="indent">In this program, you’ll see that the size of the window’s width and height is used for more than just the call to <span class="literal1">set_mode()</span>. We’ll use constant variables so that if you ever want to change the size of the window, you only have to change lines 8 and 9. Since the window width and height never change during the program’s execution, constant variables are a good idea.</p>
<h4 class="h3" id="calibre_link-727"><em class="calibre10"><strong class="calibre2">Constant Variables for Direction</strong></em></h4>
<p class="noindenta">We’ll use constant variables for each of the four directions the boxes can move in:</p>
<p class="programs">13. # Set up direction variables.<br class="calibre7" />14. DOWNLEFT = 'downleft'<br class="calibre7" />15. DOWNRIGHT = 'downright'<br class="calibre7" />16. UPLEFT = 'upleft'<br class="calibre7" />17. UPRIGHT = 'upright'</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-184"></span>You could have used any value you wanted for these directions instead of using a constant variable. For example, you could use the string <span class="literal1">'downleft'</span> directly to represent the down and left diagonal direction and retype the string every time you need to specify that direction. However, if you ever mistyped the <span class="literal1">'downleft'</span> string, you’d end up with a bug that would cause your program to behave strangely, even though the program wouldn’t crash.</p>
<p class="indent">If you use constant variables instead and accidentally mistype the variable name, Python will notice that there’s no variable with that name and crash the program with an error. This would still be a pretty bad bug, but at least you would know about it immediately and could fix it.</p>
<p class="indent">We also create a constant variable to determine how fast the boxes should move:</p>
<p class="programs">19. MOVESPEED = 4</p>
<p class="indent">The value <span class="literal1">4</span> in the constant variable <span class="literal1">MOVESPEED</span> tells the program how many pixels each box should move on each iteration through the game loop.</p>
<h4 class="h3" id="calibre_link-728"><em class="calibre10"><strong class="calibre2">Constant Variables for Color</strong></em></h4>
<p class="noindenta">Lines 22 to 25 set up constant variables for the colors. Remember, <span class="literal1">pygame</span> uses a tuple of three integer values for the amounts of red, green, and blue, called an RGB value. The integers range from <span class="literal1">0</span> to <span class="literal1">255</span>.</p>
<p class="programs">21. # Set up the colors.<br class="calibre7" />22. WHITE = (255, 255, 255)<br class="calibre7" />23. RED = (255, 0, 0)<br class="calibre7" />24. GREEN = (0, 255, 0)<br class="calibre7" />25. BLUE = (0, 0, 255)</p>
<p class="indent">Constant variables are used for readability, just as in the <span class="literal1">pygame</span> Hello World program.</p>
<h3 class="h2" id="calibre_link-729"><strong class="calibre2">Setting Up the Box Data Structures</strong></h3>
<p class="noindent">Next we’ll define the boxes. To make things simple, we’ll set up a dictionary as a data structure (see “<a href="#calibre_link-122" class="calibre4">The Dictionary Data Type</a>” on <a href="#calibre_link-123" class="calibre4">page 112</a>) to represent each moving box. The dictionary will have the keys <span class="literal1">'rect'</span> (with a <span class="literal1">Rect</span> object for a value), <span class="literal1">'color'</span> (with a tuple of three integers for a value), and <span class="literal1">'dir'</span> (with one of the direction constant variables for a value). We’ll set up just three boxes for now, but you can set up more boxes by defining more data structures. The animation code we’ll use later can be used to animate as many boxes as you define when you set up your data structures.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-133"></span>The variable <span class="literal1">b1</span> will store one of these box data structures:</p>
<p class="programs">27. # Set up the box data structure.<br class="calibre7" />28. b1 = {'rect':pygame.Rect(300, 80, 50, 100), 'color':RED, 'dir':UPRIGHT}</p>
<p class="indent">This box’s top-left corner is located at an x-coordinate of <span class="literal1">300</span> and a y-coordinate of <span class="literal1">80</span>. It has a width of <span class="literal1">50</span> pixels and a height of <span class="literal1">100</span> pixels. Its color is <span class="literal1">RED</span>, and its initial direction is <span class="literal1">UPRIGHT</span>.</p>
<p class="indent">Lines 29 and 30 create two more similar data structures for boxes that are different sizes, positions, colors, and directions:</p>
<p class="programs">29. b2 = {'rect':pygame.Rect(200, 200, 20, 20), 'color':GREEN, 'dir':UPLEFT}<br class="calibre7" />30. b3 = {'rect':pygame.Rect(100, 150, 60, 60), 'color':BLUE, 'dir':DOWNLEFT}<br class="calibre7" />31. boxes = [b1, b2, b3]</p>
<p class="indent">If you needed to retrieve a box or value from the list, you could do so using indexes and keys. Entering <span class="literal1">boxes[0]</span> would access the dictionary data structure in <span class="literal1">b1</span>. If we entered <span class="literal1">boxes[0]['color']</span>, that would access the <span class="literal1">'color'</span> key in <span class="literal1">b1</span>, so the expression <span class="literal1">boxes[0]['color']</span> would evaluate to <span class="literal1">(255, 0, 0)</span>. You can refer to any of the values in any of the box data structures by starting with <span class="literal1">boxes</span>. The three dictionaries, <span class="literal1">b1</span>, <span class="literal1">b2</span>, and <span class="literal1">b3</span>, are then stored in a list in the <span class="literal1">boxes</span> variable.</p>
<h3 class="h2" id="calibre_link-730"><strong class="calibre2">The Game Loop</strong></h3>
<p class="noindent">The game loop handles animating the moving boxes. Animations work by drawing a series of pictures with slight differences that are shown one right after another. In our animation, the pictures will be of the moving boxes and the slight differences will be in each box’s position. Each box will move by 4 pixels in each picture. The pictures are shown so fast that the boxes will look like they are moving smoothly across the screen. If a box hits the side of the window, then the game loop will make the box bounce by changing its direction.</p>
<p class="indent">Now that we know a little bit about how the game loop will work, let’s code it!</p>
<h4 class="h3" id="calibre_link-132"><em class="calibre10"><strong class="calibre2">Handling When the Player Quits</strong></em></h4>
<p class="noindenta">When the player quits by closing the window, we need to stop the program in the same way we did the <span class="literal1">pygame</span> Hello World program. We need to do this in the game loop so that our program is constantly checking whether there has been a <span class="literal1">QUIT</span> event. Line 34 starts the loop, and lines 36 to 39 handle quitting:</p>
<p class="programs">33. # Run the game loop.<br class="calibre7" />34. while True:<br class="calibre7" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check for the QUIT event.<br class="calibre7" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.quit()<br class="calibre7" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-127"></span>After that, we want to make sure that <span class="literal1">windowSurface</span> is ready to be drawn on. Later, we’ll draw each box on <span class="literal1">windowSurface</span> with the <span class="literal1">rect()</span> method. On each iteration through the game loop, the code redraws the entire window with new boxes that are located a few pixels over each time. When we do that, we’re not redrawing the whole <span class="literal1">Surface</span> object; instead, we’re just adding a drawing of the <span class="literal1">Rect</span> object to <span class="literal1">windowSurface</span>. But when the game loop iterates to draw all the <span class="literal1">Rect</span> objects again, it redraws every <span class="literal1">Rect</span> and doesn’t erase the old <span class="literal1">Rect</span> drawing. If we just let the game loop keep drawing <span class="literal1">Rect</span> objects on the screen, we’ll end up with a trail of <span class="literal1">Rect</span> objects instead of a smooth animation. To avoid that, we need to clear the window for every iteration of the game loop.</p>
<p class="indent">In order to do that, line 42 fills the entire <span class="literal1">Surface</span> with white so that anything previously drawn on it is erased:</p>
<p class="programs">41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the white background onto the surface.<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.fill(WHITE)</p>
<p class="indent">Without calling <span class="literal1">windowSurface.fill(WHITE)</span> to white out the entire window before drawing the rectangles in their new position, you would have a trail of <span class="literal1">Rect</span> objects. If you want to try it out and see what happens, you can comment out line 42 by putting a <span class="literal1">#</span> at the beginning of the line.</p>
<p class="indent">Once <span class="literal1">windowSurface</span> is filled, we can start drawing all of our <span class="literal1">Rect</span> objects.</p>
<h4 class="h3" id="calibre_link-126"><em class="calibre10"><strong class="calibre2">Moving Each Box</strong></em></h4>
<p class="noindenta">In order to update the position of each box, we need to iterate over the <span class="literal1">boxes</span> list inside the game loop:</p>
<p class="programs">44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in boxes:</p>
<p class="indent">Inside the <span class="literal1">for</span> loop, you’ll refer to the current box as <span class="literal1">b</span> to make the code easier to type. We need to change each box depending on the direction it is already moving, so we’ll use <span class="literal1">if</span> statements to figure out the box’s direction by checking the <span class="literal1">dir</span> key inside the box data structure. Then we’ll change the box’s position depending on the direction the box is moving.</p>
<p class="programs">45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the box data structure.<br class="calibre7" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left -= MOVESPEED<br class="calibre7" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top += MOVESPEED<br class="calibre7" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left += MOVESPEED<br class="calibre7" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top += MOVESPEED<br class="calibre7" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left -= MOVESPEED<br class="calibre7" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top -= MOVESPEED<br class="calibre7" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].left += MOVESPEED<br class="calibre7" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].top -= MOVESPEED</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-927"></span>The new value to set the <span class="literal1">left</span> and <span class="literal1">top</span> attributes of each box to depends on the box’s direction. If the direction is either <span class="literal1">DOWNLEFT</span> or <span class="literal1">DOWNRIGHT</span>, you want to <em class="calibre6">increase</em> the <span class="literal1">top</span> attribute. If the direction is <span class="literal1">UPLEFT</span> or <span class="literal1">UPRIGHT</span>, you want to <em class="calibre6">decrease</em> the <span class="literal1">top</span> attribute.</p>
<p class="indent">If the box’s direction is <span class="literal1">DOWNRIGHT</span> or <span class="literal1">UPRIGHT</span>, you want to <em class="calibre6">increase</em> the <span class="literal1">left</span> attribute. If the direction is <span class="literal1">DOWNLEFT</span> or <span class="literal1">UPLEFT</span>, you want to <em class="calibre6">decrease</em> the <span class="literal1">left</span> attribute.</p>
<p class="indent">The value of these attributes will increase or decrease by the amount of the integer stored in <span class="literal1">MOVESPEED</span>, which stores how many pixels the boxes move on each iteration through the game loop. We set <span class="literal1">MOVESPEED</span> on line 19.</p>
<p class="indent">For example, if <span class="literal1">b['dir']</span> is set to <span class="literal1">'downleft'</span>, <span class="literal1">b['rect'].left</span> to <span class="literal1">40</span>, and <span class="literal1">b['rect'].top</span> to <span class="literal1">100</span>, then the condition on line 46 will be <span class="literal1">True</span>. If <span class="literal1">MOVESPEED</span> is set to <span class="literal1">4</span>, then lines 47 and 48 will change the <span class="literal1">Rect</span> object so that <span class="literal1">b['rect'].left</span> is <span class="literal1">36</span> and <span class="literal1">b['rect'].top</span> is <span class="literal1">104</span>. Changing the <span class="literal1">Rect</span> value then causes the drawing code on line 86 to draw the rectangle slightly down and to the left of its previous position.</p>
<h4 class="h3" id="calibre_link-731"><em class="calibre10"><strong class="calibre2">Bouncing a Box</strong></em></h4>
<p class="noindenta">After lines 44 to 57 have moved the box, we need to check whether the box has gone past the edge of the window. If it has, you want to bounce the box. In the code, this means the <span class="literal1">for</span> loop will set a new value for the box’s <span class="literal1">'dir'</span> key. The box will move in the new direction on the next iteration of the game loop. This makes it look like the box has bounced off the side of the window.</p>
<p class="indent">In the <span class="literal1">if</span> statement on line 60, we determine that the box has moved past the top edge of the window if the <span class="literal1">top</span> attribute of the box’s <span class="literal1">Rect</span> object is less than <span class="literal1">0</span>:</p>
<p class="programs">59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check whether the box has moved out of the window.<br class="calibre7" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].top &lt; 0:<br class="calibre7" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the top.<br class="calibre7" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNLEFT<br class="calibre7" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNRIGHT</p>
<p class="indent">In that case, the direction will be changed based on which direction the box was moving. If the box was moving <span class="literal1">UPLEFT</span>, then it will now move <span class="literal1">DOWNLEFT</span>; if it was moving <span class="literal1">UPRIGHT</span>, it will now move <span class="literal1">DOWNRIGHT</span>.</p>
<p class="indent">Lines 66 to 71 handle the situation in which the box has moved past the bottom edge of the window:</p>
<p class="programs">66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].bottom &gt; WINDOWHEIGHT:<br class="calibre7" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the bottom.<br class="calibre7" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPLEFT<br class="calibre7" />70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPRIGHT</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-344"></span>These lines check whether the <span class="literal1">bottom</span> attribute (not the <span class="literal1">top</span> attribute) is <em class="calibre6">greater</em> than the value in <span class="literal1">WINDOWHEIGHT</span>. Remember that the y-coordinates start at <span class="literal1">0</span> at the top of the window and increase to <span class="literal1">WINDOWHEIGHT</span> at the bottom.</p>
<p class="indent">Lines 72 to 83 handle the behavior of the boxes when they bounce off the sides:</p>
<p class="programs">72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].left &lt; 0:<br class="calibre7" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the left side.<br class="calibre7" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNLEFT:<br class="calibre7" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNRIGHT<br class="calibre7" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPLEFT:<br class="calibre7" />77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPRIGHT<br class="calibre7" />78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].right &gt; WINDOWWIDTH:<br class="calibre7" />79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The box has moved past the right side.<br class="calibre7" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == DOWNRIGHT:<br class="calibre7" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = DOWNLEFT<br class="calibre7" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['dir'] == UPRIGHT:<br class="calibre7" />83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['dir'] = UPLEFT</p>
<p class="indent">Lines 78 to 83 are similar to lines 72 to 77 but check whether the right side of the box has moved past the window’s right edge. Remember, the x-coordinates start at <span class="literal1">0</span> on the window’s left edge and increase to <span class="literal1">WINDOWWIDTH</span> on the window’s right edge.</p>
<h4 class="h3" id="calibre_link-732"><em class="calibre10"><strong class="calibre2">Drawing the Boxes on the Window in Their New Positions</strong></em></h4>
<p class="noindenta">Every time the boxes move, we need to draw them in their new positions on <span class="literal1">windowSurface</span> by calling the <span class="literal1">pygame.draw.rect()</span> function:</p>
<p class="programs">85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the box onto the surface.<br class="calibre7" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.draw.rect(windowSurface, b['color'], b['rect'])</p>
<p class="indent">You need to pass <span class="literal1">windowSurface</span> to the function because it is the <span class="literal1">Surface</span> object to draw the rectangle on. Pass <span class="literal1">b['color']</span> to the function because it is the rectangle’s color. Finally, pass <span class="literal1">b['rect']</span> because it is the <span class="literal1">Rect</span> object with the position and size of the rectangle to draw.</p>
<p class="indent">Line 86 is the last line of the <span class="literal1">for</span> loop.</p>
<h4 class="h3" id="calibre_link-733"><em class="calibre10"><strong class="calibre2">Drawing the Window on the Screen</strong></em></h4>
<p class="noindenta">After the <span class="literal1">for</span> loop, each box in the <span class="literal1">boxes</span> list will be drawn, so you need to call <span class="literal1">pygame.display.update()</span> to draw <span class="literal1">windowSurface</span> on the screen:</p>
<p class="programs">88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the window onto the screen.<br class="calibre7" />89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()<br class="calibre7" />90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;time.sleep(0.02)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-340"></span>The computer can move, bounce, and draw the boxes so fast that if the program ran at full speed, all the boxes would look like a blur. In order to make the program run slowly enough that we can see the boxes, we need to add <span class="literal1">time.sleep(0.02)</span>. You can try commenting out the <span class="literal1">time.sleep(0.02)</span> line and running the program to see what it looks like. The call to <span class="literal1">time.sleep()</span> will pause the program for 0.02 seconds, or 20 milliseconds, between each movement of the boxes.</p>
<p class="indent">After this line, execution returns to the start of the game loop and begins the process all over again. This way, the boxes are constantly moving a little, bouncing off the walls, and being drawn on the screen in their new positions.</p>
<h3 class="h2" id="calibre_link-734"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">This chapter has presented a whole new way of creating computer programs. The previous chapters’ programs would stop and wait for the player to enter text. However, in our Animation program, the program constantly updates the data structures without waiting for input from the player.</p>
<p class="indent">Remember that we had data structures that would represent the state of the board in our Hangman and Tic-Tac-Toe games. These data structures were passed to a <span class="literal1">drawBoard()</span> function to be displayed on the screen. Our Animation program is similar. The <span class="literal1">boxes</span> variable holds a list of data structures representing boxes to be drawn to the screen, and these are drawn inside the game loop.</p>
<p class="indent">But without calls to <span class="literal1">input()</span>, how do we get input from the player? In <a href="#calibre_link-97" class="calibre4">Chapter 19</a>, we’ll cover how programs know when the player presses keys on the keyboard. We’ll also learn about a new concept called collision detection.<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-928"></span></p>
</div>
