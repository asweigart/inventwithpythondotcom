

<div type="bodymatter chapter" class="calibre1" id="calibre_link-181">
<section class="toclist">
<header class="calibre12">
<h1 class="chaptertitle">
<span class="partnumber"><span type="pagebreak" title="153" id="calibre_link-494" class="calibre26"></span>9</span><br class="calibre18" />
<span class="parttitle1">Esoteric Python Oddities</span>
</h1>
</header>
<figure class="opener"><img src="images/000017.png" alt="" class="calibre15" /></figure><p class="chapterintro">The systems of rules that define a programming language are complicated and can lead to code that, although not wrong, is quite odd and unexpected. This chapter dives into the more obscure Python language oddities. You’re unlikely to actually run into these cases in real-world coding, but they’re interesting uses of the Python syntax (or abuses of it, depending on your perspective). </p>
<p class="calibre22">By studying the examples in this chapter, you’ll get a better idea of how Python works under the hood. Let’s have a little fun and explore some esoteric gotchas.</p>
<h2 id="calibre_link-182" class="calibre7"><span type="pagebreak" title="154" id="calibre_link-495" class="calibre20"></span>Why 256 Is 256 but 257 Is Not 257</h2>
<p class="bodyfirst">The <code class="calibre9">==</code> operator compares two objects for equal value, but the <code class="calibre9">is</code> operator compares them for equal identity. Although the integer value <code class="calibre9">42</code> and the float value <code class="calibre9">42.0</code> have the same value, they’re two different objects held in separate places in the computer’s memory. You can confirm this by checking their different IDs using the <code class="calibre9">id()</code> function:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">a = 42</b>
&gt;&gt;&gt; <b class="calibre25">b = 42.0</b>
&gt;&gt;&gt; <b class="calibre25">a == b</b>
True
&gt;&gt;&gt; <b class="calibre25">a is b</b>
False
&gt;&gt;&gt; <b class="calibre25">id(a), id(b)</b>
(140718571382896, 2526629638888)</code></pre>
<p class="calibre23">When Python creates a new integer object and stores it in memory, that object creation takes very little time. As a tiny optimization, CPython (the Python interpreter available for download at <a href="https://python.org" class="calibre19">https://python.org</a>) creates integer objects for <code class="calibre9">-5</code> to <code class="calibre9">256</code> at the start of every program. These integers are called <em class="calibre10">preallocated integers</em>, and CPython automatically creates objects for them because they’re fairly common: a program is more likely to use the integer <code class="calibre9">0</code> or <code class="calibre9">2</code> than, say, <code class="calibre9">1729</code>. When creating a new integer object in memory, CPython first checks whether it’s between <code class="calibre9">-5</code> and <code class="calibre9">256</code>. If so, CPython saves time by simply returning the existing integer object instead of creating a new one. This behavior also saves memory by not storing duplicate small integers, as illustrated in <a id="calibre_link-682" href="#calibre_link-331" class="calibre19">Figure 9-1</a>.</p>
<figure class="calibre29">
<img src="images/000016.png" alt="f09001" class="calibre15" />
<figcaption class="calibre30"><p class="calibre31"><a id="calibre_link-331" href="#calibre_link-682" class="calibre19">Figure 9-1:</a> Python saves memory by using multiple references to a single integer object (left) instead of separate, duplicate integer objects for each reference (right).</p></figcaption>
</figure>
<p class="calibre23">Because of this optimization, certain contrived situations can produce bizarre results. To see an example of one, enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">a = 256</b>
&gt;&gt;&gt; <b class="calibre25">b = 256</b>
<span class="codeannotationhang">1</span> &gt;&gt;&gt; <b class="calibre25">a is b</b>
True
&gt;&gt;&gt; <b class="calibre25">c = 257</b>
&gt;&gt;&gt; <b class="calibre25">d = 257</b>
<span class="codeannotationhang">2</span> &gt;&gt;&gt; <b class="calibre25">c is d</b>
False</code></pre>
<p class="calibre23"><span type="pagebreak" title="155" id="calibre_link-496" class="calibre16"></span>All 256 objects are really the same object, so the <code class="calibre9">is</code> operator for <code class="calibre9">a</code> and <code class="calibre9">b</code> returns <code class="calibre9">True</code><span class="codeannotation">1</span>. But Python created separate 257 objects for <code class="calibre9">c</code> and <code class="calibre9">d</code>, which is why the <code class="calibre9">is</code> operator returns <code class="calibre9">False</code><span class="codeannotation">2</span>. </p>
<p class="calibre23">The expression <code class="calibre9">257 is 257</code> evaluates to <code class="calibre9">True</code>, but CPython reuses the integer object made for identical literals in the same statement:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">257 is 257</b>
True</code></pre>
<p class="calibre23">Of course, real-world programs usually only use an integer’s value, not its identity. They would never use the <code class="calibre9">is</code> operator to compare integers, floats, strings, bools, or values of other simple data types. One exception occurs when you use <code class="calibre9">is None</code> instead of <code class="calibre9">== None</code>, as explained in “Use is to Compare with None Instead of <em class="calibre10">==</em>” on page 96. Otherwise, you’ll rarely run into this problem.</p>
<h2 id="calibre_link-183" class="calibre7">String Interning</h2>
<p class="bodyfirst">Similarly, Python reuses objects to represent identical string literals in your code rather than making separate copies of the same string. To see this in practice, enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = 'cat'</b>
&gt;&gt;&gt; <b class="calibre25">eggs = 'cat'</b>
&gt;&gt;&gt; <b class="calibre25">spam is eggs</b>
True
&gt;&gt;&gt; <b class="calibre25">id(spam), id(eggs)</b>
(1285806577904, 1285806577904)</code></pre>
<p class="calibre23">Python notices that the <code class="calibre9">'cat'</code> string literal assigned to <code class="calibre9">eggs</code> is the same as the <code class="calibre9">'cat'</code> string literal assigned to <code class="calibre9">spam</code>; so instead of making a second, redundant string object, it just assigns <code class="calibre9">eggs</code> a reference to the same string object that <code class="calibre9">spam</code> uses. This explains why the IDs of their strings are the same.</p>
<p class="calibre23">This optimization is called <em class="calibre10">string interning</em>, and like the preallocated integers, it’s nothing more than a CPython implementation detail. You should never write code that relies on it. Also, this optimization won’t catch every possible identical string. Trying to identify every instance in which you can use an optimization often takes up more time than the optimization would save. For example, try creating the <code class="calibre9">'cat'</code> string from <code class="calibre9">'c'</code> and <code class="calibre9">'at'</code> in the interactive shell; you’ll notice that CPython creates the final <code class="calibre9">'cat'</code> string as a new string object rather than reusing the string object made for <code class="calibre9">spam</code>:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">bacon = 'c'</b>
&gt;&gt;&gt; <b class="calibre25">bacon += 'at'</b>
&gt;&gt;&gt; <b class="calibre25">spam is bacon</b>
False
&gt;&gt;&gt; <b class="calibre25">id(spam), id(bacon)</b>
(1285806577904, 1285808207384)</code></pre>
<p class="calibre23"><span type="pagebreak" title="156" id="calibre_link-497" class="calibre16"></span>String interning is an optimization technique that interpreters and compilers use for many different languages. You’ll find further details at <a href="https://en.wikipedia.org/wiki/String_interning" class="calibre19">https://en.wikipedia.org/wiki/String_interning</a>.</p>
<h2 id="calibre_link-184" class="calibre7">Python’s Fake Increment and Decrement Operators</h2>
<p class="bodyfirst">In Python, you can increase the value of a variable by <code class="calibre9">1</code> or reduce it by <code class="calibre9">1</code> using the augmented assignment operators. The code <code class="calibre9">spam += 1</code> and <code class="calibre9">spam -= 1</code> increments and decrements the numeric values in <code class="calibre9">spam</code> by <code class="calibre9">1</code>, respectively.</p>
<p class="calibre23">Other languages, such as C++ and JavaScript, have the <code class="calibre9">++</code> and <code class="calibre9">--</code> operators for incrementing and decrementing. (The name “C++” itself reflects this; it’s a tongue-in-cheek joke that indicates it’s an enhanced form of the C language.) Code in C++ and JavaScript could have operations like <code class="calibre9">++spam</code> or <code class="calibre9">spam++</code>. Python wisely doesn’t include these operators because they’re notoriously susceptible to subtle bugs (as discussed at <a href="https://softwareengineering.stackexchange.com/q/59880" class="calibre19">https://softwareengineering.stackexchange.com/q/59880</a>).</p>
<p class="calibre23">But it’s perfectly legal to have the following Python code:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = --spam</b>
&gt;&gt;&gt; <b class="calibre25">spam</b>
42</code></pre>
<p class="calibre23">The first detail you should notice is that the <code class="calibre9">++</code> and <code class="calibre9">--</code> “operators” in Python don’t actually increment or decrement the value in <em class="calibre10">spam</em>. Rather, the leading <code class="calibre9">-</code> is Python’s unary negation operator. It allows you to write code like this:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = 42</b>
&gt;&gt;&gt; <b class="calibre25">-spam</b>
-42</code></pre>
<p class="calibre23">It’s legal to have multiple unary negative operators in front of a value. Using two of them gives you the negative of the negative of the value, which for integer values just evaluates to the original value:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = 42</b>
&gt;&gt;&gt; <b class="calibre25">-(-spam)</b>
42</code></pre>
<p class="calibre23">This is a very silly operation to perform, and you likely won’t ever see a unary negation operator used twice in real-world code. (But if you did, it’s probably because the programmer learned to program in another language and has just written buggy Python code!) </p>
<p class="calibre23">There is also a <code class="calibre9">+</code> unary operator. It evaluates an integer value to the same sign as the original value, which is to say, it does absolutely nothing:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = 42</b>
&gt;&gt;&gt; <b class="calibre25">+spam</b>
42
&gt;&gt;&gt; <b class="calibre25">spam = -42</b>
<span type="pagebreak" title="157" id="calibre_link-498" class="calibre16"></span>&gt;&gt;&gt; <b class="calibre25">+spam</b>
-42</code></pre>
<p class="calibre23">Writing <code class="calibre9">+42</code> (or <code class="calibre9">++42</code>) seems just as silly as <code class="calibre9">--42</code>, so why does Python even have this unary operator? It exists only to complement the <code class="calibre9">-</code> operator if you need to overload these operators for your own classes. (That’s a lot of terms you might not be familiar with! You’ll learn more about operator overloading in <span class="calibre" itemid="xref_target_Chapter 17">Chapter 17</span>.)</p>
<p class="calibre23">The <code class="calibre9">+</code> and <code class="calibre9">-</code> unary operators are only valid when in front of a Python value, not after it. Although <code class="calibre9">spam++</code> and <code class="calibre9">spam--</code> might be legal code in C++ or JavaScript, they produce syntax errors in Python:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam++</b>
  File "&lt;stdin&gt;", line 1
    spam++
         ^
SyntaxError: invalid syntax</code></pre>
<p class="calibre23">Python doesn’t have increment and decrement operators. A quirk of the language syntax merely makes it seem like it does.</p>
<h2 id="calibre_link-185" class="calibre7">All of Nothing</h2>
<p class="bodyfirst">The <code class="calibre9">all()</code> built-in function accepts a sequence value, such as a list, and returns <code class="calibre9">True</code> if all the values in that sequence are “truthy.” It returns <code class="calibre9">False</code> if one or more values are “falsey.” You can think of the function call <code class="calibre9">all([False, True, True])</code> as equivalent to the expression <code class="calibre9">False and True and True</code>. </p>
<p class="calibre23">You can use <code class="calibre9">all()</code> in conjunction with list comprehensions to first create a list of Boolean values based on another list and then evaluate their collective value. For example, enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = [67, 39, 20, 55, 13, 45, 44]</b>
&gt;&gt;&gt; <b class="calibre25">[i &gt; 42 for i in spam]</b>
[True, False, False, True, False, True, True]
&gt;&gt;&gt; <b class="calibre25">all([i &gt; 42 for i in spam])</b>
False
&gt;&gt;&gt; <b class="calibre25">eggs = [43, 44, 45, 46]</b>
&gt;&gt;&gt; <b class="calibre25">all([i &gt; 42 for i in eggs])</b>
True</code></pre>
<p class="calibre23">The <code class="calibre9">all()</code> utility returns <code class="calibre9">True</code> if all numbers in <code class="calibre9">spam</code> or <code class="calibre9">eggs</code> are greater than 42. </p>
<p class="calibre23">But if you pass an empty sequence to <code class="calibre9">all()</code>, it always returns <code class="calibre9">True</code>. Enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">all([])</b>
True</code></pre>
<p class="calibre23">It’s best to think of <code class="calibre9">all([])</code> as evaluating the claim “none of the items in this list are falsey” instead of “all the items in this list are truthy.” Otherwise, <span type="pagebreak" title="158" id="calibre_link-499" class="calibre16"></span>you might get some odd results. For instance, enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">spam = []</b>
&gt;&gt;&gt; <b class="calibre25">all([i &gt; 42 for i in spam])</b>
True
&gt;&gt;&gt; <b class="calibre25">all([i &lt; 42 for i in spam])</b>
True
&gt;&gt;&gt; <b class="calibre25">all([i == 42 for i in spam])</b>
True</code></pre>
<p class="calibre23">This code seems to be showing that not only are all the values in <code class="calibre9">spam</code> (an empty list) greater than <code class="calibre9">42</code>, but they’re also less than <code class="calibre9">42</code> and exactly equal to <code class="calibre9">42</code>! This seems logically impossible. But remember that each of these three list comprehensions evaluates to the empty list, which is why none of the items in them are falsey and the <code class="calibre9">all()</code> function returns <code class="calibre9">True</code>. </p>
<h2 id="calibre_link-186" class="calibre7">Boolean Values Are Integer Values</h2>
<p class="bodyfirst">Just as Python considers the float value <code class="calibre9">42.0</code> to be equal to the integer value <code class="calibre9">42</code>, it considers the Boolean values <code class="calibre9">True</code> and <code class="calibre9">False</code> to be equivalent to <code class="calibre9">1</code> and <code class="calibre9">0</code>, respectively. In Python, the <code class="calibre9">bool</code> data type is a subclass of the <code class="calibre9">int</code> data type. (We’ll cover classes and subclasses in <span class="calibre" itemid="xref_target_Chapter 16">Chapter 16</span>.) You can use <code class="calibre9">int()</code> to convert Boolean values to integers: </p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">int(False) </b>
0
&gt;&gt;&gt; <b class="calibre25">int(True) </b>
1
&gt;&gt;&gt; <b class="calibre25">True == 1 </b>
True
&gt;&gt;&gt; <b class="calibre25">False == 0</b>
True</code></pre>
<p class="calibre23">You can also use <code class="calibre9">isinstance()</code> to confirm that a Boolean value is considered a type of integer:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">isinstance(True, bool) </b>
True
&gt;&gt;&gt; <b class="calibre25">isinstance(True, int) </b>
True</code></pre>
<p class="calibre23">The value <code class="calibre9">True</code> is of the <code class="calibre9">bool</code> data type. But because <code class="calibre9">bool</code> is a subclass of<code class="calibre9"> int</code>, <code class="calibre9">True</code> is also an <code class="calibre9">int</code>. This means you can use <code class="calibre9">True</code> and <code class="calibre9">False</code> in almost any place you can use integers. This can lead to some bizarre code:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">True + False + True + True</b>  # Same as 1 + 0 + 1 + 1
3
&gt;&gt;&gt; <b class="calibre25">-True</b>            # Same as -1.
-1
<span type="pagebreak" title="159" id="calibre_link-500" class="calibre16"></span>&gt;&gt;&gt; <b class="calibre25">42 * True</b>        # Same as 42 * 1 mathematical multiplication.
42
&gt;&gt;&gt; <b class="calibre25">'hello' * False</b>  # Same as 'hello' * 0 string replication.
' '
&gt;&gt;&gt; <b class="calibre25">'hello'[False]</b>   # Same as 'hello'[0]
'h'
&gt;&gt;&gt; <b class="calibre25">'hello'[True]</b>    # Same as 'hello'[1]
'e'
&gt;&gt;&gt; <b class="calibre25">'hello'[-True]</b>   # Same as 'hello'[-1]
'o'</code></pre>
<p class="calibre23">Of course, just because you can use <code class="calibre9">bool</code> values as numbers doesn’t mean you should. The previous examples are all unreadable and should never be used in real-world code. Originally, Python didn’t have a <code class="calibre9">bool</code> data type. It didn’t add Booleans until Python 2.3, at which point it made <code class="calibre9">bool</code> a subclass of <code class="calibre9">int</code> to ease the implementation. You can read the history of the<code class="calibre9"> bool</code> data type in PEP 285 at <a href="https://www.python.org/dev/peps/pep-0285/" class="calibre19">https://www.python.org/dev/peps/pep-0285/</a>.</p>
<p class="calibre23">Incidentally, <code class="calibre9">True</code> and <code class="calibre9">False</code> were only made keywords in Python 3. This means that in Python 2, it was possible to use <code class="calibre9">True</code> and <code class="calibre9">False</code> as variable names, leading to seemingly paradoxical code like this:</p>
<pre class="calibre28"><code class="calibre9">Python 2.7.14 (v2.7.14:84471935ed, Sep 16 2017, 20:25:58) [MSC v.1500 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; <b class="calibre25">True is False</b>
False
&gt;&gt;&gt; <b class="calibre25">True = False</b>
&gt;&gt;&gt; <b class="calibre25">True is False </b>
True</code></pre>
<p class="calibre23">Fortunately, this sort of confusing code isn’t possible in Python 3, which will raise a syntax error if you try to use the keywords <code class="calibre9">True</code> or <code class="calibre9">False</code> as variable names.</p>
<h2 id="calibre_link-187" class="calibre7">Chaining Multiple Kinds of Operators</h2>
<p class="bodyfirst">Chaining different kinds of operators in the same expression can produce unexpected bugs. For example, this (admittedly unrealistic) example uses the <code class="calibre9">==</code> and <code class="calibre9">in</code> operators in a single expression:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">False == False in [False]</b>
True</code></pre>
<p class="calibre23">This <code class="calibre9">True</code> result is surprising, because you would expect it to evaluate as either:</p>
<ul class="calibre36">
<li class="calibre11"><code class="calibre9">(False == False) in [False]</code>, which is <code class="calibre9">False</code>.</li>
<li class="calibre11"><code class="calibre9">False == (False in [False])</code>, which is also <code class="calibre9">False</code>.</li>
</ul>
<p class="calibre23">But <code class="calibre9">False == False in [False]</code> isn’t equivalent to either of these expressions. Rather, it’s equivalent to <code class="calibre9">(False == False) and (False in [False])</code>, just <span type="pagebreak" title="160" id="calibre_link-501" class="calibre16"></span>as <code class="calibre9">42 &lt; spam &lt; 99</code> is equivalent to <code class="calibre9">(42 &lt; spam) and (spam &lt; 99)</code>. This expression evaluates according to the following diagram:</p>
<figure class="calibre29">
<img src="images/000007.png" alt="g09001" class="calibre15" />
</figure>
<p class="calibre23">The <code class="calibre9">False == False in [False]</code> expression is a fun Python riddle, but it’s unlikely to come up in any real-world code.</p>
<h2 id="calibre_link-188" class="calibre7">Python’s Antigravity Feature</h2>
<p class="bodyfirst">To enable Python’s antigravity feature, enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">import antigravity</b></code></pre>
<p class="calibre23">This line is a fun Easter egg that opens the web browser to a classic XKCD comic strip about Python at <a href="https://xkcd.com/353/" class="calibre19">https://xkcd.com/353/</a>. It might surprise you that Python can open your web browser, but this is a built-in feature the <code class="calibre9">webbrowser</code> module provides. Python’s <code class="calibre9">webbrowser</code> module has an <code class="calibre9">open()</code> function that finds your operating system’s default web browser and opens a browser window to a specific URL. Enter the following into the interactive shell:</p>
<pre class="calibre28"><code class="calibre9">&gt;&gt;&gt; <b class="calibre25">import webbrowser</b>
&gt;&gt;&gt; <b class="calibre25">webbrowser.open('https://xkcd.com/353/')</b></code></pre>
<p class="calibre23">The <code class="calibre9">webbrowser</code> module is limited, but it can be useful for directing the user to further information on the internet.</p>
<h2 id="calibre_link-189" class="calibre7">Summary</h2>
<p class="bodyfirst">It’s easy to forget that computers and programming languages are designed by humans and have their own limitations. So much software is built on top of and relies upon the creations of language designers and hardware engineers. They work incredibly hard to make sure that if you have a bug in your program, it’s because your program is faulty, not the interpreter software or CPU hardware running it. We can end up taking these tools for granted.</p>
<p class="calibre23">But this is why there’s value in learning the odd nooks and crannies of computers and software. When your code raises errors or crashes (or even just acts weirdly and makes you think, “that’s odd”), you’ll need to understand the common gotchas to debug these problems.</p>
<p class="calibre23">You almost certainly won’t run into any of the issues brought up in this chapter, but being aware of these small details is what will make you an experienced Python programmer.</p>
</section>
</div>