


<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter20.html">Previous Chapter - Hacking the Vigenère Cipher</a> | <a href="chapter22.html">Next Chapter - Finding and Generating Prime Numbers</a></div>
<div id="calibre_link-30" class="calibre">
<h2 class="h2a1" id="calibre_link-50"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-988" class="calibre1"></span><span class="big">21</span><br class="calibre15" />THE ONE-TIME PAD CIPHER</h2>
<p class="epigraph"><em class="calibre7">“I’ve been over it a thousand times,” Waterhouse says, “and the only explanation I can think of is that they are converting their messages into large binary numbers and then combining them with other large binary numbers&mdash;one-time pads, most likely.”<br class="calibre9" />“In which case your project is doomed,” Alan says, “because you can’t break a one-time pad.”<br class="calibre9" />&mdash;Neal Stephenson,</em> Cryptonomicon</p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In this chapter, you’ll learn about a cipher that is impossible to crack, no matter how powerful your computer is, how much time you spend trying to crack it, or how clever a hacker you are. It’s called the <em class="calibre7">one-time pad cipher</em>, and the good news is that we don’t have to write a new program to use it! The Vigenère cipher program you wrote in <a href="#calibre_link-31" class="calibre8">Chapter 18</a> can implement this cipher without any changes. But the one-time pad cipher is so inconvenient to use on a regular basis that it’s often reserved for the most top-secret of messages.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-298"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• The unbreakable one-time pad cipher</p>
<p class="bull">• The two-time pad is the Vigenère cipher</p>
</div>
<h3 class="h1" id="calibre_link-772"><strong class="calibre3">The Unbreakable One-Time Pad Cipher</strong></h3>
<p class="noindent">The one-time pad cipher is a Vigenère cipher that becomes unbreakable when the key meets the following criteria:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">It is exactly as long as the encrypted message.</p></li>
<li value="2" class="calibre11"><p class="noindent">It is made up of truly random symbols.</p></li>
<li value="3" class="calibre11"><p class="noindent">It is used only once and never again for any other message.</p></li>
</ol>
<p class="indent">By following these three rules, you can make your encrypted message invulnerable to any cryptanalyst’s attack. Even with infinite computing power, the cipher cannot be broken.</p>
<p class="indent">The key for the one-time pad cipher is called a <em class="calibre7">pad</em> because the keys used to be printed on pads of paper. After the top sheet of paper was used, it would be torn off the pad to reveal the next key to use. Usually, a large list of one-time pad keys is generated and shared in person, and the keys are marked for specific dates. For example, if we received a message from our collaborator on October 31, we would just look through the list of one-time pads to find the corresponding key for that day.</p>
<h4 class="h2" id="calibre_link-773"><strong class="calibre3"><em class="calibre12">Making Key Length Equal Message Length</em></strong></h4>
<p class="noindent">To understand why the one-time pad cipher is unbreakable, let’s think about what makes the regular Vigenère cipher vulnerable to attack. Recall that the Vigenère cipher&ndash;hacking program works by using frequency analysis. But if the key is the same length as the message, each plaintext letter’s subkey is unique, meaning that each plaintext letter could be encrypted to any ciphertext letter with equal probability.</p>
<p class="indent">For example, to encrypt the message IF YOU WANT TO SURVIVE OUT HERE, YOU’VE GOT TO KNOW WHERE YOUR TOWEL IS, we remove the spaces and punctuation to get a message that has 55 letters. To encrypt this message using a one-time pad, we need a key that is also 55 letters long. Using the example key KCQYZHEPXAUTIQEKXEJMORETZHZTRWWQDYLBTTVEJMEDBSANYBPXQIK to encrypt the string would result in the ciphertext SHOMTDECQTILCHZSSIXGHYIKDFNNMACEWRZLGHRAQQVHZGUERPLBBQC, as shown in <a href="#calibre_link-32" class="calibre8">Figure 21-1</a>.</p>
<div class="image"><img src="images/00038.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-32" class="calibre8"></a><em class="calibre7">Figure 21-1: Encrypting an example message using a one-time pad</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-989"></span>Now imagine that a cryptanalyst gets hold of the ciphertext (SHOM TDEC...). How could they attack the cipher? Brute-forcing through the keys wouldn’t work, because there are too many even for a computer. The number of keys would be equal to 26 raised to the power of the total number of letters in the message. So if the message has 55 letters as in our example, there would be a total of 26<sup class="calibre21">55</sup>, or 666,091,878,431,395,624,153,823,182, 526,730,590,376,250,379,528,249,805,353,030,484,209,594,192,101,376 possible keys.</p>
<p class="indent">Even if the cryptanalyst had a computer powerful enough to try all the keys, it still wouldn’t be able to break the one-time pad cipher <em class="calibre7">because for any ciphertext, all possible plaintext messages are equally likely</em>.</p>
<p class="indent">For example, the ciphertext SHOMTDEC... could have easily resulted from a completely different plaintext the same number of letters in length, such as THE MYTH OF OSIRIS WAS OF IMPORTANCE IN ANCIENT EGYPTIAN RELIGION encrypted using the key ZAKAVKXOLFQDLZHWSQJBZMTWMMNAKWURWEXDCUYWKSGORGHNNEDVTCP, as shown in <a href="#calibre_link-33" class="calibre8">Figure 21-2</a>.</p>
<div class="image"><img src="images/00040.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-33" class="calibre8"></a><em class="calibre7">Figure 21-2: Encrypting a different example message using a different key but producing the same ciphertext as before</em></p>
<p class="indent">The reason we can hack any encryption at all is that we know there is usually only one key that decrypts the message to sensible English. But we’ve just seen in the preceding example that the <em class="calibre7">same</em> ciphertext could have been made using two very <em class="calibre7">different</em> plaintext messages. When we use the one-time pad, the cryptanalyst has no way of telling which is the original message. In fact, <em class="calibre7">any</em> readable English plaintext message that is exactly 55 letters long is <em class="calibre7">just as likely</em> to be the original plaintext. Just because a certain key can decrypt the ciphertext to readable English doesn’t mean it is the original encryption key.</p>
<p class="indent">Because any English plaintext could have been used to create a ciphertext with equal likelihood, it’s impossible to hack a message encrypted using a one-time pad.</p>
<h4 class="h2" id="calibre_link-774"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-311" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Making the Key Truly Random</em></strong></h4>
<p class="noindent">As you learned in <a href="#calibre_link-25" class="calibre8">Chapter 9</a>, the <span class="literal">random</span> module built into Python doesn’t generate truly random numbers. They are computed using an algorithm that creates numbers that only appear random, which is good enough in most cases. However, for the one-time pad to work, the pad must be generated from a truly random source; otherwise, it loses its mathematically perfect secrecy.</p>
<p class="indent">Python 3.6 and later have the <span class="literal">secrets</span> module, which uses the operating system’s source of truly random numbers (often gathered from random events, such as the time between the user’s keystrokes). The function <span class="literal">secrets.</span><span class="literal">randbelow</span><span class="literal">()</span> can return truly random numbers between <span class="literal">0</span> and up to but not including the argument passed to it, as in this example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import secrets</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">secrets.randbelow(10)</span><br class="calibre9" />2<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">secrets.randbelow(10)</span><br class="calibre9" />0<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">secrets.randbelow(10)</span><br class="calibre9" />6</p>
<p class="indent">The functions in <span class="literal">secrets</span> are slower than the functions in <span class="literal">random</span>, so the functions in <span class="literal">random</span> are preferred when true randomness is not needed. You can also use the <span class="literal">secrets.choice()</span> function, which returns a randomly chosen value from the string or list passed to it, as in this example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import secrets</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')</span><br class="calibre9" />'R'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">secrets.choice(['cat', 'dog', 'mouse'])</span><br class="calibre9" />'dog'</p>
<p class="indent">To create a truly random one-time pad that is 55 characters long, for example, use the following code:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import secrets</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">otp = ''</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">for i in range(55):</span><br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otp += secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')</span><br class="calibre9" /><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">otp</span><br class="calibre9" />'MVOVAAYDPELIRNRUZNNQHDNSOUWWNWPJUPIUAIMKFKNHQANIIYCHHDC'</p>
<p class="indent">There’s one more detail we must keep in mind when using the one-time pad. Let’s examine why we need to avoid using the same one-time pad key more than once.</p>
<h4 class="h2" id="calibre_link-775"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-327" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Avoiding the Two-Time Pad</em></strong></h4>
<p class="noindent">A <em class="calibre7">two-time pad cipher</em> refers to using the same one-time pad key to encrypt two different messages. This creates a weakness in an encryption.</p>
<p class="indent">As mentioned earlier, just because a key decrypts the one-time pad ciphertext to readable English doesn’t mean it is the correct key. However, when you use the same key for two different messages, you’re giving crucial information to the hacker. If you encrypt two messages using the same key and a hacker finds a key that decrypts the first ciphertext to readable English but decrypts the second message to random garbage text, the hacker will know that the key they found must not be the original key. In fact, it is highly likely that there is only one key that decrypts <em class="calibre7">both</em> messages to English, as you’ll see in the next section.</p>
<p class="indent">If the hacker has only one of the two messages, that message is still perfectly encrypted. But we must always assume that <em class="calibre7">all</em> of our encrypted messages are being intercepted by hackers and governments. Otherwise, we wouldn’t bother encrypting messages in the first place. Shannon’s maxim is important to keep in mind: the enemy knows the system! This includes all of your ciphertext.</p>
<h4 class="h2" id="calibre_link-776"><strong class="calibre3"><em class="calibre12">Why the Two-Time Pad Is the Vigenère Cipher</em></strong></h4>
<p class="noindent">You’ve already learned how to break Vigenère ciphers. If we can show that a two-time pad cipher is the same as a Vigenère cipher, we can prove that it’s breakable using the same techniques used to break the Vigenère cipher.</p>
<p class="indent">To explain why the two-time pad is hackable just like the Vigenère cipher, let’s review how the Vigenère cipher works when it encrypts a message that is longer than the key. When we run out of letters in the key to encrypt with, we go back to the first letter of the key and continue encrypting. For example, to encrypt a 20-letter message like BLUE IODINE INBOUND CAT with a 10-letter key such as YZNMPZXYXY, the first 10 letters (BLUE IODINE) are encrypted with YZNMPZXYXY, and then the next 10 letters (INBOUND CAT) are also encrypted with YZNMPZXYXY. <a href="#calibre_link-34" class="calibre8">Figure 21-3</a> shows this wraparound effect.</p>
<div class="image"><img src="images/00042.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-34" class="calibre8"></a><em class="calibre7">Figure 21-3: The Vigenère cipher’s wraparound effect</em></p>
<p class="indent">Using the one-time pad cipher, let’s say the 10-letter message BLUE IODINE is encrypted using the one-time pad key YZNMPZXYXY. Then the cryptographer makes the mistake of encrypting a second 10-letter message, INBOUND CAT, with the same one-time pad key, YZNMPZXYXY, as shown in <a href="#calibre_link-35" class="calibre8">Figure 21-4</a>.</p>
<div class="image"><img src="images/00043.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-35" class="calibre8"></a><em class="calibre7">Figure 21-4: Encrypting plaintext using a one-time pad produces the same ciphertext as the Vigenère cipher.</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-328"></span>When we compare the ciphertext of the Vigenère cipher shown in <a href="#calibre_link-34" class="calibre8">Figure 21-3</a> (ZKHQXNAGKCGMOAJMAAXR) to the ciphertexts of the one-time pad cipher shown in <a href="#calibre_link-35" class="calibre8">Figure 21-4</a> (ZKHQXNAGKC GMOAJMAAXR), we can see they are exactly the same. This means that because the two-time pad cipher has the same properties as the Vigenère cipher, we can use the same techniques to hack it!</p>
<h3 class="h1" id="calibre_link-777"><strong class="calibre3">Summary</strong></h3>
<p class="noindent">In short, a one-time pad is a way to make Vigenère cipher encryptions invulnerable to hacking by using a key that has the same length as the message, is truly random, and is used only once. When these three conditions are met, it’s impossible to break the one-time pad. However, because it’s so inconvenient to use, it’s not used for everyday encryption. Usually, the one-time pad is distributed in person and contains a list of keys. But be sure this list doesn’t fall into the wrong hands!</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-778"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">Why isn’t a one-time pad program presented in this chapter?</p></li>
<li value="2" class="calibre11"><p class="noindent">Which cipher is the two-time pad equivalent to?</p></li>
<li value="3" class="calibre11"><p class="noindent">Would using a key twice as long as the plaintext message make the onetime pad twice as secure?</p></li>
</ol>
</div>
</div>
