<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="invent4thedstyleb.css" rel="stylesheet" type="text/css" /><title>Chapter 14 - Caesar Cipher</title></head><body style="background-color: #fffeee;">

<!--<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>-->


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.webp" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter13.html">Prev: Chapter 13 - Sonar Treasure Hunt</a> | <a href="chapter15.html">Next: Chapter 15 - The Reversegam Game</a>



<div id="calibre_link-41" class="calibre">
<h2 class="h1" id="calibre_link-147"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-898" class="calibre1"></span><span class="big"><strong class="calibre2">14</strong></span><br class="calibre9" /><strong class="calibre2">CAESAR CIPHER</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">The program in this chapter isn’t really a game, but it is fun nevertheless. The program will convert normal English into a secret code. It can also convert secret codes back into regular English. Only someone who knows the key to the secret codes will be able to understand the messages.</p>
<p class="indent">Because this program manipulates text to convert it into secret messages, you’ll learn several new functions and methods for manipulating strings. You’ll also learn how programs can do math with text strings just as they can with numbers.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-241" class="calibre1"></span><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Cryptography and ciphers</p>
<p class="bull">• Ciphertext, plaintext, keys, and symbols</p>
<p class="bull">• Encrypting and decrypting</p>
<p class="bull">• The Caesar cipher</p>
<p class="bull">• The <span class="literal1">find()</span> string method</p>
<p class="bull">• Cryptanalysis</p>
<p class="bull">• The brute-force technique</p>
</div>
<h3 class="h2" id="calibre_link-632"><strong class="calibre2">Cryptography and Encryption</strong></h3>
<p class="noindent">The science of writing secret codes is called <em class="calibre6">cryptography</em>. For thousands of years, cryptography has made it possible to send secret messages that only the sender and recipient could read, even if someone captured the messenger and read the coded message. A secret code system is called a <em class="calibre6">cipher</em>. The cipher used by the program in this chapter is called the <em class="calibre6">Caesar cipher</em>.</p>
<p class="indent">In cryptography, we call the message that we want to keep secret the <em class="calibre6">plaintext</em>. Let’s say we have a plaintext message that looks like this:</p>
<p class="programs">There is a clue behind the bookshelf.</p>
<p class="indent">Converting the plaintext into the encoded message is called <em class="calibre6">encrypting</em> the plaintext. The plaintext is encrypted into the <em class="calibre6">ciphertext</em>. The ciphertext looks like random letters, so we can’t understand what the original plaintext was just by looking at the ciphertext. Here is the previous example encrypted into ciphertext:</p>
<p class="programs">aolyl pz h jsBl ilopuk Aol ivvrzolsm.</p>
<p class="indent">If you know the cipher used to encrypt the message, you can <em class="calibre6">decrypt</em> the ciphertext back to the plaintext. (Decryption is the opposite of encryption.)</p>
<p class="indent">Many ciphers use <em class="calibre6">keys</em>, which are secret values that let you decrypt ciphertext that was encrypted with a specific cipher. Think of the cipher as being like a door lock. You can only unlock it with a particular key.</p>
<p class="indent">If you’re interested in writing cryptography programs, you can read my book <em class="calibre6">Hacking Secret Ciphers with Python</em>. It’s free to download from <em class="calibre6"><a href="http://inventwithpython.com/hacking/" class="calibre4">http://inventwithpython.com/hacking/</a></em>.</p>
<h3 class="h2" id="calibre_link-633"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-226" class="calibre1"></span><strong class="calibre2">How the Caesar Cipher Works</strong></h3>
<p class="noindent">The Caesar cipher was one of the earliest ciphers ever invented. In this cipher, you encrypt a message by replacing each letter in it with a “shifted” letter. In cryptography, the encrypted letters are called <em class="calibre6">symbols</em> because they can be letters, numbers, or any other signs. If you shift the letter A by one space, you get the letter B. If you shift the letter A by two spaces, you get the letter C. <a href="#calibre_link-42" class="calibre4">Figure 14-1</a> shows some letters shifted by three spaces.</p>
<div class="image"><img src="images/00109.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-42" class="calibre4"></a><em class="calibre6">Figure 14-1: A Caesar cipher shifting letters by three spaces. Here, B becomes E.</em></p>
<p class="indent">To get each shifted letter, draw a row of boxes with each letter of the alphabet. Then draw a second row of boxes under it, but start your letters a certain number of spaces over. When you get to the end of the plaintext alphabet, wrap back around to A. <a href="#calibre_link-43" class="calibre4">Figure 14-2</a> shows an example with the letters shifted by three spaces.</p>
<div class="image"><img src="images/00000.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-43" class="calibre4"></a><em class="calibre6">Figure 14-2: The entire alphabet shifted by three spaces</em></p>
<p class="indent">The number of spaces you shift your letters (between 1 and 26) is the key in the Caesar cipher. Unless you know the key (the number used to encrypt the message), you won’t be able to decrypt the secret code. The example in <a href="#calibre_link-43" class="calibre4">Figure 14-2</a> shows the letter translations for the key 3.</p>
<div class="note">
<p class="notet"><span class="noteg"><strong class="calibre5">NOTE</strong></span></p>
<p class="notep"><em class="calibre6">While there are 26 possible keys, encrypting your message with 26 will result in a ciphertext that is exactly the same as the plaintext!</em></p>
</div>
<p class="indentb">If you encrypt the plaintext word HOWDY with a key of 3, then:</p>
<p class="bull">• The letter H becomes K.</p>
<p class="bull">• The letter O becomes R.</p>
<p class="bull">• The letter W becomes Z.</p>
<p class="bull">• The letter D becomes G.</p>
<p class="bull">• The letter Y becomes B.</p>
<p class="indentt">So, the ciphertext of HOWDY with the key 3 becomes KRZGB. To decrypt KRZGB with the key 3, we go from the bottom boxes back to the top.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-227"></span>If you would like to include lowercase letters as distinct from uppercase letters, then add another 26 boxes to the ones you already have and fill them with the 26 lowercase letters. Now with a key of 3, the letter Y becomes b, as shown in <a href="#calibre_link-44" class="calibre4">Figure 14-3</a>.</p>
<div class="image"><img src="images/00006.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-44" class="calibre4"></a><em class="calibre6">Figure 14-3: The entire alphabet, now including lowercase letters, shifted by three spaces</em></p>
<p class="indent">The cipher works the same way as it did with just uppercase letters. In fact, if you want to use letters from another language’s alphabet, you can write boxes with those letters to create your cipher.</p>
<h3 class="h2" id="calibre_link-634"><strong class="calibre2">Sample Run of Caesar Cipher</strong></h3>
<p class="noindent">Here is a sample run of the Caesar Cipher program encrypting a message:</p>
<p class="programs">Do you wish to encrypt or decrypt a message?<br class="calibre7" /><span class="codestrong">encrypt</span><br class="calibre7" />Enter your message:<br class="calibre7" /><span class="codestrong">The sky above the port was the color of television, tuned to a dead channel.</span><br class="calibre7" />Enter the key number (1-52)<br class="calibre7" /><span class="codestrong">13</span><br class="calibre7" />Your translated text is:<br class="calibre7" />gur FxL noBIr Gur CBEG JnF Gur pByBE Bs GryrIvFvBA, GHArq GB n qrnq punAAry.</p>
<p class="indent">Now run the program and decrypt the text that you just encrypted:</p>
<p class="programs">Do you wish to encrypt or decrypt a message?<br class="calibre7" /><span class="codestrong">decrypt</span><br class="calibre7" />Enter your message:<br class="calibre7" /><span class="codestrong">gur FxL noBIr Gur CBEG JnF Gur pByBE Bs GryrIvFvBA, GHArq GB n qrnq punAAry.</span><br class="calibre7" />Enter the key number (1-52)<br class="calibre7" /><span class="codestrong">13</span><br class="calibre7" />Your translated text is:<br class="calibre7" /><span class="codestrong">The sky above the port was the color of television, tuned to a dead channel.</span></p>
<p class="indent">If you do not decrypt with the correct key, the text will not decrypt properly:</p>
<p class="programs">Do you wish to encrypt or decrypt a message?<br class="calibre7" /><span class="codestrong">decrypt</span><br class="calibre7" />Enter your message:<br class="calibre7" /><span class="codestrong">gur FxL noBIr Gur CBEG JnF Gur pByBE Bs GryrIvFvBA, GHArq GB n qrnq punAAry.</span><br class="calibre7" />Enter the key number (1-52)<br class="calibre7" /><span class="codestrong">15</span><br class="calibre7" />Your translated text is:<br class="calibre7" />Rfc qiw YZmtc rfc nmpr uYq rfc amjmp md rcjctgqgml, rslcb rm Y bcYb afYllcj.</p>
<h3 class="h2" id="calibre_link-635"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-228" class="calibre1"></span><strong class="calibre2">Source Code for Caesar Cipher</strong></h3>
<p class="noindent">Enter this source code for the Caesar Cipher program and then save the file as <em class="calibre6">cipher.py</em>.</p>
<p class="indent">If you get errors after entering this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="sidenote"><em class="calibre6">cipher.py</em></p>
<p class="programs">&nbsp;1. # Caesar Cipher<br class="calibre7" />&nbsp;2. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'<br class="calibre7" />&nbsp;3. MAX_KEY_SIZE = len(SYMBOLS)<br class="calibre7" />&nbsp;4.<br class="calibre7" />&nbsp;5. def getMode():<br class="calibre7" />&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you wish to encrypt or decrypt a message?')<br class="calibre7" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = input().lower()<br class="calibre7" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in ['encrypt', 'e', 'decrypt', 'd']:<br class="calibre7" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode<br class="calibre7" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter either "encrypt" or "e" or "decrypt" or "d".')<br class="calibre7" />13.<br class="calibre7" />14. def getMessage():<br class="calibre7" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter your message:')<br class="calibre7" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return input()<br class="calibre7" />17.<br class="calibre7" />18. def getKey():<br class="calibre7" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = 0<br class="calibre7" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter the key number (1-%s)' % (MAX_KEY_SIZE))<br class="calibre7" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = int(input())<br class="calibre7" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key &gt;= 1 and key &lt;= MAX_KEY_SIZE):<br class="calibre7" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return key<br class="calibre7" />25.<br class="calibre7" />26. def getTranslatedMessage(mode, message, key):<br class="calibre7" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode[0] == 'd':<br class="calibre7" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = -key<br class="calibre7" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = ''<br class="calibre7" />30.<br class="calibre7" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre7" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre7" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbolIndex == -1: # Symbol not found in SYMBOLS.<br class="calibre7" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Just add this symbol without any change.<br class="calibre7" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol<br class="calibre7" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt or decrypt.<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex += key<br class="calibre7" />39.<br class="calibre7" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbolIndex &gt;= len(SYMBOLS):<br class="calibre7" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex -= len(SYMBOLS)<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif symbolIndex &lt; 0:<br class="calibre7" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex += len(SYMBOLS)<br class="calibre7" />44.<br class="calibre7" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += SYMBOLS[symbolIndex]<br class="calibre7" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translated<br class="calibre7" />47.<br class="calibre7" />48. mode = getMode()<br class="calibre7" />49. message = getMessage()<br class="calibre7" />50. key = getKey()<br class="calibre7" />51. print('Your translated text is:')<br class="calibre7" />52. print(getTranslatedMessage(mode, message, key))</p>
<h3 class="h2" id="calibre_link-636"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-224" class="calibre1"></span><strong class="calibre2">Setting the Maximum Key Length</strong></h3>
<p class="noindent">The encryption and decryption processes are the reverse of each other, but they share much of the same code. Let’s look at how each line works:</p>
<p class="programs">1. # Caesar Cipher<br class="calibre7" />2. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'<br class="calibre7" />3. MAX_KEY_SIZE = len(SYMBOLS)</p>
<p class="indent"><span class="literal1">MAX_KEY_SIZE</span> is a constant that stores the length of <span class="literal1">SYMBOLS</span> (<span class="literal1">52</span>). This constant reminds us that in this program, the key used in the cipher should always be between 1 and 52.</p>
<h3 class="h2" id="calibre_link-637"><strong class="calibre2">Deciding to Encrypt or Decrypt the Message</strong></h3>
<p class="noindent">The <span class="literal1">getMode()</span> function lets the user decide whether they want to use the program’s encryption or decryption mode:</p>
<p class="programs">&nbsp;5. def getMode():<br class="calibre7" />&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you wish to encrypt or decrypt a message?')<br class="calibre7" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = input().lower()<br class="calibre7" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in ['encrypt', 'e', 'decrypt', 'd']:<br class="calibre7" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode<br class="calibre7" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter either "encrypt" or "e" or "decrypt" or "d".')</p>
<p class="indent">Line 8 calls <span class="literal1">input()</span> to let the user enter the mode they want. The <span class="literal1">lower()</span> method is then called on this string to return a lowercase version of the string. The value returned from <span class="literal1">input().lower()</span> is stored in <span class="literal1">mode</span>. The <span class="literal1">if</span> statement’s condition checks whether the string stored in <span class="literal1">mode</span> exists in the <span class="literal1">['encrypt', 'e', 'decrypt', 'd']</span> list.</p>
<p class="indent">This function will return the string in <span class="literal1">mode</span> as long as <span class="literal1">mode</span> is equal to <span class="literal1">'encrypt'</span>, <span class="literal1">'e'</span>, <span class="literal1">'decrypt'</span>, or <span class="literal1">'d'</span>. Therefore, <span class="literal1">getMode()</span> will return the string <span class="literal1">mode</span>. If the user types something that is not <span class="literal1">'encrypt'</span>, <span class="literal1">'e'</span>, <span class="literal1">'decrypt'</span>, or <span class="literal1">'d'</span>, then the <span class="literal1">while</span> loop will ask them again.</p>
<h3 class="h2" id="calibre_link-638"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-225" class="calibre1"></span><strong class="calibre2">Getting the Message from the Player</strong></h3>
<p class="noindent">The <span class="literal1">getMessage()</span> function simply gets the message to encrypt or decrypt from the user and returns it:</p>
<p class="programs">14. def getMessage():<br class="calibre7" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter your message:')<br class="calibre7" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return input()</p>
<p class="indent">The call for <span class="literal1">input()</span> is combined with <span class="literal1">return</span> so that we use only one line instead of two.</p>
<h3 class="h2" id="calibre_link-639"><strong class="calibre2">Getting the Key from the Player</strong></h3>
<p class="noindent">The <span class="literal1">getKey()</span> function lets the player enter the key they will use to encrypt or decrypt the message:</p>
<p class="programs">18. def getKey():<br class="calibre7" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = 0<br class="calibre7" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter the key number (1-%s)' % (MAX_KEY_SIZE))<br class="calibre7" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = int(input())<br class="calibre7" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key &gt;= 1 and key &lt;= MAX_KEY_SIZE):<br class="calibre7" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return key</p>
<p class="indent">The <span class="literal1">while</span> loop ensures that the function keeps looping until the user enters a valid key. A valid key here is one between the integer values <span class="literal1">1</span> and <span class="literal1">52</span> (remember that <span class="literal1">MAX_KEY_SIZE</span> is <span class="literal1">52</span> because there are 52 characters in the <span class="literal1">SYMBOLS</span> variable). The <span class="literal1">getKey()</span> function then returns this key. Line 22 sets <span class="literal1">key</span> to the integer version of what the user entered, so <span class="literal1">getKey()</span> returns an integer.</p>
<h3 class="h2" id="calibre_link-640"><strong class="calibre2">Encrypting or Decrypting the Message</strong></h3>
<p class="noindent">The <span class="literal1">getTranslatedMessage()</span> function does the actual encrypting and decrypting:</p>
<p class="programs">26. def getTranslatedMessage(mode, message, key):<br class="calibre7" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode[0] == 'd':<br class="calibre7" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = -key<br class="calibre7" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = ''</p>
<p class="indentb">It has three parameters:</p>
<p class="hang"><span class="literal1"><span class="codestrong">mode</span></span> This sets the function to encryption mode or decryption mode.</p>
<p class="hang"><span class="literal1"><span class="codestrong">message</span></span> This is the plaintext (or ciphertext) to be encrypted (or decrypted).</p>
<p class="hang"><span class="literal1"><span class="codestrong">key</span></span> This is the key that is used in this cipher.</p>
<p class="indentt"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-303"></span>Line 27 checks whether the first letter in the <span class="literal1">mode</span> variable is the string <span class="literal1">'d'</span>. If so, then the program is in decryption mode. The only difference between decryption and encryption mode is that in decryption mode, the key is set to the negative version of itself. For example, if <span class="literal1">key</span> is the integer <span class="literal1">22</span>, then decryption mode sets it to <span class="literal1">-22</span>. The reason is explained in “<a href="#calibre_link-45" class="calibre4">Encrypting or Decrypting Each Letter</a>” on <a href="#calibre_link-46" class="calibre4">page 205</a>.</p>
<p class="indent">The <span class="literal1">translated</span> variable will contain the string of the result: either the ciphertext (if you are encrypting) or the plaintext (if you are decrypting). It starts as a blank string and has encrypted or decrypted characters concatenated to the end of it. Before we can start concatenating the characters to <span class="literal1">translated</span>, however, we need to encrypt or decrypt the text, which we’ll do in the rest of <span class="literal1">getTranslatedMessage()</span>.</p>
<h4 class="h3" id="calibre_link-641"><em class="calibre10"><strong class="calibre2">Finding Passed Strings with the find() String Method</strong></em></h4>
<p class="noindenta">In order to shift the letters around to do the encryption or decryption, we first need to convert them into numbers. The number for each letter in the <span class="literal1">SYMBOLS</span> string will be the index where it appears. Since the letter A is at <span class="literal1">SYMBOLS[0]</span>, the number <span class="literal1">0</span> will represent the capital A. If we wanted to encrypt this with the key 3, we would simply use 0 + 3 to get the index of the encrypted letter: <span class="literal1">SYMBOLS[3]</span> or <span class="literal1">'D'</span>.</p>
<p class="indent">We’ll use the <span class="literal1">find()</span> string method, which finds the first occurrence of a passed string in the string on which the method is called. Enter the following in the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">'Hello world!'.find('H')</span><br class="calibre7" />0<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">'Hello world!'.find('o')</span><br class="calibre7" />4<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">'Hello world!'.find('ell')</span><br class="calibre7" />1</p>
<p class="indent"><span class="literal1">'Hello world!'.find('H')</span> returns <span class="literal1">0</span> because the <span class="literal1">'H'</span> is found at the first index of the string <span class="literal1">'Hello world!'</span>. Remember, indexes start at <span class="literal1">0</span>, not <span class="literal1">1</span>. The code <span class="literal1">'Hello world!'.find('o')</span> returns <span class="literal1">4</span> because the lowercase <span class="literal1">'o'</span> is first found at the end of <span class="literal1">'Hello'</span>. The <span class="literal1">find()</span> method stops looking after the first occurrence, so the second <span class="literal1">'o'</span> in <span class="literal1">'world'</span> doesn’t matter. You can also find strings with more than one character. The string <span class="literal1">'ell'</span> is found starting at index <span class="literal1">1</span>.</p>
<p class="indent">If the passed string cannot be found, the <span class="literal1">find()</span> method returns <span class="literal1">-1</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">'Hello world!'.find('xyz')</span><br class="calibre7" />-1</p>
<p class="indent">Let’s go back to the Caesar Cipher program. Line 31 is a <span class="literal1">for</span> loop that iterates on each character in the <span class="literal1">message</span> string:</p>
<p class="programs">31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre7" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre7" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbolIndex == -1: # Symbol not found in SYMBOLS.<br class="calibre7" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Just add this symbol without any change.<br class="calibre7" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-46"></span>The <span class="literal1">find()</span> method is used on line 32 to get the index of the string in <span class="literal1">symbol</span>. If <span class="literal1">find()</span> returns <span class="literal1">-1</span>, the character in <span class="literal1">symbol</span> will just be added to <span class="literal1">translated</span> without any change. This means that any characters that aren’t part of the alphabet, such as commas and periods, won’t be changed.</p>
<h4 class="h3" id="calibre_link-45"><em class="calibre10"><strong class="calibre2">Encrypting or Decrypting Each Letter</strong></em></h4>
<p class="noindenta">Once you’ve found a letter’s index number, adding the key to the number will perform the shift and give you the index for the encrypted letter.</p>
<p class="indent">Line 38 does this addition to get the encrypted (or decrypted) letter.</p>
<p class="programs">37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt or decrypt.<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex += key</p>
<p class="indent">Remember that on line 28, we made the integer in <span class="literal1">key</span> negative for decryption. The code that adds the key will now subtract it, since adding a negative number is the same as subtraction.</p>
<p class="indent">However, if this addition (or subtraction, if <span class="literal1">key</span> is negative) causes <span class="literal1">symbolIndex</span> to go past the last index of <span class="literal1">SYMBOLS</span>, we’ll need to wrap around to the beginning of the list at <span class="literal1">0</span>. This is handled by the <span class="literal1">if</span> statement starting at line 40:</p>
<p class="programs">40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbolIndex &gt;= len(SYMBOLS):<br class="calibre7" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex -= len(SYMBOLS)<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif symbolIndex &lt; 0:<br class="calibre7" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex += len(SYMBOLS)<br class="calibre7" />44.<br class="calibre7" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += SYMBOLS[symbolIndex]</p>
<p class="indent">Line 40 checks whether <span class="literal1">symbolIndex</span> has gone past the last index by comparing it to the length of the <span class="literal1">SYMBOLS</span> string. If it has, line 41 subtracts the length of <span class="literal1">SYMBOLS</span> from <span class="literal1">symbolIndex</span>. If <span class="literal1">symbolIndex</span> is now negative, then the index needs to wrap around to the other side of the <span class="literal1">SYMBOLS</span> string. Line 42 checks whether the value of <span class="literal1">symbolIndex</span> is negative after adding the decryption key. If so, line 43 adds the length of <span class="literal1">SYMBOLS</span> to <span class="literal1">symbolIndex</span>.</p>
<p class="indent">The <span class="literal1">symbolIndex</span> variable now contains the index of the correctly encrypted or decrypted symbol. <span class="literal1">SYMBOLS[symbolIndex]</span> will point to the character for this index, and this character is added to the end of <span class="literal1">translated</span> on line 45.</p>
<p class="indent">The execution loops back to line 31 to repeat this for the next character in <span class="literal1">message</span>. Once the loop is done, the function returns the encrypted (or decrypted) string in <span class="literal1">translated</span> on line 46:</p>
<p class="programs">46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translated</p>
<p class="indent">The last line in the <span class="literal1">getTranslatedMessage()</span> function returns the <span class="literal1">translated</span> string.</p>
<h3 class="h2" id="calibre_link-642"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-220" class="calibre1"></span><strong class="calibre2">Starting the Program</strong></h3>
<p class="noindent">The start of the program calls each of the three functions defined previously to get the <span class="literal1">mode</span>, <span class="literal1">message</span>, and <span class="literal1">key</span> from the user:</p>
<p class="programs">48. mode = getMode()<br class="calibre7" />49. message = getMessage()<br class="calibre7" />50. key = getKey()<br class="calibre7" />51. print('Your translated text is:')<br class="calibre7" />52. print(getTranslatedMessage(mode, message, key))</p>
<p class="indent">These three values are passed to <span class="literal1">getTranslatedMessage()</span>, whose return value (the <span class="literal1">translated</span> string) is printed to the user.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre2">EXPANDING THE SYMBOLS</strong></p>
<p class="noindent">If you want to encrypt numbers, spaces, and punctuation marks, just add them to the <span class="literal1">SYMBOLS</span> string on line 2. For example, you could have your cipher program encrypt numbers, spaces, and punctuation marks by changing line 2 to the following:</p>
<p class="programs">2. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 123<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4567890!@#$%^&amp;*()'</p>
<p class="indent">Note that the <span class="literal1">SYMBOLS</span> string has a space character after the lowercase <span class="literal1">z</span>.</p>
<p class="indent">If you wanted, you could add even more characters to this list. And you don’t need to change the rest of your program, since all the lines of code that need the character list just use the <span class="literal1">SYMBOLS</span> constant.</p>
<p class="indent">Just make sure that each character appears only once in the string. Also, you’ll need to decrypt your message with the same <span class="literal1">SYMBOLS</span> string that it was encrypted with.</p>
</div>
<h3 class="h2" id="calibre_link-643"><strong class="calibre2">The Brute-Force Technique</strong></h3>
<p class="noindent">That’s the entire Caesar cipher. However, while this cipher may fool some people who don’t understand cryptography, it won’t keep a message secret from someone who knows <em class="calibre6">cryptanalysis</em>. While cryptography is the science of making codes, cryptanalysis is the science of breaking codes.</p>
<p class="indent">The whole point of cryptography is to make sure that if someone else gets their hands on the encrypted message, they cannot figure out the original text. Let’s pretend we are the code breaker and all we have is this encrypted text:</p>
<p class="programs">LwCjBA uiG vwB jm xtmiAivB, jCB kmzBiqvBG qA ijACzl.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-899"></span><em class="calibre6">Brute-forcing</em> is the technique of trying every possible key until you find the correct one. Because there are only 52 possible keys, it would be easy for a cryptanalyst to write a hacking program that decrypts with every possible key. Then they could look for the key that decrypts to plain English. Let’s add a brute-force feature to the program.</p>
<h3 class="h2" id="calibre_link-644"><strong class="calibre2">Adding the Brute-Force Mode</strong></h3>
<p class="noindent">First, change lines 7, 9, and 12&mdash;which are in the <span class="literal1">getMode()</span> function&mdash;to look like the following (the changes are in bold):</p>
<p class="programs">&nbsp;5. def getMode():<br class="calibre7" />&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you wish to encrypt or decrypt <span class="codestrong">or brute-force</span> a<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message?')<br class="calibre7" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = input().lower()<br class="calibre7" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode in ['encrypt', 'e', 'decrypt', 'd', 'brute', 'b']:<br class="calibre7" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return mode<br class="calibre7" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter either "encrypt" or "e" or "decrypt" or "d" <span class="codestrong">or</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">"brute" or "b"</span>.')</p>
<p class="indent">This code will let the user select brute force as a mode.</p>
<p class="indent">Next, make the following changes to the main part of the program:</p>
<p class="programs">48. mode = getMode()<br class="calibre7" />49. message = getMessage()<br class="calibre7" />50. <span class="codestrong">if mode[0] != 'b':</span><br class="calibre7" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">key = getKey()</span><br class="calibre7" />52. print('Your translated text is:')<br class="calibre7" />53. <span class="codestrong">if mode[0] != 'b':</span><br class="calibre7" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print(getTranslatedMessage(mode, message, key))</span><br class="calibre7" />55. <span class="codestrong">else:</span><br class="calibre7" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">for key in range(1, MAX_KEY_SIZE + 1):</span><br class="calibre7" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print(key, getTranslatedMessage('decrypt', message, key))</span></p>
<p class="indent">If the user is not in brute-force mode, they are asked for a key, the original <span class="literal1">getTranslatedMessage()</span> call is made, and the translated string is printed.</p>
<p class="indent">However, if the user is in brute-force mode, then the <span class="literal1">getTranslatedMessage()</span> loop iterates from <span class="literal1">1</span> all the way up to <span class="literal1">MAX_KEY_SIZE</span> (which is <span class="literal1">52</span>). Remember that the <span class="literal1">range()</span> function returns a list of integers up to, but not including, the second parameter, which is why we add <span class="literal1">+ 1</span>. The program will then print every possible translation of the message (including the key number used in the translation). Here is a sample run of this modified program:</p>
<p class="programs">Do you wish to encrypt or decrypt or brute-force a message?<br class="calibre7" /><span class="codestrong">brute</span><br class="calibre7" />Enter your message:<br class="calibre7" /><span class="codestrong">LwCjBA uiG vwB jm xtmiAivB, jCB kmzBiqvBG qA ijACzl.</span><br class="calibre7" />Your translated text is:<br class="calibre7" />1 KvBiAz thF uvA il wslhzhuA, iBA jlyAhpuAF pz hizByk.<br class="calibre7" />2 JuAhzy sgE tuz hk vrkgygtz, hAz ikxzgotzE oy ghyAxj.<br class="calibre7" />3 Itzgyx rfD sty gj uqjfxfsy, gzy hjwyfnsyD nx fgxzwi.<br class="calibre7" />4 Hsyfxw qeC rsx fi tpiewerx, fyx givxemrxC mw efwyvh.<br class="calibre7" />5 Grxewv pdB qrw eh sohdvdqw, exw fhuwdlqwB lv devxug.<br class="calibre7" />6 Fqwdvu ocA pqv dg rngcucpv, dwv egtvckpvA ku cduwtf.<br class="calibre7" />7 Epvcut nbz opu cf qmfbtbou, cvu dfsubjouz jt bctvse.<br class="calibre7" />8 Doubts may not be pleasant, but certainty is absurd.<br class="calibre7" />9 Cntasr lZx mns ad okdZrZms, ats bdqsZhmsx hr Zartqc.<br class="calibre7" />10 BmsZrq kYw lmr Zc njcYqYlr, Zsr acprYglrw gq YZqspb.<br class="calibre7" />11 AlrYqp jXv klq Yb mibXpXkq, Yrq ZboqXfkqv fp XYproa.<br class="calibre7" />12 zkqXpo iWu jkp Xa lhaWoWjp, Xqp YanpWejpu eo WXoqnZ.<br class="calibre7" />--<span class="codeitalic">snip</span>--</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-900"></span>After looking over each row, you can see that the eighth message isn’t nonsense but plain English! The cryptanalyst can deduce that the original key for this encrypted text must have been <span class="literal1">8</span>. This brute-force method would have been difficult to do back in the days of Julius Caesar and the Roman Empire, but today we have computers that can quickly go through millions or even billions of keys in a short time.</p>
<h3 class="h2" id="calibre_link-645"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">Computers are good at doing math. When we create a system to translate some piece of information into numbers (as we do with text and ordinals or with space and coordinate systems), computer programs can process these numbers quickly and efficiently. A large part of writing a program is figuring out how to represent the information you want to manipulate as values that Python can understand.</p>
<p class="indent">While our Caesar Cipher program can encrypt messages that will keep them secret from people who have to figure them out with pencil and paper, the program won’t keep them secret from people who know how to get computers to process information. (Our brute-force mode proves this.)</p>
<p class="indent">In <a href="#calibre_link-47" class="calibre4">Chapter 15</a>, we’ll create Reversegam (also known as Reversi or Othello). The AI that plays this game is much more advanced than the AI that played Tic-Tac-Toe in <a href="#calibre_link-12" class="calibre4">Chapter 10</a>. In fact, it’s so good that most of the time you won’t be able to beat it!</p>
</div>



<a href="chapter13.html">Prev: Chapter 13 - Sonar Treasure Hunt</a> | <a href="chapter15.html">Next: Chapter 15 - The Reversegam Game</a>
</body></html>