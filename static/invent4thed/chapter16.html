<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="invent4thedstyleb.css" rel="stylesheet" type="text/css" /><title>Chapter 16 - Reversegam AI Simulation</title></head><body style="background-color: #fffeee;">

<!--<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>-->


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.webp" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter15.html">Prev: Chapter 15 - The Reversegam Game</a> | <a href="chapter17.html">Next: Chapter 17 - Creating Graphics</a>



<div id="calibre_link-818" class="calibre">
<h2 class="h1" id="calibre_link-22"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-909" class="calibre1"></span><span class="big"><strong class="calibre2">16</strong></span><br class="calibre9" /><strong class="calibre2">REVERSEGAM AI SIMULATION</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">The Reversegam AI algorithm from <a href="#calibre_link-47" class="calibre4">Chapter 15</a> is simple, but it beats me almost every time I play it. Because the computer can process instructions quickly, it can easily check each possible position on the board and select the highest-scoring move. It would take me a long time to find the best move this way.</p>
<p class="indent">The Reversegam program had two functions, <span class="literal1">getPlayerMove()</span> and <span class="literal1">getComputerMove()</span>, which both returned the move selected as a two-item list in the format <span class="literal1">[x, y]</span>. Both functions also had the same parameters, the game board data structure and one type of tile, but the returned moves came from different sources&mdash;either the player or the Reversegam algorithm.</p>
<p class="indent">What happens when we replace the call to <span class="literal1">getPlayerMove()</span> with a call to <span class="literal1">getComputerMove()</span>? Then the player never has to enter a move; it is decided for them. The computer is playing against itself!</p>
<p class="indentb"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-173"></span>In this chapter, we’ll make three new programs in which the computer plays against itself, each based on the Reversegam program in <a href="#calibre_link-47" class="calibre4">Chapter 15</a>:</p>
<p class="bull">• Simulation 1: <em class="calibre6">AISim1.py</em> will make changes to <em class="calibre6">reversegam.py</em>.</p>
<p class="bull">• Simulation 2: <em class="calibre6">AISim2.py</em> will make changes to <em class="calibre6">AISim1.py</em>.</p>
<p class="bull">• Simulation 3: <em class="calibre6">AISim3.py</em> will make changes to <em class="calibre6">AISim2.py</em>.</p>
<p class="indentt">The small changes from one program to the next will show you how to turn a “player versus computer” game into a “computer versus computer” simulation. The final program, <em class="calibre6">AISim3.py</em>, shares most of its code with <em class="calibre6">reversegam.py</em> but serves quite a different purpose. The simulation doesn’t let us play Reversegam but teaches us more about the game itself.</p>
<p class="indent">You can either type in these changes yourself or download them from the book’s website at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython/" class="calibre4">https://www.nostarch.com/inventwithpython/</a></em>.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Simulations</p>
<p class="bull">• Percentages</p>
<p class="bull">• Integer division</p>
<p class="bull">• The <span class="literal1">round()</span> function</p>
<p class="bull">• Computer-versus-computer games</p>
</div>
<h3 class="h2" id="calibre_link-679"><strong class="calibre2">Making the Computer Play Against Itself</strong></h3>
<p class="noindent">Our <em class="calibre6">AISim1.py</em> program will have a few simple changes so that the computer plays against itself. Both the <span class="literal1">getPlayerMove()</span> and <span class="literal1">getComputerMove()</span> functions take a board data structure and the player’s tile, and then return the move to make. This is why <span class="literal1">getComputerMove()</span> can replace <span class="literal1">getPlayerMove()</span> and the program still works. In the <em class="calibre6">AISim1.py</em> program, the <span class="literal1">getComputerMove()</span> function is being called for both the <span class="literal1">X</span> and <span class="literal1">O</span> players.</p>
<p class="indent">We also make the program stop printing the game board for moves that are made. Since a human can’t read the game boards as fast as a computer makes moves, it isn’t useful to print every move, so we just print the final board at the end of the game.</p>
<p class="indent">These are just minimal changes to the program, so it will still say things like <span class="literal1">The player will go first.</span> even though the computer is playing as both the computer and the player.</p>
<h4 class="h3" id="calibre_link-680"><em class="calibre10"><strong class="calibre2">Sample Run of Simulation 1</strong></em></h4>
<p class="noindenta">Here’s what the user sees when they run the <em class="calibre6">AISim1.py</em> program. The text entered by the player is bold.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-174"></span>Welcome to Reversegam!<br class="calibre7" />The computer will go first.<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|XXXXXXXX|1<br class="calibre7" />2|OXXXXXXX|2<br class="calibre7" />3|XOXXOXXX|3<br class="calibre7" />4|XXOOXOOX|4<br class="calibre7" />5|XXOOXXXX|5<br class="calibre7" />6|XXOXOXXX|6<br class="calibre7" />7|XXXOXOXX|7<br class="calibre7" />8|XXXXXXXX|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />X scored 51 points. O scored 13 points.<br class="calibre7" />You beat the computer by 38 points! Congratulations!<br class="calibre7" />Do you want to play again? (yes or no)<br class="calibre7" /><span class="codestrong">no</span></p>
<h4 class="h3" id="calibre_link-681"><em class="calibre10"><strong class="calibre2">Source Code for Simulation 1</strong></em></h4>
<p class="noindenta">Save the old <em class="calibre6">reversegam.py</em> file as <em class="calibre6">AISim1.py</em> as follows:</p>
<ol class="calibre12">
<li value="1" class="calibre13"><p class="noindenta">Select <strong class="calibre5">File</strong> <img src="images/00042.jpeg" alt="image" class="calibre3" /> <strong class="calibre5">Save As</strong>.</p></li>
<li value="2" class="calibre13"><p class="noindenta">Save this file as <em class="calibre6">AISim1.py</em> so that you can make changes without affecting <em class="calibre6">reversegam.py</em>. (At this point, <em class="calibre6">reversegam.py</em> and <em class="calibre6">AISim1.py</em> still have the same code.)</p></li>
<li value="3" class="calibre13"><p class="noindenta">Make changes to <em class="calibre6">AISim1.py</em> and save that file to keep any changes. (<em class="calibre6">AISim1.py</em> will have the new changes, and <em class="calibre6">reversegam.py</em> will have the original, unchanged code.)</p></li>
</ol>
<p class="indent">This process will create a copy of our Reversegam source code as a new file that you can make changes to, while leaving the original Reversegam game the same (you may want to play it again to test it). For example, change line 216 in <em class="calibre6">AISim1.py</em> to the following (the change is in bold):</p>
<p class="programs">216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getComputerMove</span>(board, playerTile)</p>
<p class="indent">Now run the program. Notice that the game still asks whether you want to be <em class="calibre6">X</em> or <em class="calibre6">O</em>, but it won’t ask you to enter any moves. When you replace the <span class="literal1">getPlayerMove()</span> function with the <span class="literal1">getComputerMove()</span> function, you no longer call any code that takes this input from the player. The player still presses <small class="calibre11">ENTER</small> after the original computer’s moves (because of the <span class="literal1">input('Press Enter to see the computer\'s move.')</span> on line 232), but the game plays itself!</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-171"></span>Let’s make some other changes to <em class="calibre6">AISim1.py</em>. Change the following bolded lines. The changes start at line 209. Most of these changes are simply <em class="calibre6">commenting out</em> code, which means turning the code into a comment so it won’t run.</p>
<p class="indent">If you get errors after typing in this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<p class="sidenote"><em class="calibre6">AISim1.py</em></p>
<p class="programs">207.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'player': # Player's turn<br class="calibre7" />208.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerValidMoves != []:<br class="calibre7" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#if showHints:</span><br class="calibre7" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;validMovesBoard = getBoardWithValidMoves(board,</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">playerTile)</span><br class="calibre7" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(validMovesBoard)</span><br class="calibre7" />212.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#else:</span><br class="calibre7" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(board)</span><br class="calibre7" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#printScore(board, playerTile, computerTile)</span><br class="calibre7" />215.<br class="calibre7" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getComputerMove</span>(board, playerTile)<br class="calibre7" />217.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#if move == 'quit':</span><br class="calibre7" />218.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;print('Thanks for playing!')</span><br class="calibre7" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;sys.exit() # Terminate the program.</span><br class="calibre7" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#elif move == 'hints':</span><br class="calibre7" />221.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;showHints = not showHints</span><br class="calibre7" />222.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;continue</span><br class="calibre7" />223.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#else:</span><br class="calibre7" />224.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">makeMove(board, playerTile, move[0], move[1])</span><br class="calibre7" />225.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'computer'<br class="calibre7" />226.<br class="calibre7" />227.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'computer': # Computer's turn<br class="calibre7" />228.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if computerValidMoves != []:<br class="calibre7" />229.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#drawBoard(board)</span><br class="calibre7" />230.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#printScore(board, playerTile, computerTile)</span><br class="calibre7" />231.<br class="calibre7" />232.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#input('Press Enter to see the computer\'s move.')</span><br class="calibre7" />233.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getComputerMove(board, computerTile)<br class="calibre7" />234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(board, computerTile, move[0], move[1])<br class="calibre7" />235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'<br class="calibre7" />236.<br class="calibre7" />237.<br class="calibre7" />238.<br class="calibre7" />239. print('Welcome to Reversegam!')<br class="calibre7" />240.<br class="calibre7" />241. playerTile, computerTile = <span class="codestrong">['X', 'O'] #enterPlayerTile()</span></p>
<h4 class="h3" id="calibre_link-682"><em class="calibre10"><strong class="calibre2">Removing the Player Prompts and Adding a Computer Player</strong></em></h4>
<p class="noindenta">As you can seen, the <em class="calibre6">AISim1.py</em> program is mostly the same as the original Reversegam program, except we’ve replaced the call to <span class="literal1">getPlayerMove()</span> with a call to <span class="literal1">getComputerMove()</span>. We’ve also made some changes to the text that is printed to the screen so that the game easier to follow. When you run the program, the entire game is played in less than a second!</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-176"></span>Again, most of the changes are simply commenting out code. Since the computer is playing against itself, the program no longer needs to run code to get moves from the player or display the state of the board. All of this is skipped so that the board is displayed only at the very end of the game. We comment out code instead of deleting it because it’s easier to restore the code by uncommenting it if we need to reuse the code later.</p>
<p class="indent">We commented out lines 209 to 214 because we don’t need to draw a game board for the player since they won’t be playing the game. We also commented out lines 217 to 223 because we don’t need to check whether the player enters <span class="literal1">quit</span> or toggles the hints mode. But we need to de-indent line 224 by four spaces since it was in the <span class="literal1">else</span> block that we just commented out. Lines 229 to 232 also draw the game board for the player, so we comment out those lines, too.</p>
<p class="indent">The only new code is on lines 216 and 241. In line 216, we just substitute the call to <span class="literal1">getPlayerMove()</span> with <span class="literal1">getComputerMove()</span>, as discussed earlier. On line 241, instead of asking the player whether they want to be <em class="calibre6">X</em> or <em class="calibre6">O</em>, we simply always assign <span class="literal1">'X'</span> to <span class="literal1">playerTile</span> and <span class="literal1">'O'</span> to <span class="literal1">computerTile</span>. (Both of these players will be played by the computer, though, so you can rename <span class="literal1">playerTile</span> to <span class="literal1">computerTile2</span> or <span class="literal1">secondComputerTile</span> if you want.) Now that we have the computer playing against itself, we can keep modifying our program to make it do more interesting things.</p>
<h3 class="h2" id="calibre_link-683"><strong class="calibre2">Making the Computer Play Itself Several Times</strong></h3>
<p class="noindent">If we created a new algorithm, we could set it against the AI implemented in <span class="literal1">getComputerMove()</span> and see which one is better. Before we do so, however, we need a way to evaluate the players. We can’t evaluate which AI is better based on only one game, so we should have the AIs play against each other more than once. To do that, we’ll make some changes to the source code. Follow these steps to make <em class="calibre6">AISim2.py</em>:</p>
<ol class="calibre12">
<li value="1" class="calibre13"><p class="noindenta">Select <strong class="calibre5">File</strong> <img src="images/00042.jpeg" alt="image" class="calibre3" /> <strong class="calibre5">Save As</strong>.</p></li>
<li value="2" class="calibre13"><p class="noindenta">Save this file as <em class="calibre6">AISim2.py</em> so that you can make changes without affecting <em class="calibre6">AISim1.py</em>. (At this point, <em class="calibre6">AISim1.py</em> and <em class="calibre6">AISim2.py</em> still have the same code.)</p></li>
</ol>
<h4 class="h3" id="calibre_link-684"><em class="calibre10"><strong class="calibre2">Sample Run of Simulation 2</strong></em></h4>
<p class="noindenta">Here’s what the user sees when they run the <em class="calibre6">AISim2.py</em> program.</p>
<p class="programs">Welcome to Reversegam!<br class="calibre7" />#1: X scored 45 points. O scored 19 points.<br class="calibre7" />#2: X scored 38 points. O scored 26 points.<br class="calibre7" />#3: X scored 20 points. O scored 44 points.<br class="calibre7" />#4: X scored 24 points. O scored 40 points.<br class="calibre7" />#5: X scored 8 points. O scored 56 points.<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />#249: X scored 24 points. O scored 40 points.<br class="calibre7" />#250: X scored 43 points. O scored 21 points.<br class="calibre7" />X wins: 119 (47.6%)<br class="calibre7" />O wins: 127 (50.8%)<br class="calibre7" />Ties:&nbsp;&nbsp;&nbsp;4 (1.6%)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-177"></span>Because the algorithms include randomness, your run won’t have exactly the same numbers.</p>
<h4 class="h3" id="calibre_link-685"><em class="calibre10"><strong class="calibre2">Source Code for Simulation 2</strong></em></h4>
<p class="noindenta">Change the code in <em class="calibre6">AISim2.py</em> to match the following. Make sure that you change the code line by line in number order. If you get errors after typing in this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<p class="sidenote"><em class="calibre6">AISim2.py</em></p>
<p class="programs">235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'<br class="calibre7" />236.<br class="calibre7" />237. <span class="codestrong">NUM_GAMES = 250</span><br class="calibre7" />238. <span class="codestrong">xWins = oWins = ties = 0</span><br class="calibre7" />239. print('Welcome to Reversegam!')<br class="calibre7" />240.<br class="calibre7" />241. playerTile, computerTile = ['X', 'O'] #enterPlayerTile()<br class="calibre7" />242.<br class="calibre7" />243. <span class="codestrong">for i in range(NUM_GAMES): #while True:</span><br class="calibre7" />244.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finalBoard = playGame(playerTile, computerTile)<br class="calibre7" />245.<br class="calibre7" />246.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display the final score.<br class="calibre7" />247.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#drawBoard(finalBoard)</span><br class="calibre7" />248.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores = getScoreOfBoard(finalBoard)<br class="calibre7" />249.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('<span class="codestrong">#%s:</span> X scored %s points. O scored %s points.' % (<span class="codestrong">i + 1,</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores['X'], scores['O']))<br class="calibre7" />250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if scores[playerTile] &gt; scores[computerTile]:<br class="calibre7" />251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">xWins += 1 #print('You beat the computer by %s points!</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">Congratulations!' % (scores[playerTile] -</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">scores[computerTile]))</span><br class="calibre7" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif scores[playerTile] &lt; scores[computerTile]:<br class="calibre7" />253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">oWins += 1 #print('You lost. The computer beat you by %s points.'<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% (scores[computerTile] - scores[playerTile]))</span><br class="calibre7" />254.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />255.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">ties += 1 #print('The game was a tie!')</span><br class="calibre7" />256.<br class="calibre7" />257.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#print('Do you want to play again? (yes or no)')</span><br class="calibre7" />258.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#if not input().lower().startswith('y'):</span><br class="calibre7" />259.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">#&nbsp;&nbsp;&nbsp;&nbsp;break</span><br class="calibre7" />260.<br class="calibre7" />261. <span class="codestrong">print('X wins: %s (%s%%)' % (xWins, round(xWins / NUM_GAMES * 100, 1)))</span><br class="calibre7" />262. <span class="codestrong">print('O wins: %s (%s%%)' % (oWins, round(oWins / NUM_GAMES * 100, 1)))</span><br class="calibre7" />263. <span class="codestrong">print('Ties:&nbsp;&nbsp;&nbsp;%s (%s%%)' % (ties, round(ties / NUM_GAMES * 100, 1)))</span></p>
<p class="indent">If this is confusing, you can always download the <em class="calibre6">AISim2.py</em> source code from the book’s website at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython/" class="calibre4">https://www.nostarch.com/inventwithpython/</a></em>.</p>
<h4 class="h3" id="calibre_link-686"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-175" class="calibre1"></span><em class="calibre10"><strong class="calibre2">Keeping Track of Multiple Games</strong></em></h4>
<p class="noindenta">The main information we want from the simulation is how many wins for <em class="calibre6">X</em>, wins for <em class="calibre6">O</em>, and ties there are over a certain number of games. These can be tracked in four variables, which are created on lines 237 and 238.</p>
<p class="programs">237. NUM_GAMES = 250<br class="calibre7" />238. xWins = oWins = ties = 0</p>
<p class="indent">The constant <span class="literal1">NUM_GAMES</span> determines how many games the computer will play. You’ve added the variables <span class="literal1">xWins</span>, <span class="literal1">oWins</span>, and <span class="literal1">ties</span> to keep track of when <em class="calibre6">X</em> wins, when <em class="calibre6">O</em> wins, and when they tie. You can chain the assignment statement together to set <span class="literal1">ties</span> equal to <span class="literal1">0</span> and <span class="literal1">oWins</span> equal to <span class="literal1">ties</span>, then <span class="literal1">xWins</span> equal to <span class="literal1">oWins</span>. This sets all three variables to <span class="literal1">0</span>.</p>
<p class="indent"><span class="literal1">NUM_GAMES</span> is used in a <span class="literal1">for</span> loop that replaces the game loop on line 243:</p>
<p class="programs">243. for i in range(NUM_GAMES): #while True:</p>
<p class="indent">The <span class="literal1">for</span> loop runs the game the number of times in <span class="literal1">NUM_GAMES</span>. This replaces the <span class="literal1">while</span> loop that used to loop until the player said they didn’t want to play another game.</p>
<p class="indent">At line 250, an <span class="literal1">if</span> statement compares the score of the two players, and lines 251 to 255 in the <span class="literal1">if-elif-else</span> blocks increment the <span class="literal1">xWins</span>, <span class="literal1">oWins</span>, and <span class="literal1">ties</span> variables at the end of each game before looping back to start a new game:</p>
<p class="programs">250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if scores[playerTile] &gt; scores[computerTile]:<br class="calibre7" />251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xWins += 1 #print('You beat the computer by %s points!<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Congratulations!' % (scores[playerTile] -<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores[computerTile]))<br class="calibre7" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif scores[playerTile] &lt; scores[computerTile]:<br class="calibre7" />253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oWins += 1 #print('You lost. The computer beat you by %s points.'<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% (scores[computerTile] - scores[playerTile]))<br class="calibre7" />254.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />255.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ties += 1 #print('The game was a tie!')</p>
<p class="indent">We comment out the messages originally printed in the block so now only a one-line summary of the scores prints for each game. We’ll use the <span class="literal1">xWins</span>, <span class="literal1">oWins</span>, and <span class="literal1">ties</span> variables later in the code to analyze how the computer performed against itself.</p>
<h4 class="h3" id="calibre_link-687"><em class="calibre10"><strong class="calibre2">Commenting Out print() Function Calls</strong></em></h4>
<p class="noindenta">You also commented out lines 247 and 257 to 259. By doing that, you took out most of the <span class="literal1">print()</span> function calls from the program, as well as the calls to <span class="literal1">drawBoard()</span>. We don’t need to see each of the games since there are so many being played. The program still runs every game in its entirety using the AI we coded, but only the resulting scores are shown. After running all the games, the program shows how many games each side won, and lines 251 to 253 print some information about the game runs.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-158"></span>Printing things to the screen slows the computer down, but now that you’ve removed that code, the computer can run an entire game of Reversegam in about a second or two. Each time the program printed out one of those lines with the final score, it ran through an entire game (checking about 50 or 60 moves individually to choose the one that gets the most points). Now that the computer doesn’t have to do as much work, it can run much faster.</p>
<p class="indent">The numbers that the program prints at the end are <em class="calibre6">statistics</em>&mdash;numbers that are used to summarize how the games were played. In this case, we showed the resulting scores of each game played and the percentages of wins and ties for the tiles.</p>
<h4 class="h3" id="calibre_link-688"><em class="calibre10"><strong class="calibre2">Using Percentages to Grade the AIs</strong></em></h4>
<p class="noindenta"><em class="calibre6">Percentages</em> are a portion of a total amount. The percentages of a whole can range from 0 percent to 100 percent. If you had 100 percent of a pie, you would have the entire pie; if you had 0 percent of a pie, you wouldn’t have any pie at all; and if you had 50 percent of the pie, you would have half of it.</p>
<p class="indent">We can calculate percentages with division. To get a percentage, divide the part you have by the total and then multiply that by 100. For example, if <em class="calibre6">X</em> won 50 out of 100 games, you would calculate the expression <span class="literal1">50 / 100</span>, which evaluates to <span class="literal1">0.5</span>. Multiply this by <span class="literal1">100</span> to get the percentage (in this case, 50 percent).</p>
<p class="indent">If <em class="calibre6">X</em> won 100 out of 200 games, you would calculate the percentage with <span class="literal1">100 / 200</span>, which also evaluates to <span class="literal1">0.5</span>. When you multiply <span class="literal1">0.5</span> by <span class="literal1">100</span> to get the percentage, you get 50 percent. Winning 100 out of 200 games is the same percentage (that is, the same portion) as winning 50 out of 100 games.</p>
<p class="indent">In lines 261 to 263, we use percentages to print information about the outcomes of the games:</p>
<p class="programs">261. print('X wins: %s (%s%%)' % (xWins, round(xWins / NUM_GAMES * 100, 1)))<br class="calibre7" />262. print('O wins: %s (%s%%)' % (oWins, round(oWins / NUM_GAMES * 100, 1)))<br class="calibre7" />263. print('Ties:&nbsp;&nbsp;&nbsp;%s (%s%%)' % (ties, round(ties / NUM_GAMES * 100, 1)))</p>
<p class="indent">Each <span class="literal1">print()</span> statement has a label that tells the user whether the data being printed is for <em class="calibre6">X</em> wins, <em class="calibre6">O</em> wins, or ties. We use string interpolation to insert the number of games won or tied and then insert the calculated percentage the wins or ties make up of the total games, but you can see that we’re not simply dividing the <span class="literal1">xWins</span>, <span class="literal1">oWins</span>, or <span class="literal1">ties</span> by the total games and multiplying by <span class="literal1">100</span>. This is because we want to print only one decimal place for each percentage, which we can’t do with normal division.</p>
<h5 class="h4" id="calibre_link-910"><strong class="calibre2">Division Evaluates to a Floating-Point Number</strong></h5>
<p class="noindent">When you use the division operator (<span class="literal1">/</span>), the expression will always evaluate to a floating-point number. For example, the expression <span class="literal1">10 / 2</span> evaluates to the floating-point value <span class="literal1">5.0</span>, not to the integer value <span class="literal1">5</span>.</p>
<p class="indent">This is important to remember, because adding an integer to a floating-point value with the <span class="literal1">+</span> addition operator will also always evaluate to a <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-172"></span>floating-point value. For example, <span class="literal1">3 + 4.0</span> evaluates to the floating-point value <span class="literal1">7.0</span>, not to the integer <span class="literal1">7</span>.</p>
<p class="indent">Enter the following code into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">spam = 100 / 4</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre7" />25.0<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam = spam + 20</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre7" />45.0</p>
<p class="indent">In the example, the data type of the value stored in <span class="literal1">spam</span> is always a floating-point value. You can pass the floating-point value to the <span class="literal1">int()</span> function, which returns an integer form of the floating-point value. But this will always round the floating-point value down. For example, the expressions <span class="literal1">int(4.0)</span>, <span class="literal1">int(4.2)</span>, and <span class="literal1">int(4.9)</span> all evaluate to <span class="literal1">4</span>, not <span class="literal1">5</span>. But in <em class="calibre6">AISim2.py</em>, we need to round each percentage to the tenths place. Since we can’t just divide to do this, we need to use the <span class="literal1">round()</span> function.</p>
<h5 class="h4" id="calibre_link-911"><strong class="calibre2">The round() Function</strong></h5>
<p class="noindent">The <span class="literal1">round()</span> function rounds a floating-point number to the nearest integer number. Enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">round(10.0)</span><br class="calibre7" />10<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">round(10.2)</span><br class="calibre7" />10<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">round(8.7)</span><br class="calibre7" />9<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">round(3.4999)</span><br class="calibre7" />3<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">round(2.5422, 2)</span><br class="calibre7" />2.54</p>
<p class="indent">The <span class="literal1">round()</span> function also has an optional second parameter, where you can specify what place you want to round the number to. This will make the rounded number a floating-point number rather than an integer. For example, the expression <span class="literal1">round(2.5422, 2)</span> evaluates to <span class="literal1">2.54</span> and <span class="literal1">round(2.5422, 3)</span> evaluates to <span class="literal1">2.542</span>. In lines 261 to 263 of <em class="calibre6">AISim2.py</em>, we use this <span class="literal1">round()</span> with a parameter of <span class="literal1">1</span> to find the fraction of games won or tied by <em class="calibre6">X</em> and <em class="calibre6">O</em> up to one decimal place, which gives us accurate percentages.</p>
<h3 class="h2" id="calibre_link-689"><strong class="calibre2">Comparing Different AI Algorithms</strong></h3>
<p class="noindent">With just a few changes, we can make the computer play hundreds of games against itself. Right now, each player wins about half of the games, since both run exactly the same algorithm for moves. But if we add different algorithms, we can see whether a different AI will win more games.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-179"></span>Let’s add some new functions with new algorithms. But first, in <em class="calibre6">AISim2.py</em> select <strong class="calibre5">File</strong> <img src="images/00042.jpeg" alt="image" class="calibre3" /> <strong class="calibre5">Save As</strong> to save this new file as <em class="calibre6">AISim3.py</em>.</p>
<p class="indent">We’ll rename the <span class="literal1">getComputerMove()</span> function to <span class="literal1">getCornerBestMove()</span>, since this algorithm tries to move on corners first and then chooses the move that flips the most tiles. We’ll call this strategy the <em class="calibre6">corner-best algorithm</em>. We’ll also add several other functions that implement different strategies, including a <em class="calibre6">worst-move algorithm</em> that gets the worst-scoring move; a <em class="calibre6">random-move algorithm</em> that gets any valid move; and a <em class="calibre6">corner-side-best algorithm</em>, which works the same as the corner-best AI except that it looks for a side move after a corner move and before taking the highest-scoring move.</p>
<p class="indent">In <em class="calibre6">AISim3.py</em>, the call to <span class="literal1">getComputerMove()</span> on line 257 will be changed to <span class="literal1">getCornerBestMove()</span>, and line 274’s <span class="literal1">getComputerMove()</span> will become <span class="literal1">getWorstMove()</span>, which is the function we’ll write for the worst-move algorithm. This way, we’ll have the regular corner-best algorithm go against an algorithm that purposefully picks the move that will flip the <em class="calibre6">fewest</em> tiles.</p>
<h4 class="h3" id="calibre_link-690"><em class="calibre10"><strong class="calibre2">Source Code for Simulation 3</strong></em></h4>
<p class="noindenta">As you enter the source code of <em class="calibre6">AISim3.py</em> into your renamed copy of <em class="calibre6">AISim2.py</em>, make sure to write your code line by line in number order so that the line numbers match. If you get errors after typing in this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<p class="sidenote"><em class="calibre6">AISim3.py</em></p>
<p class="programs">162. def <span class="codestrong">getCornerBestMove</span>(board, computerTile):<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />184. <span class="codestrong">def getWorstMove(board, tile):</span><br class="calibre7" />185.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong"># Return the move that flips the least number of tiles.</span><br class="calibre7" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">possibleMoves = getValidMoves(board, tile)</span><br class="calibre7" />187.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">random.shuffle(possibleMoves) # Randomize the order of the moves.</span><br class="calibre7" />188.<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong"># Find the lowest-scoring move possible.</span><br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">worstScore = 64</span><br class="calibre7" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">for x, y in possibleMoves:</span><br class="calibre7" />192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">boardCopy = getBoardCopy(board)</span><br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">makeMove(boardCopy, tile, x, y)</span><br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">score = getScoreOfBoard(boardCopy)[tile]</span><br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">if score &lt; worstScore:</span><br class="calibre7" />196.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">worstMove = [x, y]</span><br class="calibre7" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">worstScore = score</span><br class="calibre7" />198.<br class="calibre7" />199.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return worstMove</span><br class="calibre7" />200.<br class="calibre7" />201. <span class="codestrong">def getRandomMove(board, tile):</span><br class="calibre7" />202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">possibleMoves = getValidMoves(board, tile)</span><br class="calibre7" />203.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return random.choice(possibleMoves)</span><br class="calibre7" />204.<br class="calibre7" />205. <span class="codestrong">def isOnSide(x, y):</span><br class="calibre7" />206.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return x == 0 or x == WIDTH - 1 or y == 0 or y == HEIGHT - 1</span><br class="calibre7" />207.<br class="calibre7" />208. <span class="codestrong">def getCornerSideBestMove(board, tile):</span><br class="calibre7" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong"># Return a corner move, a side move, or the best move.</span><br class="calibre7" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">possibleMoves = getValidMoves(board, tile)</span><br class="calibre7" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">random.shuffle(possibleMoves) # Randomize the order of the moves.</span><br class="calibre7" />212.<br class="calibre7" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong"># Always go for a corner if available.</span><br class="calibre7" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">for x, y in possibleMoves:</span><br class="calibre7" />215.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">if isOnCorner(x, y):</span><br class="calibre7" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return [x, y]</span><br class="calibre7" />217.<br class="calibre7" />218.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong"># If there is no corner move to make, return a side move.</span><br class="calibre7" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">for x, y in possibleMoves:</span><br class="calibre7" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">if isOnSide(x, y):</span><br class="calibre7" />221.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return [x, y]</span><br class="calibre7" />222.<br class="calibre7" />223.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">return getCornerBestMove(board, tile) # Do what the normal AI</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">would do.</span><br class="calibre7" />224.<br class="calibre7" />225. def printScore(board, playerTile, computerTile):<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />257.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getCornerBestMove</span>(board, playerTile)<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />274.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getWorstMove</span>(board, computerTile)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-178"></span>Running <em class="calibre6">AISim3.py</em> results in the same kind of output as <em class="calibre6">AISim2.py</em>, except different algorithms will be playing the games.</p>
<h4 class="h3" id="calibre_link-691"><em class="calibre10"><strong class="calibre2">How the AIs Work in Simulation 3</strong></em></h4>
<p class="noindenta">The functions <span class="literal1">getCornerBestMove()</span>, <span class="literal1">getWorstMove()</span>, <span class="literal1">getRandomMove()</span>, and <span class="literal1">getCornerSideBestMove()</span> are similar to one another but use slightly different strategies to play games. One of them uses the new <span class="literal1">isOnSide()</span> function. This is similar to our <span class="literal1">isOnCorner()</span> function, but it checks for the spaces along the side of the board before selecting the highest-scoring move.</p>
<h5 class="h4" id="calibre_link-912"><strong class="calibre2">The Corner-Best AI</strong></h5>
<p class="noindent">We already have the code for an AI that chooses to move on a corner and then chooses the best move possible, since that’s what <span class="literal1">getComputerMove()</span> does. We can just change the name of <span class="literal1">getComputerMove()</span> to something more descriptive, so change line 162 to rename our function to <span class="literal1">getCornerBestMove()</span>:</p>
<p class="programs">162. def getCornerBestMove(board, computerTile):</p>
<p class="indent">Since <span class="literal1">getComputerMove()</span> no longer exists, we need to update the code on line 257 to <span class="literal1">getCornerBestMove()</span>:</p>
<p class="programs">257.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getCornerBestMove(board, playerTile)</p>
<p class="indent">That’s all the work we need to do for this AI, so let’s move on.</p>
<h5 class="h4" id="calibre_link-913"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-346" class="calibre1"></span><strong class="calibre2">The Worst-Move AI</strong></h5>
<p class="noindent">The worst-move AI just finds the move with the fewest-scoring points and returns that. Its code is a lot like the code we used to find the highest-scoring move in our original <span class="literal1">getComputerMove()</span> algorithm:</p>
<p class="programs">184. def getWorstMove(board, tile):<br class="calibre7" />185.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the move that flips the least number of tiles.<br class="calibre7" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = getValidMoves(board, tile)<br class="calibre7" />187.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(possibleMoves) # Randomize the order of the moves.<br class="calibre7" />188.<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find the lowest-scoring move possible.<br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worstScore = 64<br class="calibre7" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, tile, x, y)<br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = getScoreOfBoard(boardCopy)[tile]<br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if score &lt; worstScore:<br class="calibre7" />196.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worstMove = [x, y]<br class="calibre7" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worstScore = score<br class="calibre7" />198.<br class="calibre7" />199.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return worstMove</p>
<p class="indent">The algorithm for <span class="literal1">getWorstMove()</span> starts out the same for lines 186 and 187, but then it makes a departure at line 190. We set up a variable to hold the <span class="literal1">worstScore</span> instead of <span class="literal1">bestScore</span> and set it to <span class="literal1">64</span>, because that is the total number of positions on the board and the most points that could be scored if the entire board were filled. Lines 191 to 194 are the same as the original algorithm, but then line 195 checks whether the <span class="literal1">score</span> is less than <span class="literal1">worstScore</span> instead of whether the <span class="literal1">score</span> is higher. If <span class="literal1">score</span> is less, then <span class="literal1">worstMove</span> is replaced with the move on the board the algorithm is currently testing, and <span class="literal1">worstScore</span> is updated, too. Then the function returns <span class="literal1">worstMove</span>.</p>
<p class="indent">Finally, line 274’s <span class="literal1">getComputerMove()</span> needs to be changed to <span class="literal1">getWorstMove()</span>:</p>
<p class="programs">274.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getWorstMove(board, computerTile)</p>
<p class="indent">When this is done and you run the program, <span class="literal1">getCornerBestMove()</span> and <span class="literal1">getWorstMove()</span> will play against each other.</p>
<h5 class="h4" id="calibre_link-914"><strong class="calibre2">The Random-Move AI</strong></h5>
<p class="noindent">The random-move AI just finds all the valid possible moves and then chooses a random one.</p>
<p class="programs">201. def getRandomMove(board, tile):<br class="calibre7" />202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = getValidMoves(board, tile)<br class="calibre7" />203.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return random.choice(possibleMoves)</p>
<p class="indent">It uses <span class="literal1">getValidMoves()</span>, just as all the other AIs do, and then uses <span class="literal1">choice()</span> to return one of the possible moves in the returned list.</p>
<h5 class="h4" id="calibre_link-915"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-260" class="calibre1"></span><strong class="calibre2">Checking for Side Moves</strong></h5>
<p class="noindent">Before we get into the algorithms, let’s look at one new helper function we’ve added. The <span class="literal1">isOnSide()</span> helper function is like the <span class="literal1">isOnCorner()</span> function, except that it checks whether a move is on the sides of a board:</p>
<p class="programs">205. def isOnSide(x, y):<br class="calibre7" />206.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x == 0 or x == WIDTH - 1 or y == 0 or y == HEIGHT - 1</p>
<p class="indent">It has one Boolean expression that checks whether the <span class="literal1">x</span> value or <span class="literal1">y</span> value of the coordinate arguments passed to it is equal to <span class="literal1">0</span> or <span class="literal1">7</span>. Any coordinate with a 0 or a 7 in it is at the edge of the board.</p>
<p class="indent">We’ll use this function next in the corner-side-best AI.</p>
<h5 class="h4" id="calibre_link-916"><strong class="calibre2">The Corner-Side-Best AI</strong></h5>
<p class="noindent">The corner-side-best AI works a lot like the corner-best AI, so we can reuse some of the code we’ve already entered. We define this AI in the function <span class="literal1">getCornerSideBestMove()</span>:</p>
<p class="programs">208. def getCornerSideBestMove(board, tile):<br class="calibre7" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a corner move, a side move, or the best move.<br class="calibre7" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = getValidMoves(board, tile)<br class="calibre7" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(possibleMoves) # Randomize the order of the moves.<br class="calibre7" />212.<br class="calibre7" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Always go for a corner if available.<br class="calibre7" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />215.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnCorner(x, y):<br class="calibre7" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]<br class="calibre7" />217.<br class="calibre7" />218.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If there is no corner move to make, return a side move.<br class="calibre7" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnSide(x, y):<br class="calibre7" />221.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]<br class="calibre7" />222.<br class="calibre7" />223.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getCornerBestMove(board, tile) # Do what the normal AI<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;would do.</p>
<p class="indent">Lines 210 and 211 are the same as in our corner-best AI, and lines 214 to 216 are identical to our algorithm to check for a corner move in our original <span class="literal1">getComputerMove()</span> AI. If there’s no corner move, then lines 219 to 221 check for a side move by using the <span class="literal1">isOnSide()</span> helper function. Once all corner and side moves have been checked for availability, if there’s still no move, then we reuse our <span class="literal1">getCornerBestMove()</span> function. Since there were no corner moves earlier and there still won’t be any when the code reaches the <span class="literal1">getCornerBestMove()</span> function, this function will just look for the highest-scoring move to make and return that.</p>
<p class="indent"><a href="#calibre_link-819" class="calibre4">Table 16-1</a> reviews the new algorithms we’ve made.</p>
<p class="tablecap"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-259"></span><a id="calibre_link-819" class="calibre4"></a><strong class="calibre5">Table 16-1:</strong> Functions Used for the Reversegam AIs</p>
<table class="topbot">
<thead class="calibre14">
<tr class="calibre15">
<td class="table_th"><p class="table"><strong class="calibre5">Function</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Description</strong></p></td>
</tr>
</thead>
<tbody class="calibre16">
<tr class="calibre15">
<td class="table_3a"><p class="table"><span class="literal1">getCornerBestMove()</span></p></td>
<td class="table_3a"><p class="table">Take a corner move if available. If there’s no corner, find the highest-scoring move.</p></td>
</tr>
<tr class="calibre15">
<td class="table_3a"><p class="table"><span class="literal1">getCornerSideBestMove()</span></p></td>
<td class="table_3a"><p class="table">Take a corner move if available. If there’s no corner, take a space on the side. If no sides are available, use the regular <span class="literal1">getCornerBestMove()</span> algorithm.</p></td>
</tr>
<tr class="calibre15">
<td class="table_3a"><p class="table"><span class="literal1">getRandomMove()</span></p></td>
<td class="table_3a"><p class="table">Randomly choose a valid move to make.</p></td>
</tr>
<tr class="calibre15">
<td class="table_3a"><p class="table"><span class="literal1">getWorstMove()</span></p></td>
<td class="table_3a"><p class="table">Take the position that will result in the fewest tiles being flipped.</p></td>
</tr>
</tbody>
</table>
<p class="indent">Now that we have our algorithms, we can pit them against each other.</p>
<h4 class="h3" id="calibre_link-692"><em class="calibre10"><strong class="calibre2">Comparing the AIs</strong></em></h4>
<p class="noindenta">We’ve written our program so that the corner-best AI plays against the worst-move AI. We can run the program to simulate how well the AIs do against each other and analyze the results with the printed statistics.</p>
<p class="indent">In addition to these two AIs, we’ve made some others that we don’t call on. These AIs exist in the code but aren’t being used, so if we want to see how they fare in a match, we’ll need to edit the code to call on them. Since we already have one comparison set up, let’s see how the worst-move AI does against the corner-best AI.</p>
<h5 class="h4" id="calibre_link-917"><strong class="calibre2">Worst-Move AI vs. Corner-Best AI</strong></h5>
<p class="noindent">Run the program to pit the <span class="literal1">getCornerBestMove()</span> function against the <span class="literal1">getWorstMove()</span> function. Unsurprisingly, the strategy of flipping the fewest tiles each turn will lose most games:</p>
<p class="programs">X wins: 206 (82.4%)<br class="calibre7" />O wins: 41 (16.4%)<br class="calibre7" />Ties:&nbsp;&nbsp;&nbsp;3 (1.2%)</p>
<p class="indent">What <em class="calibre6">is</em> surprising is that sometimes the worst-move strategy does work! Rather than winning 100 percent of the time, the algorithm in the <span class="literal1">getCornerBestMove()</span> function wins only about 80 percent of the time. About 1 in 5 times, it loses!</p>
<p class="indent">This is the power of running simulation programs: you can find novel insights that would take much longer for you to realize if you were just playing games on your own. The computer is much faster!</p>
<h5 class="h4" id="calibre_link-918"><strong class="calibre2">Random-Move AI vs. Corner-Best AI</strong></h5>
<p class="noindent">Let’s try a different strategy. Change the <span class="literal1">getWorstMove()</span> call on line 274 to <span class="literal1">getRandomMove()</span>:</p>
<p class="programs">274.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getRandomMove</span>(board, computerTile)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-258"></span>When you run the program now, it will look something like this:</p>
<p class="programs">Welcome to Reversegam!<br class="calibre7" />#1: X scored 32 points. O scored 32 points.<br class="calibre7" />#2: X scored 44 points. O scored 20 points.<br class="calibre7" />#3: X scored 31 points. O scored 33 points.<br class="calibre7" />#4: X scored 45 points. O scored 19 points.<br class="calibre7" />#5: X scored 49 points. O scored 15 points.<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />#249: X scored 20 points. O scored 44 points.<br class="calibre7" />#250: X scored 38 points. O scored 26 points.<br class="calibre7" />X wins: 195 (78.0%)<br class="calibre7" />O wins: 48 (19.2%)<br class="calibre7" />Ties:&nbsp;&nbsp;&nbsp;7 (2.8%)</p>
<p class="indent">The random-move algorithm <span class="literal1">getRandomMove()</span> did slightly better against the corner-best algorithm than did the worst-move algorithm. This makes sense because making intelligent choices is usually better than just choosing moves at random, but making random choices is slightly better than purposefully choosing the worst move.</p>
<h5 class="h4" id="calibre_link-919"><strong class="calibre2">Corner-Side-Best AI vs. Corner-Best AI</strong></h5>
<p class="noindent">Picking a corner space if it’s available is a good idea, because a tile on the corner can never be flipped. Putting a tile on the side spaces seems like it might also be a good idea, since there are fewer ways it can be surrounded and flipped. But does this benefit outweigh passing up moves that would flip more tiles? Let’s find out by pitting the corner-best algorithm against the corner-side-best algorithm.</p>
<p class="indent">Change the algorithm on line 274 to use <span class="literal1">getCornerSideBestMove()</span>:</p>
<p class="programs">274.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = <span class="codestrong">getCornerSideBestMove</span>(board, computerTile)</p>
<p class="indent">Then run the program again:</p>
<p class="programs">Welcome to Reversegam!<br class="calibre7" />#1: X scored 27 points. O scored 37 points.<br class="calibre7" />#2: X scored 39 points. O scored 25 points.<br class="calibre7" />#3: X scored 41 points. O scored 23 points.<br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" />#249: X scored 48 points. O scored 16 points.<br class="calibre7" />#250: X scored 38 points. O scored 26 points.<br class="calibre7" />X wins: 152 (60.8%)<br class="calibre7" />O wins: 89 (35.6%)<br class="calibre7" />Ties:&nbsp;&nbsp;&nbsp;9 (3.6%)</p>
<p class="indent">Wow! That’s unexpected. It seems that choosing the side spaces over a space that flips more tiles is a bad strategy. The benefit of the side space doesn’t outweigh the cost of flipping fewer of the opponent’s tiles. Can we be sure of these results? Let’s run the program again, but this time play <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-920"></span>1,000 games by changing line 278 to <span class="literal1">NUM_GAMES = 1000</span> in <em class="calibre6">AISim3.py</em>. The program may now take a few minutes for your computer to run&mdash;but it would take <em class="calibre6">weeks</em> for you to do this by hand!</p>
<p class="indent">You’ll see that the more accurate statistics from the 1,000-games run are about the same as the statistics from the 250-games run. It seems that choosing the move that flips the most tiles is a better idea than choosing a side to move on.</p>
<p class="indent">We’ve just used programming to find out which game strategy works the best. When you hear about scientists using computer models, this is what they’re doing. They use a simulation to re-create some real-world process, and then do tests in the simulation to find out more about the real world.</p>
<h3 class="h2" id="calibre_link-693"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">This chapter didn’t cover a new game, but it modeled various strategies for Reversegam. If we thought that taking side moves in Reversegam was a good idea, we would have to spend weeks, even months, carefully playing games of Reversegam by hand and writing down the results to test this idea. But if we know how to program a computer to play Reversegam, then we can have it try different strategies for us. If you think about it, the computer is executing millions of lines of our Python program in seconds! Your experiments with the simulations of Reversegam can help you learn more about playing it in real life.</p>
<p class="indent">In fact, this chapter would make a good science fair project. You could research which set of moves leads to the most wins against other sets of moves, and you could make a hypothesis about which is the best strategy. After running several simulations, you could determine which strategy works best. With programming, you can make a science fair project out of a simulation of any board game! And it’s all because you know how to instruct the computer to do it, step by step, line by line. You can speak the computer’s language and get it to do large amounts of data processing and number crunching for you.</p>
<p class="indent">That’s all for the text-based games in this book. Games that use only text can be fun, even though they’re simple. But most modern games use graphics, sound, and animation to make them more exciting. In the rest of the chapters in this book, you’ll learn how to create games with graphics by using a Python module called <span class="literal1">pygame</span>.</p>
</div>



<a href="chapter15.html">Prev: Chapter 15 - The Reversegam Game</a> | <a href="chapter17.html">Next: Chapter 17 - Creating Graphics</a>
</body></html>