<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="invent4thedstyleb.css" rel="stylesheet" type="text/css" /><title>Chapter 15 - The Reversegam Game</title></head><body style="background-color: #fffeee;">

<!--<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>-->


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.webp" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter14.html">Prev: Chapter 14 - Caesar Cipher</a> | <a href="chapter16.html">Next: Chapter 16 - Reversegam AI Simulation</a>



<div id="calibre_link-11" class="calibre">
<h2 class="h1" id="calibre_link-47"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-192" class="calibre1"></span><span class="big"><strong class="calibre2">15</strong></span><br class="calibre9" /><strong class="calibre2">THE REVERSEGAM GAME</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">In this chapter, we’ll make Reversegam, also known as Reversi or Othello. This two-player board game is played on a grid, so we’ll use a Cartesian coordinate system with x- and y-coordinates. Our version of the game will have a computer AI that is more advanced than our Tic-Tac-Toe AI from <a href="#calibre_link-12" class="calibre4">Chapter 10</a>. In fact, this AI is so good that it will probably beat you almost every time you play. (I lose whenever I play against it!)</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-357" class="calibre1"></span><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• How to play Reversegam</p>
<p class="bull">• The <span class="literal1">bool()</span> function</p>
<p class="bull">• Simulating moves on a Reversegam board</p>
<p class="bull">• Programming a Reversegam AI</p>
</div>
<h3 class="h2" id="calibre_link-647"><strong class="calibre2">How to Play Reversegam</strong></h3>
<p class="noindent">Reversegam has an 8×8 board and tiles that are black on one side and white on the other (our game will use <em class="calibre6">O</em>s and <em class="calibre6">X</em>s instead). The starting board looks like <a href="#calibre_link-13" class="calibre4">Figure 15-1</a>.</p>
<div class="image"><img src="images/00015.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-13" class="calibre4"></a><em class="calibre6">Figure 15-1: The starting Reversegam board has two white tiles and two black tiles.</em></p>
<p class="indent">Two players take turns placing tiles of their chosen color&mdash;black or white&mdash;on the board. When a player places a tile on the board, any of the opponent’s tiles that are between the new tile and the other tiles of the player’s color are flipped. For example, when the white player places a new white tile on space (5, 6), as in <a href="#calibre_link-14" class="calibre4">Figure 15-2</a>, the black tile at (5, 5) is between two white tiles, so it will flip to white, as in <a href="#calibre_link-15" class="calibre4">Figure 15-3</a>. The goal of the game is to end with more tiles of your color than your opponent’s color.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-901"></span><img src="images/00024.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-14" class="calibre4"></a><em class="calibre6">Figure 15-2: White places a new tile.</em></p>
<div class="image"><img src="images/00034.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-15" class="calibre4"></a><em class="calibre6">Figure 15-3: White’s move has caused one of black’s tiles to flip.</em></p>
<p class="indent">Black could make a similar move next, placing a black tile on (4, 6), which would flip the white tile at (4, 5). This results in a board that looks like <a href="#calibre_link-16" class="calibre4">Figure 15-4</a>.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-902"></span><img src="images/00044.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-16" class="calibre4"></a><em class="calibre6">Figure 15-4: Black has placed a new tile, flipping one of white’s tiles.</em></p>
<p class="indent">Tiles in all directions are flipped as long as they are between the player’s new tile and an existing tile of that color. In <a href="#calibre_link-17" class="calibre4">Figure 15-5</a>, white places a tile at (3, 6) and flips black tiles in two directions (marked by the lines). The result is shown in <a href="#calibre_link-18" class="calibre4">Figure 15-6</a>.</p>
<p class="indent">Each player can quickly flip many tiles on the board in one or two moves. Players must always make a move that flips at least one tile. The game ends when either a player can’t make a move or the board is completely full. The player with the most tiles of their color wins.</p>
<div class="image"><img src="images/00054.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-17" class="calibre4"></a><em class="calibre6">Figure 15-5: White’s second move at (3, 6) will flip two of black’s tiles.</em></p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-362"></span><img src="images/00063.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-18" class="calibre4"></a><em class="calibre6">Figure 15-6: The board after white’s second move.</em></p>
<p class="indent">The AI we make for this game will look for any corner moves on the board it can take. If there are no corner moves available, the computer will select the move that claims the most tiles.</p>
<h3 class="h2" id="calibre_link-648"><strong class="calibre2">Sample Run of Reversegam</strong></h3>
<p class="noindent">Here’s what the user sees when they run the Reversegam program. The text entered by the player is bold.</p>
<p class="programs">Welcome to Reversegam!<br class="calibre7" />Do you want to be X or O?<br class="calibre7" /><span class="codestrong">x</span><br class="calibre7" />The player will go first.<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|1<br class="calibre7" />2|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|2<br class="calibre7" />3|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|3<br class="calibre7" />4|&nbsp;&nbsp;&nbsp;XO&nbsp;&nbsp;&nbsp;|4<br class="calibre7" />5|&nbsp;&nbsp;&nbsp;OX&nbsp;&nbsp;&nbsp;|5<br class="calibre7" />6|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|6<br class="calibre7" />7|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|7<br class="calibre7" />8|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />You: 2 points. Computer: 2 points.<br class="calibre7" />Enter your move, "quit" to end the game, or "hints" to toggle hints.<br class="calibre7" /><span class="codestrong">53</span><br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|1<br class="calibre7" />2|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|2<br class="calibre7" />3|&nbsp;&nbsp;&nbsp;&nbsp;X&nbsp;&nbsp;&nbsp;|3<br class="calibre7" />4|&nbsp;&nbsp;&nbsp;XX&nbsp;&nbsp;&nbsp;|4<br class="calibre7" />5|&nbsp;&nbsp;&nbsp;OX&nbsp;&nbsp;&nbsp;|5<br class="calibre7" />6|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|6<br class="calibre7" />7|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|7<br class="calibre7" />8|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />You: 4 points. Computer: 1 points.<br class="calibre7" />Press Enter to see the computer's move.<br class="calibre7" /><br class="calibre7" />--<span class="codeitalic">snip</span>--<br class="calibre7" /><br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|OOOOOOOO|1<br class="calibre7" />2|OXXXOOOO|2<br class="calibre7" />3|OXOOOOOO|3<br class="calibre7" />4|OXXOXXOX|4<br class="calibre7" />5|OXXOOXOX|5<br class="calibre7" />6|OXXXXOOX|6<br class="calibre7" />7|OOXXOOOO|7<br class="calibre7" />8|OOXOOOOO|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678<br class="calibre7" />X scored 21 points. O scored 43 points.<br class="calibre7" />You lost. The computer beat you by 22 points.<br class="calibre7" />Do you want to play again? (yes or no)<br class="calibre7" /><span class="codestrong">no</span></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-356"></span>As you can see, the AI was pretty good at beating me, 43 to 21. To help the player out, we’ll program the game to provide hints. The player can type <span class="literal1">hints</span> as their move, which will toggle the hints mode on and off. When hints mode is on, all the possible moves the player can make will show up on the board as periods (<span class="literal1">.</span>), like this:</p>
<p class="programs">&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|1<br class="calibre7" />2|&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;|2<br class="calibre7" />3|&nbsp;&nbsp;XO.&nbsp;&nbsp;&nbsp;|3<br class="calibre7" />4|&nbsp;&nbsp;&nbsp;XOX&nbsp;&nbsp;|4<br class="calibre7" />5|&nbsp;&nbsp;&nbsp;OOO&nbsp;&nbsp;|5<br class="calibre7" />6|&nbsp;&nbsp;&nbsp;. .&nbsp;&nbsp;|6<br class="calibre7" />7|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|7<br class="calibre7" />8|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-363"></span>As you can see, the player can move on (4, 2), (5, 3), (4, 6), or (6, 6) based on the hints shown on this board.</p>
<h3 class="h2" id="calibre_link-649"><strong class="calibre2">Source Code for Reversegam</strong></h3>
<p class="noindent">Reversegam is a mammoth program compared to our previous games. It’s nearly 300 lines long! But don’t worry: many of these are comments or blank lines to space out the code and make it more readable.</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="indent">As with our other programs, we’ll first create several functions to carry out Reversegam-related tasks that the main section will call. Roughly the first 250 lines of code are for these helper functions, and the last 30 lines of code implement the Reversegam game itself.</p>
<p class="indent">If you get errors after entering this code, compare your code to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<p class="sidenote"><em class="calibre6">reversegam.py</em></p>
<p class="programs">&nbsp;&nbsp;1. # Reversegam: a clone of Othello/Reversi<br class="calibre7" />&nbsp;&nbsp;2. import random<br class="calibre7" />&nbsp;&nbsp;3. import sys<br class="calibre7" />&nbsp;&nbsp;4. WIDTH = 8 # Board is 8 spaces wide.<br class="calibre7" />&nbsp;&nbsp;5. HEIGHT = 8 # Board is 8 spaces tall.<br class="calibre7" />&nbsp;&nbsp;6. def drawBoard(board):<br class="calibre7" />&nbsp;&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Print the board passed to this function. Return None.<br class="calibre7" />&nbsp;&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('&nbsp;&nbsp;12345678')<br class="calibre7" />&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(' +--------+')<br class="calibre7" />&nbsp;10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />&nbsp;11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%s|' % (y+1), end='')<br class="calibre7" />&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[x][y], end='')<br class="calibre7" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('|%s' % (y+1))<br class="calibre7" />&nbsp;15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(' +--------+')<br class="calibre7" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('&nbsp;&nbsp;12345678')<br class="calibre7" />&nbsp;17.<br class="calibre7" />&nbsp;18. def getNewBoard():<br class="calibre7" />&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a brand-new, blank board data structure.<br class="calibre7" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board = []<br class="calibre7" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(WIDTH):<br class="calibre7" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board.append([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])<br class="calibre7" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board<br class="calibre7" />&nbsp;24.<br class="calibre7" />&nbsp;25. def isValidMove(board, tile, xstart, ystart):<br class="calibre7" />&nbsp;26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return False if the player's move on space xstart, ystart is<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid.<br class="calibre7" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If it is a valid move, return a list of spaces that would become<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the player's if they made a move here.<br class="calibre7" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[xstart][ystart] != ' ' or not isOnBoard(xstart, ystart):<br class="calibre7" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-903"></span> 30.<br class="calibre7" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tile == 'X':<br class="calibre7" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherTile = 'O'<br class="calibre7" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherTile = 'X'<br class="calibre7" />&nbsp;35.<br class="calibre7" />&nbsp;36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip = []<br class="calibre7" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0, -1], [-1, -1], [-1, 0], [-1, 1]]:<br class="calibre7" />&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = xstart, ystart<br class="calibre7" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += xdirection # First step in the x direction<br class="calibre7" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += ydirection # First step in the y direction<br class="calibre7" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while isOnBoard(x, y) and board[x][y] == otherTile:<br class="calibre7" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep moving in this x &amp; y direction.<br class="calibre7" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += xdirection<br class="calibre7" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += ydirection<br class="calibre7" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnBoard(x, y) and board[x][y] == tile:<br class="calibre7" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# There are pieces to flip over. Go in the reverse<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction until we reach the original space, noting all<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the tiles along the way.<br class="calibre7" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= xdirection<br class="calibre7" />&nbsp;49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y -= ydirection<br class="calibre7" />&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x == xstart and y == ystart:<br class="calibre7" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip.append([x, y])<br class="calibre7" />&nbsp;53.<br class="calibre7" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valid move.<br class="calibre7" />&nbsp;55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tilesToFlip<br class="calibre7" />&nbsp;57.<br class="calibre7" />&nbsp;58. def isOnBoard(x, y):<br class="calibre7" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the coordinates are located on the board.<br class="calibre7" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x &gt;= 0 and x &lt;= WIDTH - 1 and y &gt;= 0 and y &lt;= HEIGHT - 1<br class="calibre7" />&nbsp;61.<br class="calibre7" />&nbsp;62. def getBoardWithValidMoves(board, tile):<br class="calibre7" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a new board with periods marking the valid moves the player<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can make.<br class="calibre7" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />&nbsp;65.<br class="calibre7" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in getValidMoves(boardCopy, tile):<br class="calibre7" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy[x][y] = '.'<br class="calibre7" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy<br class="calibre7" />&nbsp;69.<br class="calibre7" />&nbsp;70. def getValidMoves(board, tile):<br class="calibre7" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a list of [x,y] lists of valid moves for the given player<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on the given board.<br class="calibre7" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMoves = []<br class="calibre7" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isValidMove(board, tile, x, y) != False:<br class="calibre7" />&nbsp;76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMoves.append([x, y])<br class="calibre7" />&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return validMoves<br class="calibre7" />&nbsp;78.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-904"></span> 79. def getScoreOfBoard(board):<br class="calibre7" />&nbsp;80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the score by counting the tiles. Return a dictionary<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with keys 'X' and 'O'.<br class="calibre7" />&nbsp;81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscore = 0<br class="calibre7" />&nbsp;82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oscore = 0<br class="calibre7" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[x][y] == 'X':<br class="calibre7" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscore += 1<br class="calibre7" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[x][y] == 'O':<br class="calibre7" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oscore += 1<br class="calibre7" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'X':xscore, 'O':oscore}<br class="calibre7" />&nbsp;90.<br class="calibre7" />&nbsp;91. def enterPlayerTile():<br class="calibre7" />&nbsp;92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter which tile they want to be.<br class="calibre7" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a list with the player's tile as the first item and the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computer's tile as the second.<br class="calibre7" />&nbsp;94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tile = ''<br class="calibre7" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while not (tile == 'X' or tile == 'O'):<br class="calibre7" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to be X or O?')<br class="calibre7" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tile = input().upper()<br class="calibre7" />&nbsp;98.<br class="calibre7" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The first element in the list is the player's tile, and the second<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is the computer's tile.<br class="calibre7" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tile == 'X':<br class="calibre7" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['X', 'O']<br class="calibre7" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['O', 'X']<br class="calibre7" />104.<br class="calibre7" />105. def whoGoesFirst():<br class="calibre7" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Randomly choose who goes first.<br class="calibre7" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if random.randint(0, 1) == 0:<br class="calibre7" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'computer'<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'player'<br class="calibre7" />111.<br class="calibre7" />112. def makeMove(board, tile, xstart, ystart):<br class="calibre7" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Place the tile on the board at xstart, ystart and flip any of the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opponent's pieces.<br class="calibre7" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return False if this is an invalid move; True if it is valid.<br class="calibre7" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip = isValidMove(board, tile, xstart, ystart)<br class="calibre7" />116.<br class="calibre7" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tilesToFlip == False:<br class="calibre7" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />119.<br class="calibre7" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[xstart][ystart] = tile<br class="calibre7" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in tilesToFlip:<br class="calibre7" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[x][y] = tile<br class="calibre7" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre7" />124.<br class="calibre7" />125. def getBoardCopy(board):<br class="calibre7" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make a duplicate of the board list and return it.<br class="calibre7" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getNewBoard()<br class="calibre7" />128.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-905"></span>129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy[x][y] = board[x][y]<br class="calibre7" />132.<br class="calibre7" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy<br class="calibre7" />134.<br class="calibre7" />135. def isOnCorner(x, y):<br class="calibre7" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the position is in one of the four corners.<br class="calibre7" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)<br class="calibre7" />138.<br class="calibre7" />139. def getPlayerMove(board, playerTile):<br class="calibre7" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter their move.<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the move as [x, y] (or return the strings 'hints' or<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'quit').<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIGITS1TO8 = '1 2 3 4 5 6 7 8'.split()<br class="calibre7" />143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter your move, "quit" to end the game, or "hints" to<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toggle hints.')<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = input().lower()<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move == 'quit' or move == 'hints':<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return move<br class="calibre7" />148.<br class="calibre7" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIGITS1TO8:<br class="calibre7" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = int(move[0]) - 1<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = int(move[1]) - 1<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isValidMove(board, playerTile, x, y) == False:<br class="calibre7" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre7" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />155.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('That is not a valid move. Enter the column (1-8) and<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then the row (1-8).')<br class="calibre7" />158.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('For example, 81 will move on the top-right corner.')<br class="calibre7" />159.<br class="calibre7" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]<br class="calibre7" />161.<br class="calibre7" />162. def getComputerMove(board, computerTile):<br class="calibre7" />163.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and the computer's tile, determine where to<br class="calibre7" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# move and return that move as an [x, y] list.<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = getValidMoves(board, computerTile)<br class="calibre7" />166.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(possibleMoves) # Randomize the order of the moves.<br class="calibre7" />167.<br class="calibre7" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Always go for a corner if available.<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnCorner(x, y):<br class="calibre7" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]<br class="calibre7" />172.<br class="calibre7" />173.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find the highest-scoring move possible.<br class="calibre7" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestScore = -1<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />177.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, computerTile, x, y)<br class="calibre7" />178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = getScoreOfBoard(boardCopy)[computerTile]<br class="calibre7" />179.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if score &gt; bestScore:<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-906"></span>180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestMove = [x, y]<br class="calibre7" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestScore = score<br class="calibre7" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bestMove<br class="calibre7" />183.<br class="calibre7" />184. def printScore(board, playerTile, computerTile):<br class="calibre7" />185.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores = getScoreOfBoard(board)<br class="calibre7" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You: %s points. Computer: %s points.' % (scores[playerTile],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores[computerTile]))<br class="calibre7" />187.<br class="calibre7" />188. def playGame(playerTile, computerTile):<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showHints = False<br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = whoGoesFirst()<br class="calibre7" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The ' + turn + ' will go first.')<br class="calibre7" />192.<br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Clear the board and place starting pieces.<br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board = getNewBoard()<br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[3][3] = 'X'<br class="calibre7" />196.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[3][4] = 'O'<br class="calibre7" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[4][3] = 'O'<br class="calibre7" />198.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[4][4] = 'X'<br class="calibre7" />199.<br class="calibre7" />200.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />201.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerValidMoves = getValidMoves(board, playerTile)<br class="calibre7" />202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computerValidMoves = getValidMoves(board, computerTile)<br class="calibre7" />203.<br class="calibre7" />204.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerValidMoves == [] and computerValidMoves == []:<br class="calibre7" />205.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board # No one can move, so end the game.<br class="calibre7" />206.<br class="calibre7" />207.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'player': # Player's turn<br class="calibre7" />208.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerValidMoves != []:<br class="calibre7" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if showHints:<br class="calibre7" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMovesBoard = getBoardWithValidMoves(board,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerTile)<br class="calibre7" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(validMovesBoard)<br class="calibre7" />212.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(board)<br class="calibre7" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printScore(board, playerTile, computerTile)<br class="calibre7" />215.<br class="calibre7" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getPlayerMove(board, playerTile)<br class="calibre7" />217.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move == 'quit':<br class="calibre7" />218.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Thanks for playing!')<br class="calibre7" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit() # Terminate the program.<br class="calibre7" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif move == 'hints':<br class="calibre7" />221.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showHints = not showHints<br class="calibre7" />222.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre7" />223.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />224.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(board, playerTile, move[0], move[1])<br class="calibre7" />225.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'computer'<br class="calibre7" />226.<br class="calibre7" />227.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'computer': # Computer's turn<br class="calibre7" />228.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if computerValidMoves != []:<br class="calibre7" />229.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(board)<br class="calibre7" />230.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printScore(board, playerTile, computerTile)<br class="calibre7" />231.<br class="calibre7" />232.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input('Press Enter to see the computer\'s move.')<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-351"></span>233.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getComputerMove(board, computerTile)<br class="calibre7" />234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(board, computerTile, move[0], move[1])<br class="calibre7" />235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'<br class="calibre7" />236.<br class="calibre7" />237.<br class="calibre7" />238.<br class="calibre7" />239. print('Welcome to Reversegam!')<br class="calibre7" />240.<br class="calibre7" />241. playerTile, computerTile = enterPlayerTile()<br class="calibre7" />242.<br class="calibre7" />243. while True:<br class="calibre7" />244.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finalBoard = playGame(playerTile, computerTile)<br class="calibre7" />245.<br class="calibre7" />246.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display the final score.<br class="calibre7" />247.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(finalBoard)<br class="calibre7" />248.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores = getScoreOfBoard(finalBoard)<br class="calibre7" />249.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('X scored %s points. O scored %s points.' % (scores['X'],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores['O']))<br class="calibre7" />250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if scores[playerTile] &gt; scores[computerTile]:<br class="calibre7" />251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You beat the computer by %s points! Congratulations!' %<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scores[playerTile] - scores[computerTile]))<br class="calibre7" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif scores[playerTile] &lt; scores[computerTile]:<br class="calibre7" />253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You lost. The computer beat you by %s points.' %<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scores[computerTile] - scores[playerTile]))<br class="calibre7" />254.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />255.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game was a tie!')<br class="calibre7" />256.<br class="calibre7" />257.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to play again? (yes or no)')<br class="calibre7" />258.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not input().lower().startswith('y'):<br class="calibre7" />259.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<h3 class="h2" id="calibre_link-650"><strong class="calibre2">Importing Modules and Setting Up Constants</strong></h3>
<p class="noindent">As with our other games, we begin this program by importing modules:</p>
<p class="programs">1. # Reversegam: a clone of Othello/Reversi<br class="calibre7" />2. import random<br class="calibre7" />3. import sys<br class="calibre7" />4. WIDTH = 8&nbsp;&nbsp;# Board is 8 spaces wide.<br class="calibre7" />5. HEIGHT = 8 # Board is 8 spaces tall.</p>
<p class="indent">Line 2 imports the <span class="literal1">random</span> module for its <span class="literal1">randint()</span> and <span class="literal1">choice()</span> functions. Line 3 imports the <span class="literal1">sys</span> module for its <span class="literal1">exit()</span> function.</p>
<p class="indent">Lines 4 and 5 set two constants, <span class="literal1">WIDTH</span> and <span class="literal1">HEIGHT</span>, which are used to set up the game board.</p>
<h3 class="h2" id="calibre_link-651"><strong class="calibre2">The Game Board Data Structure</strong></h3>
<p class="noindent">Let’s figure out the board’s data structure. This data structure is a list of lists, just like the one in <a href="#calibre_link-19" class="calibre4">Chapter 13</a>’s Sonar Treasure Hunt game. The list of lists is created so that <span class="literal1">board[x][y]</span> will represent the character on the <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-353"></span>space located at position <span class="literal1">x</span> on the x-axis (going left/right) and position <span class="literal1">y</span> on the y-axis (going up/down).</p>
<p class="indent">This character can either be a <span class="literal1">' '</span> (a space representing an empty position), a <span class="literal1">'.'</span> (a period representing a possible move in hints mode), or an <span class="literal1">'X'</span> or <span class="literal1">'O'</span> (letters representing tiles). Whenever you see a parameter named <span class="literal1">board</span>, it is meant to be this kind of list-of-lists data structure.</p>
<p class="indent">It is important to note that while the x- and y-coordinates for the game board will range from 1 to 8, the indexes of the list data structure will range from 0 to 7. Our code will need to make slight adjustments to account for this.</p>
<h4 class="h3" id="calibre_link-652"><em class="calibre10"><strong class="calibre2">Drawing the Board Data Structure on the Screen</strong></em></h4>
<p class="noindenta">The board data structure is just a Python list value, but we need a nicer way to present it on the screen. The <span class="literal1">drawBoard()</span> function takes a board data structure and displays it on the screen so the player knows where tiles are placed:</p>
<p class="programs">&nbsp;6. def drawBoard(board):<br class="calibre7" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Print the board passed to this function. Return None.<br class="calibre7" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('&nbsp;&nbsp;12345678')<br class="calibre7" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(' +--------+')<br class="calibre7" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%s|' % (y+1), end='')<br class="calibre7" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[x][y], end='')<br class="calibre7" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('|%s' % (y+1))<br class="calibre7" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(' +--------+')<br class="calibre7" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('&nbsp;&nbsp;12345678')</p>
<p class="indent">The <span class="literal1">drawBoard()</span> function prints the current game board based on the data structure in <span class="literal1">board</span>.</p>
<p class="indent">Line 8 is the first <span class="literal1">print()</span> function call executed for each board, and it prints the labels for the x-axis along the top of the board. Line 9 prints the top horizontal line of the board. The <span class="literal1">for</span> loop on line 10 will loop eight times, once for each row. Line 11 prints the label for the y-axis on the left side of the board, and it has an <span class="literal1">end=''</span> keyword argument to print nothing instead of a new line.</p>
<p class="indent">This is so that another loop on line 12 (which also loops eight times, once for each column in the row) prints each position along with an <span class="literal1">X</span>, <span class="literal1">O</span>, <span class="literal1">.</span>, or blank space depending on what’s stored in <span class="literal1">board[x][y]</span>. Line 13’s <span class="literal1">print()</span> function call inside this loop also has an <span class="literal1">end=''</span> keyword argument so that the newline character is not printed. That will produce a single line on the screen that looks like <span class="literal1">'1|XXXXXXXX|1'</span> (if each of the <span class="literal1">board[x][y]</span> values were an <span class="literal1">'X'</span>).</p>
<p class="indent">After the inner loop is done, the <span class="literal1">print()</span> function calls on lines 15 and 16 to print the bottom horizontal line and x-axis labels.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-352"></span>When the <span class="literal1">for</span> loop on line 13 prints the row eight times, it forms the entire board:</p>
<p class="programs">&nbsp;&nbsp;12345678<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />1|XXXXXXXX|1<br class="calibre7" />2|XXXXXXXX|2<br class="calibre7" />3|XXXXXXXX|3<br class="calibre7" />4|XXXXXXXX|4<br class="calibre7" />5|XXXXXXXX|5<br class="calibre7" />6|XXXXXXXX|6<br class="calibre7" />7|XXXXXXXX|7<br class="calibre7" />8|XXXXXXXX|8<br class="calibre7" />&nbsp;+--------+<br class="calibre7" />&nbsp;&nbsp;12345678</p>
<p class="indent">Of course, instead of <span class="literal1">X</span>, some of the spaces on the board will be the other player’s mark (<span class="literal1">O</span>), a period (<span class="literal1">.</span>) if hints mode is turned on, or a space for empty positions.</p>
<h4 class="h3" id="calibre_link-653"><em class="calibre10"><strong class="calibre2">Creating a Fresh Board Data Structure</strong></em></h4>
<p class="noindenta">The <span class="literal1">drawBoard()</span> function will display a board data structure on the screen, but we need a way to create these board data structures as well. The <span class="literal1">getNewBoard()</span> function returns a list of eight lists, with each list containing eight <span class="literal1">' '</span> strings that will represent a blank board with no moves:</p>
<p class="programs">18. def getNewBoard():<br class="calibre7" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a brand-new, blank board data structure.<br class="calibre7" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board = []<br class="calibre7" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(WIDTH):<br class="calibre7" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board.append([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])<br class="calibre7" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board</p>
<p class="indent">Line 20 creates the list that contains the inner lists. The <span class="literal1">for</span> loop adds eight inner lists inside this list. These inner lists have eight strings to represent eight empty spaces on the board. Together, this code creates a board with 64 empty spaces&mdash;a blank Reversegam board.</p>
<h3 class="h2" id="calibre_link-654"><strong class="calibre2">Checking Whether a Move Is Valid</strong></h3>
<p class="noindent">Given the board’s data structure, the player’s tile, and the x- and y-coordinates for the player’s move, the <span class="literal1">isValidMove()</span> function should return <span class="literal1">True</span> if the Reversegam game rules allow a move on those coordinates, and <span class="literal1">False</span> if they don’t. For a move to be valid, it must be on the board and also flip at least one of the opponent’s tiles.</p>
<p class="indent">This function uses several x- and y-coordinates on the board, so the <span class="literal1">xstart</span> and <span class="literal1">ystart</span> variables keep track of the x- and y-coordinates of the original move.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-349"></span>25. def isValidMove(board, tile, xstart, ystart):<br class="calibre7" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return False if the player's move on space xstart, ystart is<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invalid.<br class="calibre7" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If it is a valid move, return a list of spaces that would become<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the player's if they made a move here.<br class="calibre7" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[xstart][ystart] != ' ' or not isOnBoard(xstart, ystart):<br class="calibre7" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />30.<br class="calibre7" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tile == 'X':<br class="calibre7" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherTile = 'O'<br class="calibre7" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherTile = 'X'<br class="calibre7" />35.<br class="calibre7" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip = []</p>
<p class="indent">Line 28 checks whether the x- and y-coordinates are on the game board and whether the space is empty using the <span class="literal1">isOnBoard()</span> function (which we’ll define later in the program). This function makes sure both the x- and y-coordinates are between <span class="literal1">0</span> and the <span class="literal1">WIDTH</span> or <span class="literal1">HEIGHT</span> of the board minus <span class="literal1">1</span>.</p>
<p class="indent">The player’s tile (either the human player or the computer player) is in <span class="literal1">tile</span>, but this function will need to know the opponent’s tile. If the player’s tile is <span class="literal1">X</span>, then obviously the opponent’s tile is <span class="literal1">O</span>, and vice versa. We use the <span class="literal1">if-else</span> statement on lines 31 to 34 for this.</p>
<p class="indent">Finally, if the given x- and y-coordinate is a valid move, <span class="literal1">isValidMove()</span> returns a list of all the opponent’s tiles that would be flipped by this move. We create a new empty list, <span class="literal1">tilesToFlip</span>, that we’ll use to store all the tile coordinates.</p>
<h4 class="h3" id="calibre_link-655"><em class="calibre10"><strong class="calibre2">Checking Each of the Eight Directions</strong></em></h4>
<p class="noindenta">In order for a move to be valid, it needs to flip at least one of the opponent’s tiles by sandwiching the current player’s new tile with one of the player’s old tiles. That means that the new tile must be next to one of the opponent’s tiles.</p>
<p class="indent">The <span class="literal1">for</span> loop on line 37 iterates through a list of lists that represents the directions the program will check for an opponent’s tile:</p>
<p class="programs">37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0, -1], [-1, -1], [-1, 0], [-1, 1]]:</p>
<p class="indent">The game board is a Cartesian coordinate system with x- and y-directions. There are eight directions to check: up, down, left, right, and the four diagonal directions. Each of the eight two-item lists in the list on line 37 is used for checking one of these directions. The program checks a direction by adding the first value in the two-item list to the x-coordinate and the second value to the y-coordinate.</p>
<p class="indent">Because the x-coordinates increase as you go to the right, you can check the right direction by adding <span class="literal1">1</span> to the x-coordinate. So the <span class="literal1">[1, 0]</span> list adds <span class="literal1">1</span> to the x-coordinate and <span class="literal1">0</span> to the y-coordinate. Checking the left direction is the opposite: you would subtract <span class="literal1">1</span> (that is, add <span class="literal1">-1</span>) from the x-coordinate.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-350"></span>But to check diagonally, you need to add to or subtract from both coordinates. For example, adding <span class="literal1">1</span> to the x-coordinate and adding <span class="literal1">-1</span> to the y-coordinate would result in checking the up-right diagonal direction.</p>
<p class="indent"><a href="#calibre_link-20" class="calibre4">Figure 15-7</a> shows a diagram to make it easier to remember which two-item list represents which direction.</p>
<div class="image"><img src="images/00074.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-20" class="calibre4"></a><em class="calibre6">Figure 15-7: Each two-item list represents one of the eight directions.</em></p>
<p class="indent">The <span class="literal1">for</span> loop at line 37 iterates through each of the two-item lists so that each direction is checked. Inside the <span class="literal1">for</span> loop, the <span class="literal1">x</span> and <span class="literal1">y</span> variables are set to the same values as <span class="literal1">xstart</span> and <span class="literal1">ystart</span>, respectively, using multiple assignment at line 38. The <span class="literal1">xdirection</span> and <span class="literal1">ydirection</span> variables are set to the values in one of the two-item lists and change the <span class="literal1">x</span> and <span class="literal1">y</span> variables according to the direction being checked in that iteration of the <span class="literal1">for</span> loop:</p>
<p class="programs">37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0, -1], [-1, -1], [-1, 0], [-1, 1]]:<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = xstart, ystart<br class="calibre7" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += xdirection # First step in the x direction<br class="calibre7" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += ydirection # First step in the y direction</p>
<p class="indent">The <span class="literal1">xstart</span> and <span class="literal1">ystart</span> variables will stay the same so that the program can remember which space it originally started from.</p>
<p class="indent">Remember, for a move to be valid, it must be both on the board and next to one of the other player’s tiles. (Otherwise, there aren’t any of the opponent’s tiles to flip, and a move must flip over at least one tile to be valid.) Line 41 checks this condition, and if it isn’t <span class="literal1">True</span>, the execution goes back to the <span class="literal1">for</span> statement to check the next direction.</p>
<p class="programs">41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while isOnBoard(x, y) and board[x][y] == otherTile:<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep moving in this x &amp; y direction.<br class="calibre7" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += xdirection<br class="calibre7" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += ydirection</p>
<p class="indent">But if the first space checked does have the opponent’s tile, then the program should check for more of the opponent’s tiles in that direction until it reaches one of the player’s tiles or the end of the board. The next tile in the same direction is checked by using <span class="literal1">xdirection</span> and <span class="literal1">ydirection</span> again to make <span class="literal1">x</span> and <span class="literal1">y</span> the next coordinates to check. So the program changes <span class="literal1">x</span> and <span class="literal1">y</span> on lines 43 and 44.</p>
<h4 class="h3" id="calibre_link-656"><em class="calibre10"><strong class="calibre2">Finding Out Whether There Are Tiles to Flip Over</strong></em></h4>
<p class="noindenta">Next, we check whether there are adjacent tiles that can be flipped over.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-348"></span>45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnBoard(x, y) and board[x][y] == tile:<br class="calibre7" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# There are pieces to flip over. Go in the reverse<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;direction until we reach the original space, noting all<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the tiles along the way.<br class="calibre7" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x -= xdirection<br class="calibre7" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y -= ydirection<br class="calibre7" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if x == xstart and y == ystart:<br class="calibre7" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip.append([x, y])</p>
<p class="indent">The <span class="literal1">if</span> statement on line 45 checks whether a coordinate is occupied by the player’s own tile. This tile will mark the end of the sandwich made by the player’s tiles surrounding the opponent’s tiles. We also need to record the coordinates of all of the opponent’s tiles that should be flipped.</p>
<p class="indent">The <span class="literal1">while</span> loop moves <span class="literal1">x</span> and <span class="literal1">y</span> in reverse on lines 48 and 49. Until <span class="literal1">x</span> and <span class="literal1">y</span> are back to the original <span class="literal1">xstart</span> and <span class="literal1">ystart</span> position, <span class="literal1">xdirection</span> and <span class="literal1">ydirection</span> are subtracted from <span class="literal1">x</span> and <span class="literal1">y</span>, and each <span class="literal1">x</span> and <span class="literal1">y</span> position is appended to the <span class="literal1">tilesToFlip</span> list. When <span class="literal1">x</span> and <span class="literal1">y</span> have reached the <span class="literal1">xstart</span> and <span class="literal1">ystart</span> position, line 51 breaks the execution out of the loop. Since the original <span class="literal1">xstart</span> and <span class="literal1">ystart</span> position is an empty space (we ensured this was the case on lines 28 and 29), the condition for line 41’s <span class="literal1">while</span> loop will be <span class="literal1">False</span>. The program moves on to line 37, and the <span class="literal1">for</span> loop checks the next direction.</p>
<p class="indent">The <span class="literal1">for</span> loop does this in all eight directions. After that loop is done, the <span class="literal1">tilesToFlip</span> list will contain the x- and y-coordinates of all our opponent’s tiles that would be flipped if the player moved on <span class="literal1">xstart</span>, <span class="literal1">ystart</span>. Remember, the <span class="literal1">isValidMove()</span> function is only checking whether the original move was valid; it doesn’t actually permanently change the data structure of the game board.</p>
<p class="indent">If none of the eight directions ended up flipping at least one of the opponent’s tiles, then <span class="literal1">tilesToFlip</span> will be an empty list:</p>
<p class="programs">54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(tilesToFlip) == 0: # If no tiles were flipped, this is not a<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;valid move.<br class="calibre7" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return tilesToFlip</p>
<p class="indent">This is a sign that this move is not valid and <span class="literal1">isValidMove()</span> should return <span class="literal1">False</span>. Otherwise, <span class="literal1">isValidMove()</span> returns <span class="literal1">tilesToFlip</span>.</p>
<h3 class="h2" id="calibre_link-657"><strong class="calibre2">Checking for Valid Coordinates</strong></h3>
<p class="noindent">The <span class="literal1">isOnBoard()</span> function is called from <span class="literal1">isValidMove()</span>. It does a simple check to see whether given x- and y-coordinates are on the board. For example, an x-coordinate of <span class="literal1">4</span> and a y-coordinate of <span class="literal1">9999</span> would not be on the board since y-coordinates only go up to <span class="literal1">7</span>, which is equal to <span class="literal1">WIDTH - 1</span> or <span class="literal1">HEIGHT - 1</span>.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-338"></span>58. def isOnBoard(x, y):<br class="calibre7" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the coordinates are located on the board.<br class="calibre7" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x &gt;= 0 and x &lt;= WIDTH - 1 and y &gt;= 0 and y &lt;= HEIGHT - 1</p>
<p class="indent">Calling this function is shorthand for the Boolean expression on line 72 that checks whether both <span class="literal1">x</span> and <span class="literal1">y</span> are between <span class="literal1">0</span> and the <span class="literal1">WIDTH</span> or <span class="literal1">HEIGHT</span> subtracted by <span class="literal1">1</span>, which is <span class="literal1">7</span>.</p>
<h4 class="h3" id="calibre_link-658"><em class="calibre10"><strong class="calibre2">Getting a List with All Valid Moves</strong></em></h4>
<p class="noindenta">Now let’s create a hints mode that displays a board with all possible moves marked on it. The <span class="literal1">getBoardWithValidMoves()</span> function returns a game board data structure that has periods (<span class="literal1">.</span>) for all spaces that are valid moves:</p>
<p class="programs">62. def getBoardWithValidMoves(board, tile):<br class="calibre7" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a new board with periods marking the valid moves the player<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;can make.<br class="calibre7" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />65.<br class="calibre7" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in getValidMoves(boardCopy, tile):<br class="calibre7" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy[x][y] = '.'<br class="calibre7" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy</p>
<p class="indent">This function creates a duplicate game <span class="literal1">board</span> data structure called <span class="literal1">boardCopy</span> (returned by <span class="literal1">getBoardCopy()</span> on line 64) instead of modifying the one passed to it in the <span class="literal1">board</span> parameter. Line 66 calls <span class="literal1">getValidMoves()</span> to get a list of x- and y-coordinates with all the legal moves the player could make. The board copy is marked with periods in those spaces and returned.</p>
<p class="indent">The <span class="literal1">getValidMoves()</span> function returns a list of two-item lists. The two-item lists hold the x- and y-coordinates for all valid moves of the <span class="literal1">tile</span> given to it for the board data structure in the <span class="literal1">board</span> parameter:</p>
<p class="programs">70. def getValidMoves(board, tile):<br class="calibre7" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a list of [x,y] lists of valid moves for the given player<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on the given board.<br class="calibre7" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMoves = []<br class="calibre7" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isValidMove(board, tile, x, y) != False:<br class="calibre7" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMoves.append([x, y])<br class="calibre7" />77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return validMoves</p>
<p class="indent">This function uses nested loops (on lines 73 and 74) to check every xand y-coordinate (all 64 of them) by calling <span class="literal1">isValidMove()</span> on that space and checking whether it returns <span class="literal1">False</span> or a list of possible moves (in which case the move is valid). Each valid x- and y-coordinate is appended to the list in <span class="literal1">validMoves</span>.</p>
<h4 class="h3" id="calibre_link-659"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-213" class="calibre1"></span><em class="calibre10"><strong class="calibre2">Calling the bool() Function</strong></em></h4>
<p class="noindenta">You may have noticed that the program checks whether <span class="literal1">isValidMove()</span> on line 75 returns <span class="literal1">False</span> even though this function returns a list. To understand how this works, you need to learn a bit more about Booleans and the <span class="literal1">bool()</span> function.</p>
<p class="indent">The <span class="literal1">bool()</span> function is similar to the <span class="literal1">int()</span> and <span class="literal1">str()</span> functions. It returns the Boolean value form of the value passed to it.</p>
<p class="indent">Most data types have one value that is considered the <span class="literal1">False</span> value for that data type. Every other value is considered <span class="literal1">True</span>. For example, the integer <span class="literal1">0</span>, the floating-point number <span class="literal1">0.0</span>, an empty string, an empty list, and an empty dictionary are all considered to be <span class="literal1">False</span> when used as the condition for an <span class="literal1">if</span> or loop statement. All other values are <span class="literal1">True</span>. Enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">bool(0)</span><br class="calibre7" />False<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool(0.0)</span><br class="calibre7" />False<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool('')</span><br class="calibre7" />False<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool([])</span><br class="calibre7" />False<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool({})</span><br class="calibre7" />False<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool(1)</span><br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool('Hello')</span><br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool([1, 2, 3, 4, 5])</span><br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">bool({'spam':'cheese', 'fizz':'buzz'})</span><br class="calibre7" />True</p>
<p class="indent">Conditions are automatically interpreted as Boolean values. This is why the condition on line 75 works correctly. The call to the <span class="literal1">isValidMove()</span> function either returns the Boolean value <span class="literal1">False</span> or a nonempty list.</p>
<p class="indent">If you imagine that the entire condition is placed inside a call to <span class="literal1">bool()</span>, then line 75’s condition <span class="literal1">False</span> becomes <span class="literal1">bool(False)</span> (which, of course, evaluates to <span class="literal1">False</span>). And a condition of a nonempty list placed as the parameter to <span class="literal1">bool()</span> will return <span class="literal1">True</span>.</p>
<h3 class="h2" id="calibre_link-660"><strong class="calibre2">Getting the Score of the Game Board</strong></h3>
<p class="noindent">The <span class="literal1">getScoreOfBoard()</span> function uses nested <span class="literal1">for</span> loops to check all 64 positions on the board and see which player’s tile (if any) is on them:</p>
<p class="programs">79. def getScoreOfBoard(board):<br class="calibre7" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the score by counting the tiles. Return a dictionary<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with keys 'X' and 'O'.<br class="calibre7" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscore = 0<br class="calibre7" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oscore = 0<br class="calibre7" />83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[x][y] == 'X':<br class="calibre7" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xscore += 1<br class="calibre7" />87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if board[x][y] == 'O':<br class="calibre7" />88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oscore += 1<br class="calibre7" />89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'X':xscore, 'O':oscore}</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-355"></span>For each <span class="literal1">X</span> tile, the code increments <span class="literal1">xscore</span> on line 86. For each <span class="literal1">O</span> tile, the code increments <span class="literal1">oscore</span> on line 88. The function then returns <span class="literal1">xscore</span> and <span class="literal1">oscore</span> in a dictionary.</p>
<h3 class="h2" id="calibre_link-661"><strong class="calibre2">Getting the Player’s Tile Choice</strong></h3>
<p class="noindent">The <span class="literal1">enterPlayerTile()</span> function asks the player which tile they want to be, either <em class="calibre6">X</em> or <em class="calibre6">O</em>:</p>
<p class="programs">91. def enterPlayerTile():<br class="calibre7" />92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter which tile they want to be.<br class="calibre7" />93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a list with the player's tile as the first item and the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computer's tile as the second.<br class="calibre7" />94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tile = ''<br class="calibre7" />95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while not (tile == 'X' or tile == 'O'):<br class="calibre7" />96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to be X or O?')<br class="calibre7" />97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tile = input().upper()<br class="calibre7" />98.<br class="calibre7" />99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The first element in the list is the player's tile, and the second<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is the computer's tile.<br class="calibre7" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tile == 'X':<br class="calibre7" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['X', 'O']<br class="calibre7" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['O', 'X']</p>
<p class="indent">The <span class="literal1">for</span> loop will keep looping until the player enters <span class="literal1">X</span> or <span class="literal1">O</span> in either upper- or lowercase. The <span class="literal1">enterPlayerTile()</span> function then returns a two-item list, where the player’s tile choice is the first item and the computer’s tile is the second. Later, line 241 calls <span class="literal1">enterPlayerTile()</span> and uses multiple assignment to put these two returned items in two variables.</p>
<h3 class="h2" id="calibre_link-662"><strong class="calibre2">Determining Who Goes First</strong></h3>
<p class="noindent">The <span class="literal1">whoGoesFirst()</span> function randomly selects who goes first and returns either the string <span class="literal1">'computer'</span> or the string <span class="literal1">'player'</span>:</p>
<p class="programs">105. def whoGoesFirst():<br class="calibre7" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Randomly choose who goes first.<br class="calibre7" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if random.randint(0, 1) == 0:<br class="calibre7" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'computer'<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'player'</p>
<h3 class="h2" id="calibre_link-663"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-262" class="calibre1"></span><strong class="calibre2">Placing a Tile on the Board</strong></h3>
<p class="noindent">The <span class="literal1">makeMove()</span> function is called when a player wants to place a tile on the board and flip the other tiles according to the rules of Reversegam:</p>
<p class="programs">112. def makeMove(board, tile, xstart, ystart):<br class="calibre7" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Place the tile on the board at xstart, ystart and flip any of the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opponent's pieces.<br class="calibre7" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return False if this is an invalid move; True if it is valid.<br class="calibre7" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tilesToFlip = isValidMove(board, tile, xstart, ystart)</p>
<p class="indent">This function modifies in place the <span class="literal1">board</span> data structure that is passed. Changes made to the <span class="literal1">board</span> variable (because it is a list reference) will be made to the global scope.</p>
<p class="indent">Most of the work is done by <span class="literal1">isValidMove()</span> on line 115, which returns a list of x- and y-coordinates (in a two-item list) of tiles that need to be flipped. Remember, if the <span class="literal1">xstart</span> and <span class="literal1">ystart</span> arguments point to an invalid move, <span class="literal1">isValidMove()</span> will return the Boolean value <span class="literal1">False</span>, which is checked for by line 117:</p>
<p class="programs">117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if tilesToFlip == False:<br class="calibre7" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />119.<br class="calibre7" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[xstart][ystart] = tile<br class="calibre7" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in tilesToFlip:<br class="calibre7" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[x][y] = tile<br class="calibre7" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</p>
<p class="indent">If the return value of <span class="literal1">isValidMove()</span> (now stored in <span class="literal1">tilesToFlip</span>) is <span class="literal1">False</span>, then <span class="literal1">makeMove()</span> will also return <span class="literal1">False</span> on line 118.</p>
<p class="indent">Otherwise, <span class="literal1">isValidMove()</span> returns a list of spaces on the board to put down the tiles (the <span class="literal1">'X'</span> or <span class="literal1">'O'</span> string in <span class="literal1">tile</span>). Line 120 sets the space that the player has moved on. Line 121 <span class="literal1">for</span> loop sets all the tiles that are in <span class="literal1">tilesToFlip</span>.</p>
<h3 class="h2" id="calibre_link-664"><strong class="calibre2">Copying the Board Data Structure</strong></h3>
<p class="noindent">The <span class="literal1">getBoardCopy()</span> function is different from <span class="literal1">getNewBoard()</span>. The <span class="literal1">getNewBoard()</span> function creates a blank game board data structure that has only empty spaces and the four starting tiles. <span class="literal1">getBoardCopy()</span> creates a blank game board data structure but then copies all of the positions in the <span class="literal1">board</span> parameter with a nested loop. The AI uses the <span class="literal1">getBoardCopy()</span> function so it can make changes to the game board copy without changing the real game board. This technique was also used by the Tic-Tac-Toe program in <a href="#calibre_link-12" class="calibre4">Chapter 10</a>.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-354"></span>125. def getBoardCopy(board):<br class="calibre7" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make a duplicate of the board list and return it.<br class="calibre7" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getNewBoard()<br class="calibre7" />128.<br class="calibre7" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in range(WIDTH):<br class="calibre7" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for y in range(HEIGHT):<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy[x][y] = board[x][y]<br class="calibre7" />132.<br class="calibre7" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy</p>
<p class="indent">A call to <span class="literal1">getNewBoard()</span> sets up <span class="literal1">boardCopy</span> as a fresh game board data structure. Then the two nested <span class="literal1">for</span> loops copy each of the 64 tiles from <span class="literal1">board</span> to the duplicate board data structure in <span class="literal1">boardCopy</span>.</p>
<h3 class="h2" id="calibre_link-665"><strong class="calibre2">Determining Whether a Space Is on a Corner</strong></h3>
<p class="noindent">The <span class="literal1">isOnCorner()</span> function returns <span class="literal1">True</span> if the coordinates are on a corner space at coordinates (0, 0), (7, 0), (0, 7), or (7, 7):</p>
<p class="programs">135. def isOnCorner(x, y):<br class="calibre7" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the position is in one of the four corners.<br class="calibre7" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (x == 0 or x == WIDTH - 1) and (y == 0 or y == HEIGHT - 1)</p>
<p class="indent">Otherwise, <span class="literal1">isOnCorner()</span> returns <span class="literal1">False</span>. We’ll use this function later for the AI.</p>
<h3 class="h2" id="calibre_link-666"><strong class="calibre2">Getting the Player’s Move</strong></h3>
<p class="noindent">The <span class="literal1">getPlayerMove()</span> function is called to let the player enter the coordinates of their next move (and check whether the move is valid). The player can also enter <span class="literal1">hints</span> to turn hints mode on (if it is off) or off (if it is on). Finally, the player can enter <span class="literal1">quit</span> to quit the game.</p>
<p class="programs">139. def getPlayerMove(board, playerTile):<br class="calibre7" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter their move.<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the move as [x, y] (or return the strings 'hints' or<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'quit').<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIGITS1TO8 = '1 2 3 4 5 6 7 8'.split()</p>
<p class="indent">The <span class="literal1">DIGITS1TO8</span> constant variable is the list <span class="literal1">['1', '2', '3', '4', '5', '6', '7', '8']</span>. The <span class="literal1">getPlayerMove()</span> function uses <span class="literal1">DIGITS1TO8</span> a couple times, and this constant is more readable than the full list value. You can’t use the <span class="literal1">isdigit()</span> method because that would allow 0 and 9 to be entered, which are not valid coordinates on the 8×8 board.</p>
<p class="indent">The <span class="literal1">while</span> loop keeps looping until the player types in a valid move:</p>
<p class="programs">143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter your move, "quit" to end the game, or "hints" to<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toggle hints.')<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = input().lower()<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move == 'quit' or move == 'hints':<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return move</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-907"></span>Line 146 checks whether the player wants to quit or toggle hints mode, and line 147 returns the string <span class="literal1">'quit'</span> or <span class="literal1">'hints'</span>, respectively. The <span class="literal1">lower()</span> method is called on the string returned by <span class="literal1">input()</span> so the player can type <span class="literal1">HINTS</span> or <span class="literal1">Quit</span> and still have the command understood.</p>
<p class="indent">The code that called <span class="literal1">getPlayerMove()</span> will handle what to do if the player wants to quit or toggle hints mode. If the player enters coordinates to move on, the <span class="literal1">if</span> statement on line 149 checks whether the move is valid:</p>
<p class="programs">149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(move) == 2 and move[0] in DIGITS1TO8 and move[1] in<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIGITS1TO8:<br class="calibre7" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x = int(move[0]) - 1<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y = int(move[1]) - 1<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isValidMove(board, playerTile, x, y) == False:<br class="calibre7" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre7" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />155.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">The game expects that the player has entered the x- and y-coordinates of their move as two numbers without anything between them. Line 149 first checks that the size of the string the player typed in is <span class="literal1">2</span>. After that, it also checks that both <span class="literal1">move[0]</span> (the first character in the string) and <span class="literal1">move[1]</span> (the second character in the string) are strings that exist in <span class="literal1">DIGITS1TO8</span>.</p>
<p class="indent">Remember that the game board data structures have indexes from 0 to 7, not 1 to 8. The code prints 1 to 8 when the board is displayed in <span class="literal1">drawBoard()</span> because nonprogrammers are used to numbers beginning at 1 instead of 0. So to convert the strings in <span class="literal1">move[0]</span> and <span class="literal1">move[1]</span> to integers, lines 150 and 151 subtract 1 from <span class="literal1">x</span> and <span class="literal1">y</span>.</p>
<p class="indent">Even if the player has entered a correct move, the code needs to check that the move is allowed by the rules of Reversegam. This is done by the <span class="literal1">isValidMove()</span> function, which is passed the game board data structure, the player’s tile, and the x- and y-coordinates of the move.</p>
<p class="indent">If <span class="literal1">isValidMove()</span> returns <span class="literal1">False</span>, line 153 <span class="literal1">continue</span> statement executes. The execution then goes back to the beginning of the <span class="literal1">while</span> loop and asks the player for a valid move again. Otherwise, the player did enter a valid move, and the execution needs to break out of the <span class="literal1">while</span> loop.</p>
<p class="indent">If the <span class="literal1">if</span> statement’s condition on line 149 was <span class="literal1">False</span>, then the player didn’t enter a valid move. Lines 157 and 158 instruct them on how to correctly enter moves:</p>
<p class="programs">156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('That is not a valid move. Enter the column (1-8) and<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then the row (1-8).')<br class="calibre7" />158.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('For example, 81 will move on the top-right corner.')</p>
<p class="indent">Afterward, the execution moves back to the <span class="literal1">while</span> statement on line 143, because line 158 is not only the last line in the <span class="literal1">else</span> block but also the last <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-193"></span>line in the <span class="literal1">while</span> block. The <span class="literal1">while</span> loop will keep looping until the player enters a valid move. If the player enters x- and y-coordinates, line 160 will execute:</p>
<p class="programs">160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]</p>
<p class="indent">Finally, if line 160 executes, <span class="literal1">getPlayerMove()</span> returns a two-item list with the x- and y-coordinates of the player’s valid move.</p>
<h3 class="h2" id="calibre_link-667"><strong class="calibre2">Getting the Computer’s Move</strong></h3>
<p class="noindent">The <span class="literal1">getComputerMove()</span> function is where the AI algorithm is implemented:</p>
<p class="programs">162. def getComputerMove(board, computerTile):<br class="calibre7" />163.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and the computer's tile, determine where to<br class="calibre7" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# move and return that move as an [x, y] list.<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = getValidMoves(board, computerTile)</p>
<p class="indent">Normally you use the results from <span class="literal1">getValidMoves()</span> for hints mode, which will print <span class="literal1">.</span> on the board to show the player all the potential moves they can make. But if <span class="literal1">getValidMoves()</span> is called with the computer AI’s tile (in <span class="literal1">computerTile</span>), it will also find all the possible moves that the <em class="calibre6">computer</em> can make. The AI will select the best move from this list.</p>
<p class="indent">First, the <span class="literal1">random.shuffle()</span> function will randomize the order of moves in the <span class="literal1">possibleMoves</span> list:</p>
<p class="programs">166.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(possibleMoves) # Randomize the order of the moves.</p>
<p class="indent">We want to shuffle the <span class="literal1">possibleMoves</span> list because it will make the AI less predictable; otherwise, the player could just memorize the moves needed to win because the computer’s responses would always be the same. Let’s look at the algorithm.</p>
<h4 class="h3" id="calibre_link-668"><em class="calibre10"><strong class="calibre2">Strategizing with Corner Moves</strong></em></h4>
<p class="noindenta">Corner moves are a good idea in Reversegam because once a tile has been placed on a corner, it can never be flipped over. Line 169 loops through every move in <span class="literal1">possibleMoves</span>. If any of them is on the corner, the program will return that space as the computer’s move:</p>
<p class="programs">168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Always go for a corner if available.<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isOnCorner(x, y):<br class="calibre7" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [x, y]</p>
<p class="indent">Since <span class="literal1">possibleMoves</span> is a list of two-item lists, we’ll use multiple assignment in the <span class="literal1">for</span> loop to set <span class="literal1">x</span> and <span class="literal1">y</span>. If <span class="literal1">possibleMoves</span> contains multiple corner moves, the first one is always used. But since <span class="literal1">possibleMoves</span> was shuffled on line 166, which corner move is first in the list is random.</p>
<h4 class="h3" id="calibre_link-669"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-358" class="calibre1"></span><em class="calibre10"><strong class="calibre2">Getting a List of the Highest-Scoring Moves</strong></em></h4>
<p class="noindenta">If there are no corner moves, the program will loop through the entire list of possible moves and find out which results in the highest score. Then <span class="literal1">bestMove</span> is set to the highest-scoring move the code has found so far, and <span class="literal1">bestScore</span> is set to the best move’s score. This is repeated until the highest-scoring possible move is found.</p>
<p class="programs">173.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find the highest-scoring move possible.<br class="calibre7" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestScore = -1<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x, y in possibleMoves:<br class="calibre7" />176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />177.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, computerTile, x, y)<br class="calibre7" />178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = getScoreOfBoard(boardCopy)[computerTile]<br class="calibre7" />179.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if score &gt; bestScore:<br class="calibre7" />180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestMove = [x, y]<br class="calibre7" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bestScore = score<br class="calibre7" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return bestMove</p>
<p class="indent">Line 174 first sets <span class="literal1">bestScore</span> to <span class="literal1">-1</span> so that the first move the code checks will be set to the first <span class="literal1">bestMove</span>. This guarantees that <span class="literal1">bestMove</span> is set to one of the moves from <span class="literal1">possibleMoves</span> when it returns.</p>
<p class="indent">On line 175, the <span class="literal1">for</span> loop sets <span class="literal1">x</span> and <span class="literal1">y</span> to every move in <span class="literal1">possibleMoves</span>. Before simulating a move, line 176 makes a duplicate game board data structure by calling <span class="literal1">getBoardCopy()</span>. You’ll want a copy you can modify without changing the real game board data structure stored in the <span class="literal1">board</span> variable.</p>
<p class="indent">Then line 177 calls <span class="literal1">makeMove()</span>, passing the duplicate board (stored in <span class="literal1">boardCopy</span>) instead of the real board. This will simulate what would happen on the real board if that move were made. The <span class="literal1">makeMove()</span> function will handle placing the computer’s tile and flipping the player’s tiles on the duplicate board.</p>
<p class="indent">Line 178 calls <span class="literal1">getScoreOfBoard()</span> with the duplicate board, which returns a dictionary where the keys are <span class="literal1">'X'</span> and <span class="literal1">'O'</span>, and the values are the scores. When the code in the loop finds a move that scores higher than <span class="literal1">bestScore</span>, lines 179 to 181 will store that move and score as the new values in <span class="literal1">bestMove</span> and <span class="literal1">bestScore</span>. After <span class="literal1">possibleMoves</span> has been fully iterated through, <span class="literal1">bestMove</span> is returned.</p>
<p class="indent">For example, say that <span class="literal1">getScoreOfBoard()</span> returns the dictionary <span class="literal1">{'X':22, 'O':8}</span> and <span class="literal1">computerTile</span> is <span class="literal1">'X'</span>. Then <span class="literal1">getScoreOfBoard(boardCopy)[computerTile]</span> would evaluate to <span class="literal1">{'X':22, 'O':8}['X']</span>, which would then evaluate to <span class="literal1">22</span>. If <span class="literal1">22</span> is larger than <span class="literal1">bestScore</span>, <span class="literal1">bestScore</span> is set to <span class="literal1">22</span>, and <span class="literal1">bestMove</span> is set to the current <span class="literal1">x</span> and <span class="literal1">y</span> values.</p>
<p class="indent">By the time this <span class="literal1">for</span> loop is finished, you can be sure that <span class="literal1">bestScore</span> is the highest possible score a move can get, and that move is stored in <span class="literal1">bestMove</span>.</p>
<p class="indent">Even though the code always chooses the first in the list of these tied moves, the choice appears random because the list order was shuffled on line 166. This ensures that the AI won’t be predictable when there’s more than one best move.</p>
<h3 class="h2" id="calibre_link-670"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-360" class="calibre1"></span><strong class="calibre2">Printing the Scores to the Screen</strong></h3>
<p class="noindent">The <span class="literal1">showPoints()</span> function calls the <span class="literal1">getScoreOfBoard()</span> function and then prints the player’s and computer’s scores:</p>
<p class="programs">184. def printScore(board, playerTile, computerTile):<br class="calibre7" />185.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores = getScoreOfBoard(board)<br class="calibre7" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You: %s points. Computer: %s points.' % (scores[playerTile],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores[computerTile]))</p>
<p class="indent">Remember that <span class="literal1">getScoreOfBoard()</span> returns a dictionary with the keys <span class="literal1">'X'</span> and <span class="literal1">'O'</span> and values of the scores for the <em class="calibre6">X</em> and <em class="calibre6">O</em> players.</p>
<p class="indent">That’s all the functions for the Reversegam game. The code in the <span class="literal1">playGame()</span> function implements the actual game and calls these functions as needed.</p>
<h3 class="h2" id="calibre_link-671"><strong class="calibre2">Starting the Game</strong></h3>
<p class="noindent">The <span class="literal1">playGame()</span> function calls the previous functions we’ve written to play a single game:</p>
<p class="programs">188. def playGame(playerTile, computerTile):<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showHints = False<br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = whoGoesFirst()<br class="calibre7" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The ' + turn + ' will go first.')<br class="calibre7" />192.<br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Clear the board and place starting pieces.<br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board = getNewBoard()<br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[3][3] = 'X'<br class="calibre7" />196.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[3][4] = 'O'<br class="calibre7" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[4][3] = 'O'<br class="calibre7" />198.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[4][4] = 'X'</p>
<p class="indent">The <span class="literal1">playGame()</span> function is passed <span class="literal1">'X'</span> or <span class="literal1">'O'</span> strings for <span class="literal1">playerTile</span> and <span class="literal1">computerTile</span>. The player to go first is determined by line 190. The <span class="literal1">turn</span> variable contains the string <span class="literal1">'computer'</span> or <span class="literal1">'player'</span> to keep track of whose turn it is. Line 194 creates a blank board data structure, while lines 195 to 198 set up the initial four tiles on the board. The game is now ready to begin.</p>
<h4 class="h3" id="calibre_link-672"><em class="calibre10"><strong class="calibre2">Checking for a Stalemate</strong></em></h4>
<p class="noindenta">Before getting the player’s or computer’s turn, we need to check whether it is even possible for either of them to move. If not, then the game is at a stalemate and should end. (If only one side has no valid moves, the turn skips to the other player.)</p>
<p class="programs">200.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />201.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerValidMoves = getValidMoves(board, playerTile)<br class="calibre7" />202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computerValidMoves = getValidMoves(board, computerTile)<br class="calibre7" />203.<br class="calibre7" />204.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerValidMoves == [] and computerValidMoves == []:<br class="calibre7" />205.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board # No one can move, so end the game.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-908"></span>Line 200 is the main loop for running the player’s and computer’s turns. As long as this loop keeps looping, the game will continue. But before running these turns, lines 201 and 202 check whether either side can make a move by getting a list of valid moves. If both of these lists are empty, then neither player can make a move. Line 205 exits the <span class="literal1">playGame()</span> function by returning the final board, ending the game.</p>
<h4 class="h3" id="calibre_link-673"><em class="calibre10"><strong class="calibre2">Running the Player’s Turn</strong></em></h4>
<p class="noindenta">If the game is not in a stalemate, the program determines whether it is the player’s turn by checking whether <span class="literal1">turn</span> is set to the string <span class="literal1">'player'</span>:</p>
<p class="programs">207.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'player': # Player's turn<br class="calibre7" />208.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerValidMoves != []:<br class="calibre7" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if showHints:<br class="calibre7" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validMovesBoard = getBoardWithValidMoves(board,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerTile)<br class="calibre7" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(validMovesBoard)<br class="calibre7" />212.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(board)<br class="calibre7" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printScore(board, playerTile, computerTile)</p>
<p class="indent">Line 207 begins an <span class="literal1">elif</span> block containing the code that runs if it is the player’s turn. (The <span class="literal1">elif</span> block that starts on line 227 contains the code for the computer’s turn.)</p>
<p class="indent">All of this code will run only if the player has a valid move, which line 208 determines by checking that <span class="literal1">playerValidMoves</span> is not empty. We display the board on the screen by calling <span class="literal1">drawBoard()</span> on line 211 or 213.</p>
<p class="indent">If hints mode is on (that is, <span class="literal1">showHints</span> is <span class="literal1">True</span>), then the board data structure should display <span class="literal1">.</span> on every valid space the player could move, which is accomplished with the <span class="literal1">getBoardWithValidMoves()</span> function. It is passed a game board data structure and returns a copy that also contains periods (<span class="literal1">.</span>). Line 211 passes this board to the <span class="literal1">drawBoard()</span> function.</p>
<p class="indent">If hints mode is off, then line 213 passes <span class="literal1">board</span> to <span class="literal1">drawBoard()</span> instead.</p>
<p class="indent">After printing the game board to the player, you also want to print the current score by calling <span class="literal1">printScore()</span> on line 214.</p>
<p class="indent">Next, the player needs to enter their move. The <span class="literal1">getPlayerMove()</span> function handles this, and its return value is a two-item list of the x- and y-coordinates of the player’s move:</p>
<p class="programs">216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getPlayerMove(board, playerTile)</p>
<p class="indent">When we defined <span class="literal1">getPlayerMove()</span>, we already made sure that the player’s move is valid.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-361"></span>The <span class="literal1">getPlayerMove()</span> function may have returned the strings <span class="literal1">'quit'</span> or <span class="literal1">'hints'</span> instead of a move on the board. Lines 217 to 222 handle these cases:</p>
<p class="programs">217.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move == 'quit':<br class="calibre7" />218.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Thanks for playing!')<br class="calibre7" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit() # Terminate the program.<br class="calibre7" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif move == 'hints':<br class="calibre7" />221.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showHints = not showHints<br class="calibre7" />222.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre7" />223.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />224.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(board, playerTile, move[0], move[1])<br class="calibre7" />225.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'computer'</p>
<p class="indent">If the player entered <span class="literal1">quit</span> for their move, then <span class="literal1">getPlayerMove()</span> would return the string <span class="literal1">'quit'</span>. In that case, line 219 calls <span class="literal1">sys.exit()</span> to terminate the program.</p>
<p class="indent">If the player entered <span class="literal1">hints</span> for their move, then <span class="literal1">getPlayerMove()</span> would return the string <span class="literal1">'hints'</span>. In that case, you want to turn hints mode on (if it was off) or off (if it was on).</p>
<p class="indent">The <span class="literal1">showHints = not showHints</span> assignment statement on line 221 handles both of these cases, because <span class="literal1">not False</span> evaluates to <span class="literal1">True</span> and <span class="literal1">not True</span> evaluates to <span class="literal1">False</span>. Then the <span class="literal1">continue</span> statement moves the execution to the start of the loop (<span class="literal1">turn</span> has not changed, so it will still be the player’s turn).</p>
<p class="indent">Otherwise, if the player didn’t quit or toggle hints mode, line 224 calls <span class="literal1">makeMove()</span> to make the player’s move on the board.</p>
<p class="indent">Finally, line 225 sets <span class="literal1">turn</span> to <span class="literal1">'computer'</span>. The flow of execution skips the <span class="literal1">else</span> block and reaches the end of the <span class="literal1">while</span> block, so execution jumps back to the <span class="literal1">while</span> statement on line 200. This time, however, it will be the computer’s turn.</p>
<h4 class="h3" id="calibre_link-674"><em class="calibre10"><strong class="calibre2">Running the Computer’s Turn</strong></em></h4>
<p class="noindenta">If the <span class="literal1">turn</span> variable contains the string <span class="literal1">'computer'</span>, then the code for the computer’s turn will run. It is similar to the code for the player’s turn, with a few changes:</p>
<p class="programs">227.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif turn == 'computer': # Computer's turn<br class="calibre7" />228.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if computerValidMoves != []:<br class="calibre7" />229.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(board)<br class="calibre7" />230.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printScore(board, playerTile, computerTile)<br class="calibre7" />231.<br class="calibre7" />232.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;input('Press Enter to see the computer\'s move.')<br class="calibre7" />233.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getComputerMove(board, computerTile)<br class="calibre7" />234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(board, computerTile, move[0], move[1])</p>
<p class="indent">After printing the board with <span class="literal1">drawBoard()</span>, the program also prints the current score with a call to <span class="literal1">showPoints()</span> on line 230.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-310"></span>Line 232 calls <span class="literal1">input()</span> to pause the script so the player can look at the board. This is much like how <span class="literal1">input()</span> was used to pause the Jokes program in <a href="#calibre_link-21" class="calibre4">Chapter 4</a>. Instead of using a <span class="literal1">print()</span> call to print a string before a call to <span class="literal1">input()</span>, you can do the same thing by passing the string to print to <span class="literal1">input()</span>.</p>
<p class="indent">After the player has looked at the board and pressed <small class="calibre11">ENTER</small>, line 233 calls <span class="literal1">getComputerMove()</span> to get the x- and y-coordinates of the computer’s next move. These coordinates are stored in variables <span class="literal1">x</span> and <span class="literal1">y</span> using multiple assignment.</p>
<p class="indent">Finally, <span class="literal1">x</span> and <span class="literal1">y</span>, along with the game board data structure and the computer’s tile, are passed to the <span class="literal1">makeMove()</span> function. This places the computer’s tile on the game board in <span class="literal1">board</span> to reflect the computer’s move. Line 233 call to <span class="literal1">getComputerMove()</span> got the computer’s move (and stored it in variables <span class="literal1">x</span> and <span class="literal1">y</span>). The call to <span class="literal1">makeMove()</span> on line 234 makes the move on the board.</p>
<p class="indent">Next, line 235 sets the <span class="literal1">turn</span> variable to <span class="literal1">'player'</span>:</p>
<p class="programs">235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'</p>
<p class="indent">There is no more code in the <span class="literal1">while</span> block after line 235, so the execution loops back to the <span class="literal1">while</span> statement on line 200.</p>
<h3 class="h2" id="calibre_link-675"><strong class="calibre2">The Game Loop</strong></h3>
<p class="noindent">That’s all the functions we’ll make for Reversegam. Starting at line 239, the main part of the program runs a game by calling <span class="literal1">playGame()</span>, but it also displays the final score and asks the player whether they want to play again:</p>
<p class="programs">239. print('Welcome to Reversegam!')<br class="calibre7" />240.<br class="calibre7" />241. playerTile, computerTile = enterPlayerTile()</p>
<p class="indent">The program starts by welcoming the player on line 239 and asking them whether they want to be <em class="calibre6">X</em> or <em class="calibre6">O</em>. Line 241 uses the multiple assignment trick to set <span class="literal1">playerTile</span> and <span class="literal1">computerTile</span> to the two values returned by <span class="literal1">enterPlayerTile()</span>.</p>
<p class="indent">The <span class="literal1">while</span> loop on line 243 runs each game:</p>
<p class="programs">243. while True:<br class="calibre7" />244.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finalBoard = playGame(playerTile, computerTile)<br class="calibre7" />245.<br class="calibre7" />246.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display the final score.<br class="calibre7" />247.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(finalBoard)<br class="calibre7" />248.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores = getScoreOfBoard(finalBoard)<br class="calibre7" />249.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('X scored %s points. O scored %s points.' % (scores['X'],<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scores['O']))<br class="calibre7" />250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if scores[playerTile] &gt; scores[computerTile]:<br class="calibre7" />251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You beat the computer by %s points! Congratulations!' %<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scores[playerTile] - scores[computerTile]))<br class="calibre7" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif scores[playerTile] &lt; scores[computerTile]:<br class="calibre7" />253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('You lost. The computer beat you by %s points.' %<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(scores[computerTile] - scores[playerTile]))<br class="calibre7" />254.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />255.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game was a tie!')</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-359"></span>It begins by calling <span class="literal1">playGame()</span>. This function call does not return until the game is finished. The board data structure returned by <span class="literal1">playGame()</span> will be passed to <span class="literal1">getScoreOfBoard()</span> to count the <em class="calibre6">X</em> and <em class="calibre6">O</em> tiles to determine the final score. Line 249 displays this final score.</p>
<p class="indent">If there are more of the player’s tiles than the computer’s, line 251 congratulates the player for winning. If the computer won, line 253 tells the player that they lost. Otherwise, line 255 tells the player the game was a tie.</p>
<h3 class="h2" id="calibre_link-676"><strong class="calibre2">Asking the Player to Play Again</strong></h3>
<p class="noindent">After the game is finished, the player is asked whether they want to play again:</p>
<p class="programs">257.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to play again? (yes or no)')<br class="calibre7" />258.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not input().lower().startswith('y'):<br class="calibre7" />259.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">If the player does not type a reply that begins with the letter <em class="calibre6">y</em>, such as <span class="literal1">yes</span> or <span class="literal1">YES</span> or <span class="literal1">Y</span>, then the condition on line 258 evaluates to <span class="literal1">True</span>, and line 259 breaks out of the <span class="literal1">while</span> loop that started on line 243, which ends the game. Otherwise, this <span class="literal1">while</span> loop naturally loops, and <span class="literal1">playGame()</span> is called again to begin the next game.</p>
<h3 class="h2" id="calibre_link-677"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">The Reversegam AI may seem almost unbeatable, but this isn’t because the computer is smarter than we are; it’s just much faster! The strategy it follows is simple: move on the corner if you can, and otherwise make the move that will flip over the most tiles. A human could do that, but it would be time-consuming to figure out how many tiles would be flipped for every possible valid move. For the computer, calculating this number is simple.</p>
<p class="indent">This game is similar to Sonar Treasure Hunt because it makes use of a grid for a board. It is also like the Tic-Tac-Toe game because there’s an AI that plans out the best move for the computer to make. This chapter introduced only one new concept: that empty lists, blank strings, and the integer <span class="literal1">0</span> all evaluate to <span class="literal1">False</span> in the context of a condition. Other than that, this game used programming concepts you already knew!</p>
<p class="indent">In <a href="#calibre_link-22" class="calibre4">Chapter 16</a>, you’ll learn how to make AIs play computer games against each other.</p>
</div>



<a href="chapter14.html">Prev: Chapter 14 - Caesar Cipher</a> | <a href="chapter16.html">Next: Chapter 16 - Reversegam AI Simulation</a>
</body></html>