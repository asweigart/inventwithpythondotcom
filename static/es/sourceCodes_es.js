var sourceCodes = {"ahorcado":"import random\r\nIM\u00C1GENES_AHORCADO = [\'\'\'\r\n\r\n  +---+\r\n  |   |\r\n      |\r\n      |\r\n      |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n      |\r\n      |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n  |   |\r\n      |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n \/|   |\r\n      |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n \/|\\  |\r\n      |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n \/|\\  |\r\n \/    |\r\n      |\r\n=========\'\'\', \'\'\'\r\n\r\n  +---+\r\n  |   |\r\n  O   |\r\n \/|\\  |\r\n \/ \\  |\r\n      |\r\n=========\'\'\']\r\npalabras = \'hormiga babuino tejon murcielago oso castor camello gato almeja cobra pantera coyote cuervo ciervo perro burro pato aguila huron zorro rana cabra ganso halcon leon lagarto llama topo mono alce raton mula salamandra nutria buho panda loro paloma piton conejo carnero rata cuervo rinoceronte salmon foca tiburon oveja mofeta perezoso serpiente ara\u00F1a cig\u00FCe\u00F1a cisne tigre sapo trucha pavo tortuga comadreja ballena lobo wombat cebra\'.split()\r\n\r\ndef obtenerPalabraAlAzar(listaDePalabras):\r\n    # Esta funci\u00F3n devuelve una cadena al azar de la lista de cadenas pasada como argumento.\r\n    \u00EDndiceDePalabras = random.randint(0, len(listaDePalabras) - 1)\r\n    return listaDePalabras[\u00EDndiceDePalabras]\r\n\r\ndef mostrarTablero(IM\u00C1GENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta):\r\n    print(IM\u00C1GENES_AHORCADO[len(letrasIncorrectas)])\r\n    print()\r\n\r\n    print(\'Letras incorrectas:\', end=\' \')\r\n    for letra in letrasIncorrectas:\r\n        print(letra, end=\' \')\r\n    print()\r\n\r\n    espaciosVac\u00EDos = \'_\' * len(palabraSecreta)\r\n\r\n    for i in range(len(palabraSecreta)): # completar los espacios vac\u00EDos con las letras adivinadas\r\n        if palabraSecreta[i] in letrasCorrectas:\r\n            espaciosVac\u00EDos = espaciosVac\u00EDos[:i] + palabraSecreta[i] + espaciosVac\u00EDos[i+1:]\r\n\r\n    for letra in espaciosVac\u00EDos: # mostrar la palabra secreta con espacios entre cada letra\r\n        print(letra, end=\' \')\r\n    print()\r\n\r\ndef obtenerIntento(letrasProbadas):\r\n    # Devuelve la letra ingresada por el jugador. Verifica que el jugador ha ingresado s\u00F3lo una letra, y no otra cosa.\r\n    while True:\r\n        print(\'Adivina una letra.\')\r\n        intento = input()\r\n        intento = intento.lower()\r\n        if len(intento) != 1:\r\n            print(\'Por favor, introduce una letra.\')\r\n        elif intento in letrasProbadas:\r\n            print(\'Ya has probado esa letra. Elige otra.\')\r\n        elif intento not in \'abcdefghijklmn\u00F1opqrstuvwxyz\':\r\n            print(\'Por favor ingresa una LETRA.\')\r\n        else:\r\n            return intento\r\n\r\ndef jugarDeNuevo():\r\n    # Esta funci\u00F3n devuelve True si el jugador quiere volver a jugar, en caso contrario devuelve False.\r\n    print(\'\u00BFQuieres jugar de nuevo? (s\u00ED o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\nprint(\'A H O R C A D O\')\r\nletrasIncorrectas = \'\'\r\nletrasCorrectas = \'\'\r\npalabraSecreta = obtenerPalabraAlAzar(palabras)\r\njuegoTerminado = False\r\n\r\nwhile True:\r\n    mostrarTablero(IM\u00C1GENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta)\r\n\r\n    # Permite al jugador escribir una letra.\r\n    intento = obtenerIntento(letrasIncorrectas + letrasCorrectas)\r\n\r\n    if intento in palabraSecreta:\r\n        letrasCorrectas = letrasCorrectas + intento\r\n\r\n        # Verifica si el jugador ha ganado.\r\n        encontradoTodasLasLetras = True\r\n        for i in range(len(palabraSecreta)):\r\n            if palabraSecreta[i] not in letrasCorrectas:\r\n                encontradoTodasLasLetras = False\r\n                break\r\n        if encontradoTodasLasLetras:\r\n            print(\'\u00A1S\u00ED! \u00A1La palabra secreta es \"\' + palabraSecreta + \'\"! \u00A1Has ganado!\')\r\n            juegoTerminado = True\r\n    else:\r\n        letrasIncorrectas = letrasIncorrectas + intento\r\n\r\n        # Comprobar si el jugador ha agotado sus intentos y ha perdido.\r\n        if len(letrasIncorrectas) == len(IM\u00C1GENES_AHORCADO) - 1:\r\n            mostrarTablero(IM\u00C1GENES_AHORCADO, letrasIncorrectas, letrasCorrectas, palabraSecreta)\r\n            print(\'\u00A1Te has quedado sin intentos!\\nDespu\u00E9s de \' + str(len(letrasIncorrectas)) + \' intentos fallidos y \' + str(len(letrasCorrectas)) + \' aciertos, la palabra era \"\' + palabraSecreta + \'\"\')\r\n            juegoTerminado = True\r\n\r\n    # Preguntar al jugador si quiere volver a jugar (pero s\u00F3lo si el juego ha terminado).\r\n    if juegoTerminado:\r\n        if jugarDeNuevo():\r\n            letrasIncorrectas = \'\'\r\n            letrasCorrectas = \'\'\r\n            juegoTerminado = False\r\n            palabraSecreta = obtenerPalabraAlAzar(palabras)\r\n        else:\r\n            break\r\n",
    "spritesYsonidos":"import pygame, sys, time, random\r\nfrom pygame.locals import *\r\n\r\n# configurar pygame\r\npygame.init()\r\nmainClock = pygame.time.Clock()\r\n\r\n# configurar la ventana\r\nANCHOVENTANA = 400\r\nALTOVENTANA = 400\r\nsuperficieVentana = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), 0, 32)\r\npygame.display.set_caption(\'Sprites y Sonido\')\r\n\r\n# configurar los colores\r\nNEGRO = (0, 0, 0)\r\n\r\n# configurar la estructura de bloque de datos\r\njugador = pygame.Rect(300, 100, 40, 40)\r\nim\u00E1genJugador = pygame.image.load(\'jugador.png\')\r\nim\u00E1genEstiradaJugador = pygame.transform.scale(im\u00E1genJugador, (40, 40))\r\nim\u00E1genComida = pygame.image.load(\'cereza.png\')\r\ncomidas = []\r\nfor i in range(20):\r\n    comidas.append(pygame.Rect(random.randint(0, ANCHOVENTANA - 20), random.randint(0, ALTOVENTANA - 20), 20, 20))\r\n\r\ncontadorComida = 0\r\nNUEVACOMIDA = 40\r\n\r\n# configurar variables del teclado\r\nmoverseIzquierda = False\r\nmoverseDerecha = False\r\nmoverseArriba = False\r\nmoverseAbajo = False\r\n\r\nVELOCIDADMOVIMIENTO = 6\r\n\r\n# configurar m\u00FAsica\r\nsonidoRecolecci\u00F3n = pygame.mixer.Sound(\'recolecci\u00F3n.wav\')\r\npygame.mixer.music.load(\'m\u00FAsicaDeFondo.mid\')\r\npygame.mixer.music.play(-1, 0.0)\r\nm\u00FAsicaSonando = True\r\n\r\n# ejecutar el bucle del juego\r\nwhile True:\r\n    # comprobar si se ha disparado el evento QUIT (salir)\r\n    for evento in pygame.event.get():\r\n        if evento.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n        if evento.type == KEYDOWN:\r\n            # cambiar las variables del teclado\r\n            if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                moverseDerecha = False\r\n                moverseIzquierda = True\r\n            if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                moverseIzquierda = False\r\n                moverseDerecha = True\r\n            if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                moverseAbajo = False\r\n                moverseArriba = True\r\n            if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                moverseArriba = False\r\n                moverseAbajo = True\r\n        if evento.type == KEYUP:\r\n            if evento.key == K_ESCAPE:\r\n                pygame.quit()\r\n                sys.exit()\r\n            if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                moverseIzquierda = False\r\n            if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                moverseDerecha = False\r\n            if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                moverseArriba = False\r\n            if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                moverseAbajo = False\r\n            if evento.key == ord(\'x\'):\r\n                jugador.top = random.randint(0, ALTOVENTANA - jugador.height)\r\n                jugador.left = random.randint(0, ANCHOVENTANA - jugador.width)\r\n            if evento.key == ord(\'m\'):\r\n                if m\u00FAsicaSonando:\r\n                    pygame.mixer.music.stop()\r\n                else:\r\n                    pygame.mixer.music.play(-1, 0.0)\r\n                m\u00FAsicaSonando = not m\u00FAsicaSonando\r\n\r\n        if evento.type == MOUSEBUTTONUP:\r\n            comidas.append(pygame.Rect(evento.pos[0] - 10, evento.pos[1] - 10, 20, 20))\r\n\r\n    contadorComida += 1\r\n    if contadorComida >= NUEVACOMIDA:\r\n        # agregar nueva comida\r\n        contadorComida = 0\r\n        comidas.append(pygame.Rect(random.randint(0, ANCHOVENTANA - 20), random.randint(0, ALTOVENTANA - 20), 20, 20))\r\n\r\n    # pintar el fondo negro sobre la superficie\r\n    superficieVentana.fill(NEGRO)\r\n\r\n    # mover el jugador\r\n    if moverseAbajo and jugador.bottom < ALTOVENTANA:\r\n        jugador.top += VELOCIDADMOVIMIENTO\r\n    if moverseArriba and jugador.top > 0:\r\n        jugador.top -= VELOCIDADMOVIMIENTO\r\n    if moverseIzquierda and jugador.left > 0:\r\n        jugador.left -= VELOCIDADMOVIMIENTO\r\n    if moverseDerecha and jugador.right < ANCHOVENTANA:\r\n        jugador.right += VELOCIDADMOVIMIENTO\r\n\r\n\r\n    # dibujar el bloque sobre la superficie\r\n    superficieVentana.blit(im\u00E1genEstiradaJugador, jugador)\r\n\r\n    # comprobar si el jugador ha intersectado alguno de los cuadrados de comida\r\n    for comida in comidas[:]:\r\n        if jugador.colliderect(comida):\r\n            comidas.remove(comida)\r\n            jugador = pygame.Rect(jugador.left, jugador.top, jugador.width + 2, jugador.height + 2)\r\n            im\u00E1genEstiradaJugador = pygame.transform.scale(im\u00E1genJugador, (jugador.width, jugador.height))\r\n            if m\u00FAsicaSonando:\r\n                sonidoRecolecci\u00F3n.play()\r\n\r\n    # dibujar la comida\r\n    for comida in comidas:\r\n        superficieVentana.blit(im\u00E1genComida, comida)\r\n\r\n    # dibujar la ventana sobre la pantalla\r\n    pygame.display.update()\r\n    mainClock.tick(40)\r\n",
    "sonar":"# Sonar\r\n\r\nimport random\r\nimport sys\r\n\r\ndef dibujarTablero(tablero):\r\n    # Dibuja la estructura de datos del tablero.\r\n\r\n    l\u00EDneah = \'    \' # espacio inicial para los n\u00FAmeros a lo largo del lado izquierdo del tablero\r\n    for i in range(1, 6):\r\n        l\u00EDneah += (\' \' * 9) + str(i)\r\n\r\n    # imprimir los n\u00FAmeros a lo largo del borde superior\r\n    print(l\u00EDneah)\r\n    print(\'   \' + (\'0123456789\' * 6))\r\n    print()\r\n\r\n    # imprimir cada una de las 15 filas\r\n    for i in range(15):\r\n        # los n\u00FAmeros de una sola cifra deben ser precedidos por un espacio extra\r\n        if i < 10:\r\n            espacioExtra = \' \'\r\n        else:\r\n            espacioExtra = \'\'\r\n        print(\'%s%s %s %s\' % (espacioExtra, i, obtenerFila(tablero, i), i))\r\n\r\n    # imprimir los n\u00FAmeros a lo largo del borde inferior\r\n    print()\r\n    print(\'   \' + (\'0123456789\' * 6))\r\n    print(l\u00EDneah)\r\n\r\n\r\ndef obtenerFila(tablero, fila):\r\n    # Devuelve una cadena con la estructura de datos de un tablero para una fila determinada.\r\n    filaTablero = \'\'\r\n    for i in range(60):\r\n        filaTablero += tablero[i][fila]\r\n    return filaTablero\r\n\r\ndef obtenerNuevoTablero():\r\n    # Crear una nueva estructura de datos para un tablero de 60x15.\r\n    tablero = []\r\n    for x in range(60): # la lista principal es una lista de 60 listas\r\n        tablero.append([])\r\n        for y in range(15): # cada lista en la lista principal tiene 15 cadenas de un solo caracter\r\n            # usar diferentes caracteres para el oc\u00E9ano para hacerlo m\u00E1s f\u00E1cil de leer.\r\n            if random.randint(0, 1) == 0:\r\n                tablero[x].append(\'~\')\r\n            else:\r\n                tablero[x].append(\'`\')\r\n    return tablero\r\n\r\ndef obtenerCofresAleatorios(n\u00FAmCofres):\r\n    # Crear una lista de estructuras de datos cofre (listas de dos \u00EDtems con coordenadas x, y)\r\n    cofres = []\r\n    for i in range(n\u00FAmCofres):\r\n        cofres.append([random.randint(0, 59), random.randint(0, 14)])\r\n    return cofres\r\n\r\ndef esMovidaV\u00E1lida(x, y):\r\n    # Devuelve True si las coordenadas pertenecen al tablero, de lo contrario False.\r\n    return x >= 0 and x <= 59 and y >= 0 and y <= 14\r\n\r\ndef realizarMovida(tablero, cofres, x, y):\r\n    # Cambia la estructura de datos del tablero agregando un caracter de dispositivo sonar. Elimina los cofres\r\n    # de la lista de cofres a medida que son encontrados. Devuelve False si la movida no es v\u00E1lida.\r\n    # En caso contrario, devuelve una cadena con el resultado de esa movida.\r\n    if not esMovidaV\u00E1lida(x, y):\r\n        return False\r\n\r\n    menorDistancia = 100 # cualquier cofre estar\u00E1 a una distancia menor que 100.\r\n    for cx, cy in cofres:\r\n        if abs(cx - x) > abs(cy - y):\r\n            distancia = abs(cx - x)\r\n        else:\r\n            distancia = abs(cy - y)\r\n\r\n        if distancia < menorDistancia: # queremos el cofre m\u00E1s cercano.\r\n            menorDistancia = distancia\r\n\r\n    if menorDistancia == 0:\r\n        # \u00A1xy est\u00E1 directamente sobre un cofre!\r\n        cofres.remove([x, y])\r\n        return \'\u00A1Has encontrado un cofre del tesoro hundido!\'\r\n    else:\r\n        if menorDistancia < 10:\r\n            tablero[x][y] = str(menorDistancia)\r\n            return \'Tesoro detectado a una distancia %s del dispositivo sonar.\' % (menorDistancia)\r\n        else:\r\n            tablero[x][y] = \'O\'\r\n            return \'El sonar no ha detectado nada. Todos los cofres est\u00E1n fuera del alcance del dispositivo.\'\r\n\r\n\r\ndef ingresarMovidaJugador():\r\n    # Permite al jugador teclear su movida. Devuelve una lista de dos \u00EDtems con coordenadas xy.\r\n    print(\'\u00BFD\u00F3nde quieres dejar caer el siguiente dispositivo sonar? (0-59 0-14) (o teclea salir)\')\r\n    while True:\r\n        movida = input()\r\n        if movida.lower() == \'salir\':\r\n            print(\'\u00A1Gracias por jugar!\')\r\n            sys.exit()\r\n\r\n        movida = movida.split()\r\n        if len(movida) == 2 and movida[0].isdigit() and movida[1].isdigit() and esMovidaV\u00E1lida(int(movida[0]), int(movida[1])):\r\n            return [int(movida[0]), int(movida[1])]\r\n        print(\'Ingresa un n\u00FAmero de 0 a 59, un espacio, y luego un n\u00FAmero de 0 a 14.\')\r\n\r\n\r\ndef jugarDeNuevo():\r\n    # Esta funci\u00F3n devuelve True si el jugador quiere jugar de nuevo, de lo contrario devuelve False.\r\n    print(\'\u00BFQuieres jugar de nuevo? (s\u00ED o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\ndef mostrarInstrucciones():\r\n    print(\'\'\'Instrucciones:\r\nEres el capit\u00E1n de Sim\u00F3n, un buque cazador de tesoros. Tu misi\u00F3n actual\r\nes encontrar los tres cofres con tesoros perdidos que se hallan ocultos en la parte del\r\noc\u00E9ano en que te encuentras y recogerlos.\r\n\r\nPara jugar, ingresa las coordenadas del punto del oc\u00E9ano en que quieres colocar un\r\ndispositivo sonar. El sonar puede detectar cu\u00E1l es la distancia al cofre m\u00E1s cercano.\r\nPor ejemplo, la d abajo indica d\u00F3nde se ha colocado el dispositivo, y los n\u00FAmeros 2\r\nrepresentan los sitios a una distancia 2 del dispositivo. Los n\u00FAmeros 4 representan\r\nlos sitios a una distancia 4 del dispositivo.\r\n\r\n    444444444\r\n    4       4\r\n    4 22222 4\r\n    4 2   2 4\r\n    4 2 d 2 4\r\n    4 2   2 4\r\n    4 22222 4\r\n    4       4\r\n    444444444\r\nPulsa enter para continuar...\'\'\')\r\n    input()\r\n\r\n    print(\'\'\'Por ejemplo, aqu\u00ED hay un cofre del tesoro (la c) ubicado a una distancia 2\r\ndel dispositivo sonar (la d):\r\n\r\n    22222\r\n    c   2\r\n    2 d 2\r\n    2   2\r\n    22222\r\n\r\nEl punto donde el dispositivo fue colocado se indicar\u00E1 con un 2.\r\n\r\nLos cofres del tesoro no se mueven. Los dispositivos sonar pueden detectar\r\ncofres hasta una distancia 9. Si todos los cofres est\u00E1n fuera del alcance, el punto\r\nse indicar\u00E1 con un O.\r\n\r\nSi un dispositivo es colocado directamente sobre un cofre del tesoro, has descubierto\r\nla ubicaci\u00F3n del cofre, y este ser\u00E1 recogido. El dispositivo sonar\r\npermanecer\u00E1 all\u00ED.\r\n\r\nCuando recojas un cofre, todos los dispositivos sonar se actualizar\u00E1n para localizar el pr\u00F3ximo\r\ncofre hundido m\u00E1s cercano.\r\nPulsa enter para continuar...\'\'\')\r\n    input()\r\n    print()\r\n\r\n\r\nprint(\'\u00A1 S O N A R !\')\r\nprint()\r\nprint(\'\u00BFTe gustar\u00EDa ver las instrucciones? (s\u00ED\/no)\')\r\nif input().lower().startswith(\'s\'):\r\n    mostrarInstrucciones()\r\n\r\nwhile True:\r\n    # configuraci\u00F3n del juego\r\n    dispositivosSonar = 16\r\n    elTablero = obtenerNuevoTablero()\r\n    losCofres = obtenerCofresAleatorios(3)\r\n    dibujarTablero(elTablero)\r\n    movidasPrevias = []\r\n\r\n    while dispositivosSonar > 0:\r\n        # Comienzo de un turno:\r\n\r\n        # mostrar el estado de los dispositivos sonar \/ cofres\r\n        if dispositivosSonar > 1: extraSsonar = \'s\'\r\n        else: extraSsonar = \'\'\r\n        if len(losCofres) > 1: extraScofre = \'s\'\r\n        else: extraScofre = \'\'\r\n        print(\'A\u00FAn tienes %s dispositivos%s  sonar. Falta encontrar %s cofre%s.\' % (dispositivosSonar, extraSsonar, len(losCofres), extraScofre))\r\n\r\n        x, y = ingresarMovidaJugador()\r\n        movidasPrevias.append([x, y]) # debemos registrar todas las movidas para que los dispositivos sonar puedan ser actualizados.\r\n\r\n        resultadoMovida = realizarMovida(elTablero, losCofres, x, y)\r\n        if resultadoMovida == False:\r\n            continue\r\n        else:\r\n            if resultadoMovida == \'\u00A1Has encontrado uno de los cofres del tesoro!\':\r\n                # actualizar todos los dispositivos sonar presentes en el mapa.\r\n                for x, y in movidasPrevias:\r\n                    realizarMovida(elTablero, losCofres, x, y)\r\n            dibujarTablero(elTablero)\r\n            print(resultadoMovida)\r\n\r\n        if len(losCofres) == 0:\r\n            print(\'\u00A1Has encontrado todos los cofres del tesoro! \u00A1Felicitaciones y buena partida!\')\r\n            break\r\n\r\n        dispositivosSonar -= 1\r\n\r\n    if dispositivosSonar == 0:\r\n        print(\'\u00A1Nos hemos quedado sin dispositivos sonar! \u00A1Ahora tenemos que dar la vuelta y dirigirnos\')\r\n        print(\'de regreso a casa dejando tesoros en el mar! Juego terminado.\')\r\n        print(\'    Los cofres restantes estaban aqu\u00ED:\')\r\n        for x, y in losCofres:\r\n            print(\'    %s, %s\' % (x, y))\r\n\r\n    if not jugarDeNuevo():\r\n        sys.exit()\r\n",
    "reversi":"# Reversi\r\n\r\nimport random\r\nimport sys\r\n\r\ndef dibujarTablero(tablero):\r\n    # Esta funcion dibuja el tablero recibido. Devuelve None\r\n    L\u00CDNEAH = \'  +---+---+---+---+---+---+---+---+\'\r\n    L\u00CDNEAV = \'  |   |   |   |   |   |   |   |   |\'\r\n\r\n    print(\'    1   2   3   4   5   6   7   8\')\r\n    print(L\u00CDNEAH)\r\n    for y in range(8):\r\n        print(L\u00CDNEAV)\r\n        print(y+1, end=\' \')\r\n        for x in range(8):\r\n            print(\'| %s\' % (tablero[x][y]), end=\' \')\r\n        print(\'|\')\r\n        print(L\u00CDNEAV)\r\n        print(L\u00CDNEAH)\r\n\r\n\r\ndef reiniciarTablero(tablero):\r\n    # Deja en blanco el tablero recibido como argumento, excepto la posici\u00F3n inicial\r\n    for x in range(8):\r\n        for y in range(8):\r\n            tablero[x][y] = \' \'\r\n\r\n    # Piezas iniciales:\r\n    tablero[3][3] = \'X\'\r\n    tablero[3][4] = \'O\'\r\n    tablero[4][3] = \'O\'\r\n    tablero[4][4] = \'X\'\r\n\r\n\r\ndef obtenerNuevoTablero():\r\n    # Crea un tablero nuevo, vac\u00EDo.\r\n    tablero = []\r\n    for i in range(8):\r\n        tablero.append([\' \'] * 8)\r\n\r\n    return tablero\r\n\r\n\r\ndef esJugadaV\u00E1lida(tablero, baldosa, comienzox, comienzoy):\r\n    # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida\r\n    # Si es una jugada v\u00E1lida, devuelve una lista de espacios que pasar\u00EDan a ser del jugador si moviera aqu\u00ED.\r\n    if tablero[comienzox][comienzoy] != \' \' or not est\u00E1EnTablero(comienzox, comienzoy):\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa # coloca temporariamente la baldosa sobre el tablero.\r\n\r\n    if baldosa == \'X\':\r\n        otraBaldosa = \'O\'\r\n    else:\r\n        otraBaldosa = \'X\'\r\n\r\n    baldosasAConvertir = []\r\n    for direcci\u00F3nx, direcci\u00F3ny in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = comienzox, comienzoy\r\n        x += direcci\u00F3nx # primer paso en la direcci\u00F3n\r\n        y += direcci\u00F3ny # primer paso en la direcci\u00F3n\r\n        if est\u00E1EnTablero(x, y) and tablero[x][y] == otraBaldosa:\r\n            # Hay una pieza perteneciente al otro jugador al lado de nustra pieza\r\n            x += direcci\u00F3nx\r\n            y += direcci\u00F3ny\r\n            if not est\u00E1EnTablero(x, y):\r\n                continue\r\n            while tablero[x][y] == otraBaldosa:\r\n                x += direcci\u00F3nx\r\n                y += direcci\u00F3ny\r\n                if not est\u00E1EnTablero(x, y): # sale del bucle while y continua en el bucle for.\r\n                    break\r\n            if not est\u00E1EnTablero(x, y):\r\n                continue\r\n            if tablero[x][y] == baldosa:\r\n                # Hay fichas a convertir. Caminar en direcci\u00F3n opuesta hasta llegar al casillero original, registrando todas las posiciones en el camino.\r\n                while True:\r\n                    x -= direcci\u00F3nx\r\n                    y -= direcci\u00F3ny\r\n                    if x == comienzox and y == comienzoy:\r\n                        break\r\n                    baldosasAConvertir.append([x, y])\r\n\r\n    tablero[comienzox][comienzoy] = \' \' # restablecer el espacio vac\u00EDo\r\n    if len(baldosasAConvertir) == 0: # Si no se convirti\u00F3 ninguna baldosa, la jugada no es v\u00E1lida.\r\n        return False\r\n    return baldosasAConvertir\r\n\r\n\r\ndef est\u00E1EnTablero(x, y):\r\n    # Devuelve True si las coordenadas se encuentran dentro del tablero\r\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\r\n\r\n\r\ndef obtenerTableroConJugadasV\u00E1lidas(tablero, baldosa):\r\n    # Devuelve un nuevo tablero, marcando con \".\" las jugadas v\u00E1lidas que el jugador puede realizar.\r\n    r\u00E9plicaTablero = obtenerCopiaTablero(tablero)\r\n\r\n    for x, y in obtenerJugadasV\u00E1lidas(r\u00E9plicaTablero, baldosa):\r\n        r\u00E9plicaTablero[x][y] = \'.\'\r\n    return r\u00E9plicaTablero\r\n\r\n\r\ndef obtenerJugadasV\u00E1lidas(tablero, baldosa):\r\n    # Devuelve una lista de listas [x,y] de jugadas v\u00E1lidas para el jugador en el tablero dado.\r\n    jugadasV\u00E1lidas = []\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if esJugadaV\u00E1lida(tablero, baldosa, x, y) != False:\r\n                jugadasV\u00E1lidas.append([x, y])\r\n    return jugadasV\u00E1lidas\r\n\r\n\r\ndef obtenerPuntajeTablero(tablero):\r\n    # Determina el puntaje contando las piezas. Devuelve un diccionario con claves \'X\' y \'O\'.\r\n    puntajex = 0\r\n    puntajeo = 0\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if tablero[x][y] == \'X\':\r\n                puntajex += 1\r\n            if tablero[x][y] == \'O\':\r\n                puntajeo += 1\r\n    return {\'X\':puntajex, \'O\':puntajeo}\r\n\r\n\r\ndef ingresarBaldosaJugador():\r\n    # Permite al jugador elegir que baldosa desea ser.\r\n    # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.\r\n    baldosa = \'\'\r\n    while not (baldosa == \'X\' or baldosa == \'O\'):\r\n        print(\'\u00BFDeseas ser X \u00F3 O?\')\r\n        baldosa = input().upper()\r\n\r\n    #  El primer elemento en la lista es la baldosa del juegador, el segundo es la de la computadora.\r\n    if baldosa == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\n\r\ndef qui\u00E9nComienza():\r\n    # Elije al azar qu\u00E9 jugador comienza.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computadora\'\r\n    else:\r\n        return \'jugador\'\r\n\r\n\r\ndef jugarDeNuevo():\r\n    # Esta funci\u00F3n devuelve True si el jugador quiere jugar de nuevo, de lo contrario devuelve False.\r\n    print(\'\u00BFQuieres jugar de nuevo? (s\u00ED o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\ndef hacerJugada(tablero, baldosa, comienzox, comienzoy):\r\n    # Coloca la baldosa sobre el tablero en comienzox, comienzoy, y convierte cualquier baldosa del oponente.\r\n    # Devuelve False si la jugada es inv\u00E1lida, True si es v\u00E1lida.\r\n    baldosasAConvertir = esJugadaV\u00E1lida(tablero, baldosa, comienzox, comienzoy)\r\n\r\n    if baldosasAConvertir == False:\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa\r\n    for x, y in baldosasAConvertir:\r\n        tablero[x][y] = baldosa\r\n    return True\r\n\r\n\r\ndef obtenerCopiaTablero(tablero):\r\n    # Duplica la lista del tablero y devuelve el duplicado.\r\n    r\u00E9plicaTablero = obtenerNuevoTablero()\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            r\u00E9plicaTablero[x][y] = tablero[x][y]\r\n\r\n    return r\u00E9plicaTablero\r\n\r\n\r\ndef esEsquina(x, y):\r\n    # Devuelve True si la posicion es una de las esquinas.\r\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\r\n\r\n\r\ndef obtenerJugadaJugador(tablero, baldosaJugador):\r\n    # Permite al jugador tipear su jugada.\r\n    # Devuelve la jugada como [x, y] (o devuelve las cadenas \'pistas\' o \'salir\')\r\n    CIFRAS1A8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Ingresa tu jugada, salir para terminar el juego, o pistas para activar\/desactivar las pistas.\')\r\n        jugada = input().lower()\r\n        if jugada == \'salir\':\r\n            return \'salir\'\r\n        if jugada == \'pistas\':\r\n            return \'pistas\'\r\n\r\n        if len(jugada) == 2 and jugada[0] in CIFRAS1A8 and jugada[1] in CIFRAS1A8:\r\n            x = int(jugada[0]) - 1\r\n            y = int(jugada[1]) - 1\r\n            if esJugadaV\u00E1lida(tablero, baldosaJugador, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'Esta no es una jugada v\u00E1lida. Ingresa la coordenada x (1-8), luego la coordenada y (1-8).\')\r\n            print(\'Por ejemplo, 81 corresponde a la esquina superior derecha.\')\r\n\r\n    return [x, y]\r\n\r\n\r\ndef obtenerJugadaComputadora(tablero, baldosaComputadora):\r\n    # Dado un tablero y la baldosa de la computadora, determinar d\u00F3nde\r\n    # jugar y devolver esa jugada como una lista [x, y].\r\n    jugadasPosibles = obtenerJugadasV\u00E1lidas(tablero, baldosaComputadora)\r\n\r\n    # ordena al azar el orden de las jugadas posibles\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # siempre jugar en una esquina si est\u00E1 disponible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    # Recorrer la lista de jugadas posibles y recordar la que da el mejor puntaje\r\n    mejorPuntaje = -1\r\n    for x, y in jugadasPosibles:\r\n        r\u00E9plicaTablero = obtenerCopiaTablero(tablero)\r\n        hacerJugada(r\u00E9plicaTablero, baldosaComputadora, x, y)\r\n        puntaje = obtenerPuntajeTablero(r\u00E9plicaTablero)[baldosaComputadora]\r\n        if puntaje > mejorPuntaje:\r\n            mejorJugada = [x, y]\r\n            mejorPuntaje = puntaje\r\n    return mejorJugada\r\n\r\n\r\ndef mostrarPuntajes(baldosaJugador, baldosaComputadora):\r\n    # Imprime el puntaje actual.\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'Tienes %s puntos. La computadora tiene %s puntos.\' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))\r\n\r\n\r\n\r\nprint(\'\u00A1Bienvenido a Reversi!\')\r\n\r\nwhile True:\r\n    # Reiniciar el tablero y el juego.\r\n    tableroPrincipal = obtenerNuevoTablero()\r\n    reiniciarTablero(tableroPrincipal)\r\n    baldosaJugador, baldosaComputadora = ingresarBaldosaJugador()\r\n    mostrarPistas = False\r\n    turno = qui\u00E9nComienza()\r\n    print((\"El \" if turno == \"jugador\" else \"La \") + turno + \' will go first.\')\r\n\r\n    while True:\r\n        if turno == \'jugador\':\r\n            # Turno del jugador\r\n            if mostrarPistas:\r\n                tableroConJugadasV\u00E1lidas = obtenerTableroConJugadasV\u00E1lidas(tableroPrincipal, baldosaJugador)\r\n                dibujarTablero(tableroConJugadasV\u00E1lidas)\r\n            else:\r\n                dibujarTablero(tableroPrincipal)\r\n            mostrarPuntajes(baldosaJugador, baldosaComputadora)\r\n            jugada = obtenerJugadaJugador(tableroPrincipal, baldosaJugador)\r\n            if jugada == \'salir\':\r\n                print(\'\u00A1Gracias por jugar!\')\r\n                sys.exit() # terminar el programa\r\n            elif jugada == \'pistas\':\r\n                mostrarPistas = not mostrarPistas\r\n                continue\r\n            else:\r\n                hacerJugada(tableroPrincipal, baldosaJugador, jugada[0], jugada[1])\r\n\r\n            if obtenerJugadasV\u00E1lidas(tableroPrincipal, baldosaComputadora) == []:\r\n                break\r\n            else:\r\n                turno = \'computadora\'\r\n\r\n        else:\r\n            # Turno de la computadora\r\n            dibujarTablero(tableroPrincipal)\r\n            mostrarPuntajes(baldosaJugador, baldosaComputadora)\r\n            input(\'Presiona enter para ver la jugada de la computadora.\')\r\n            x, y = obtenerJugadaComputadora(tableroPrincipal, baldosaComputadora)\r\n            hacerJugada(tableroPrincipal, baldosaComputadora, x, y)\r\n\r\n            if obtenerJugadasV\u00E1lidas(tableroPrincipal, baldosaJugador) == []:\r\n                break\r\n            else:\r\n                turno = \'jugador\'\r\n\r\n    # Mostrar el puntaje final.\r\n    dibujarTablero(tableroPrincipal)\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'X ha obtenido %s puntos. O ha obtenido %s puntos.\' % (puntajes[\'X\'], puntajes[\'O\']))\r\n    if puntajes[baldosaJugador] > puntajes[baldosaComputadora]:\r\n        print(\'\u00A1Has vencido a la computadora por %s puntos! \u00A1Felicitaciones!\' % (puntajes[baldosaJugador] - puntajes[baldosaComputadora]))\r\n    elif puntajes[baldosaJugador] < puntajes[baldosaComputadora]:\r\n        print(\'Has perdido. La computadora te ha vencido por %s puntos.\' % (puntajes[baldosaComputadora] - puntajes[baldosaJugador]))\r\n    else:\r\n        print(\'\u00A1Ha sido un empate!\')\r\n\r\n    if not jugarDeNuevo():\r\n        break\r\n",
    "pygameHolaMundo":"import pygame, sys\r\nfrom pygame.locals import *\r\n\r\n# configurar pygame\r\npygame.init()\r\n\r\n# configurar la ventana\r\nsuperficieVentana = pygame.display.set_mode((500, 400), 0, 32)\r\npygame.display.set_caption(\'\u00A1Hola mundo!\')\r\n\r\n# configurar los colores\r\nNEGRO = (0, 0, 0)\r\nBLANCO = (255, 255, 255)\r\nROJO = (255, 0, 0)\r\nVERDE = (0, 255, 0)\r\nAZUL = (0, 0, 255)\r\n\r\n# configurar fuentes\r\nfuenteB\u00E1sica = pygame.font.SysFont(None, 48)\r\n\r\n# configurar el texto\r\ntexto = fuenteB\u00E1sica.render(\'\u00A1Hola mundo!\', True, BLANCO, AZUL)\r\ntextRect = texto.get_rect()\r\ntextRect.centerx = superficieVentana.get_rect().centerx\r\ntextRect.centery = superficieVentana.get_rect().centery\r\n\r\n# pintar un fondo blanco sobre la ventana\r\nsuperficieVentana.fill(BLANCO)\r\n\r\n# dibujar un pol\u00EDgono verde sobre la superficie\r\npygame.draw.polygon(superficieVentana, VERDE, ((146, 0), (291, 106), (236, 277), (56, 277), (0, 106)))\r\n\r\n# dibujar algunas l\u00EDneas azules sobre la superficie\r\npygame.draw.line(superficieVentana, AZUL, (60, 60), (120, 60), 4)\r\npygame.draw.line(superficieVentana, AZUL, (120, 60), (60, 120))\r\npygame.draw.line(superficieVentana, AZUL, (60, 120), (120, 120), 4)\r\n\r\n# dibujar un c\u00EDrculo azul sobre la superficie\r\npygame.draw.circle(superficieVentana, AZUL, (300, 50), 20, 0)\r\n\r\n# dibujar una elipse roja sobre la superficie\r\npygame.draw.ellipse(superficieVentana, ROJO, (300, 250, 40, 80), 1)\r\n\r\n# dibujar el rect\u00E1ngulo de fondo para el texto sobre la superficie\r\npygame.draw.rect(superficieVentana, ROJO, (textRect.left - 20, textRect.top - 20, textRect.width + 40, textRect.height + 40))\r\n\r\n# obtener un arreglo de p\u00EDxeles de la superficie\r\narregloDeP\u00EDxeles = pygame.PixelArray(superficieVentana)\r\narregloDeP\u00EDxeles[480][380] = NEGRO\r\ndel arregloDeP\u00EDxeles\r\n\r\n# dibujar el texto sobre la superficie\r\nsuperficieVentana.blit(texto, textRect)\r\n\r\n# dibujar la ventana sobre la pantalla\r\npygame.display.update()\r\n\r\n# ejecutar el bucle del juego\r\nwhile True:\r\n    for event in pygame.event.get():\r\n        if event.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n",
    "pygameEntrada":"import pygame, sys, random\r\nfrom pygame.locals import *\r\n\r\n# configurar pygame\r\npygame.init()\r\nrelojPrincipal = pygame.time.Clock()\r\n\r\n# configurar la ventana\r\nANCHOVENTANA = 400\r\nALTURAVENTANA = 400\r\nsuperficieVentana = pygame.display.set_mode((ANCHOVENTANA, ALTURAVENTANA), 0, 32)\r\npygame.display.set_caption(\'Entrada\')\r\n\r\n# configurar los colores\r\nNEGRO = (0, 0, 0)\r\nVERDE = (0, 255, 0)\r\nBLANCO = (255, 255, 255)\r\n\r\n# configurar estructura de datos del jugador y la comida\r\ncontadorDeComida = 0\r\nNUEVACOMIDA = 40\r\nTAMA\u00D1OCOMIDA = 20\r\njugador = pygame.Rect(300, 100, 50, 50)\r\ncomidas = []\r\nfor i in range(20):\r\n    comidas.append(pygame.Rect(random.randint(0, ANCHOVENTANA - TAMA\u00D1OCOMIDA), random.randint(0, ALTURAVENTANA - TAMA\u00D1OCOMIDA), TAMA\u00D1OCOMIDA, TAMA\u00D1OCOMIDA))\r\n\r\n# configurar variables de movimiento\r\nmoverseIzquierda = False\r\nmoverseDerecha = False\r\nmoverseArriba = False\r\nmoverseAbajo = False\r\n\r\nMOVESPEED = 6\r\n\r\n\r\n# ejecutar el bucle del juego\r\nwhile True:\r\n    # comprobar eventos\r\n    for evento in pygame.event.get():\r\n        if evento.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n        if evento.type == KEYDOWN:\r\n            # cambiar las variables del teclado\r\n            if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                moverseDerecha = False\r\n                moverseIzquierda = True\r\n            if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                moverseIzquierda = False\r\n                moverseDerecha = True\r\n            if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                moverseAbajo = False\r\n                moverseArriba = True\r\n            if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                moverseArriba = False\r\n                moverseAbajo = True\r\n        if evento.type == KEYUP:\r\n            if evento.key == K_ESCAPE:\r\n                pygame.quit()\r\n                sys.exit()\r\n            if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                moverseIzquierda = False\r\n            if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                moverseDerecha = False\r\n            if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                moverseArriba = False\r\n            if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                moverseAbajo = False\r\n            if evento.key == ord(\'x\'):\r\n                jugador.top = random.randint(0, ALTURAVENTANA - jugador.height)\r\n                jugador.left = random.randint(0, ANCHOVENTANA - jugador.width)\r\n\r\n        if evento.type == MOUSEBUTTONUP:\r\n            comidas.append(pygame.Rect(evento.pos[0], evento.pos[1], TAMA\u00D1OCOMIDA, TAMA\u00D1OCOMIDA))\r\n\r\n    contadorDeComida += 1\r\n    if contadorDeComida >= NUEVACOMIDA:\r\n        # agregar nueva comida\r\n        contadorDeComida = 0\r\n        comidas.append(pygame.Rect(random.randint(0, ANCHOVENTANA - TAMA\u00D1OCOMIDA), random.randint(0, ALTURAVENTANA - TAMA\u00D1OCOMIDA), TAMA\u00D1OCOMIDA, TAMA\u00D1OCOMIDA))\r\n\r\n    # dibujar el fondo negro sobre la superficie\r\n    superficieVentana.fill(NEGRO)\r\n\r\n    # mover al jugador\r\n    if moverseAbajo and jugador.bottom < ALTURAVENTANA:\r\n        jugador.top += MOVESPEED\r\n    if moverseArriba and jugador.top > 0:\r\n        jugador.top -= MOVESPEED\r\n    if moverseIzquierda and jugador.left > 0:\r\n        jugador.left -= MOVESPEED\r\n    if moverseDerecha and jugador.right < ANCHOVENTANA:\r\n        jugador.right += MOVESPEED\r\n\r\n    # dibujar al jugador sobre la superficie\r\n    pygame.draw.rect(superficieVentana, BLANCO, jugador)\r\n\r\n    # comprobar si el jugador ha intersectado alguno de los cuadrados de comida\r\n    for food in comidas[:]:\r\n        if jugador.colliderect(food):\r\n            comidas.remove(food)\r\n\r\n    # dibujar la comida\r\n    for i in range(len(comidas)):\r\n        pygame.draw.rect(superficieVentana, VERDE, comidas[i])\r\n\r\n    # dibujar la ventana sobre la pantalla\r\n    pygame.display.update()\r\n    relojPrincipal.tick(40)\r\n",
    "panecillos":"import random\r\ndef obtenerNumSecreto(digitosNum):\r\n    # Devuelve un numero de largo digotosNUm, compuesto de d\u00EDgitos \u00FAnicos al azar.\r\n    numeros = list(range(10))\r\n    random.shuffle(numeros)\r\n    numSecreto = \'\'\r\n    for i in range(digitosNum):\r\n        numSecreto += str(numeros[i])\r\n    return numSecreto\r\n\r\ndef obtenerPistas(conjetura, numSecreto):\r\n    # Devuelve una palabra con las pistas Panecillos Pico y Fermi en ella.\r\n    if conjetura == numSecreto:\r\n        return \'\u00A1Lo has adivinado!\'\r\n\r\n    pista = []\r\n\r\n    for i in range(len(conjetura)):\r\n        if conjetura[i] == numSecreto[i]:\r\n            pista.append(\'Fermi\')\r\n        elif conjetura[i] in numSecreto:\r\n            pista.append(\'Pico\')\r\n    if len(pista) == 0:\r\n        return \'Panecillos\'\r\n\r\n    pista.sort()\r\n    return \' \'.join(pista)\r\n\r\ndef esSoloDigitos(num):\r\n    # Devuelve True si el n\u00FAmero se compone s\u00F3lo de d\u00EDgitos. De lo contrario Falso.\r\n    if num == \'\':\r\n        return False\r\n\r\n    for i in num:\r\n        if i not in \'0 1 2 3 4 5 6 7 8 9\'.split():\r\n            return False\r\n\r\n    return True\r\n\r\ndef jugarDeNuevo():\r\n    # Esta funcion devuelve True si el jugador desea vovler a jugar, de lo contrario Falso.\r\n    print(\'\u00BFDeseas volver a jugar? (s\u00ED o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\ndigitosNum = 3\r\nMAXADIVINANZAS = 10\r\n\r\nprint(\'Estoy pensando en un n\u00FAmero de %s d\u00EDgitos. Intenta adivinar cu\u00E1l es.\' % (digitosNum))\r\nprint(\'Aqu\u00ED hay algunas pistas:\')\r\nprint(\'Cuando digo:    Eso significa:\')\r\nprint(\'  Pico          Un d\u00EDgito es correcto pero en la posici\u00F3n incorrecta.\')\r\nprint(\'  Fermi         Un d\u00EDgito es correcto y en la posici\u00F3n correcta.\')\r\nprint(\'  Panecillos    Ning\u00FAn d\u00EDgito es correcto.\')\r\n\r\nwhile True:\r\n    numSecreto = obtenerNumSecreto(digitosNum)\r\n    print(\'He pensado un n\u00FAmero. Tienes %s intentos para adivinarlo.\' % (MAXADIVINANZAS))\r\n\r\n    numIntentos = 1\r\n    while numIntentos <= MAXADIVINANZAS:\r\n        conjetura = \'\'\r\n        while len(conjetura) != digitosNum or not esSoloDigitos(conjetura):\r\n            print(\'Conjetura #%s: \' % (numIntentos))\r\n            conjetura = input()\r\n\r\n        pista = obtenerPistas(conjetura, numSecreto)\r\n        print(pista)\r\n        numIntentos += 1\r\n\r\n        if conjetura == numSecreto:\r\n            break\r\n        if numIntentos > MAXADIVINANZAS:\r\n            print(\'Te has quedado sin intentos. La respuesta era %s.\' % (numSecreto))\r\n\r\n    if not jugarDeNuevo():\r\n        break\r\n",
    "lanzarMoneda":"import random\r\nprint(\'Lanzar\u00E9 una moneda 1000 veces. Adivina cuantas veces caer\u00E1 Cara. (Presiona enter para comenzar)\')\r\ninput()\r\nlanzamientos = 0\r\ncaras = 0\r\nwhile lanzamientos < 1000:\r\n    if random.randint(0, 1) == 1:\r\n        caras = caras + 1\r\n    lanzamientos = lanzamientos + 1\r\n\r\n    if lanzamientos == 900:\r\n        print(\'900 lanzamientos y hubo \' + str(caras) + \' caras.\')\r\n    if lanzamientos == 100:\r\n        print(\'En 100 lanzamientos, cara sali\u00F3 \' + str(caras) + \' veces.\')\r\n    if lanzamientos == 500:\r\n        print(\'La mitad de los lanzamientos y cara sali\u00F3 \' + str(caras) + \' veces.\')\r\n\r\nprint()\r\nprint(\'De 1000 lanzamientos, al final cara sali\u00F3 \' + str(caras) + \' veces!\')\r\nprint(\'\u00BFEstuviste cerca?\')",
    "hola":"# Este programa saluda y pregunta por mi nombre.\r\nprint(\'\u00A1Hola Mundo!\')\r\nprint(\'\u00BFC\u00F3mo te llamas?\')\r\nmiNombre = input()\r\nprint(\'Es un placer conocerte, \' + miNombre)\r\n",
    "evasorPantallaCompleta":"import pygame, random, sys\r\nfrom pygame.locals import *\r\n\r\nANCHOVENTANA = 600\r\nALTOVENTANA = 600\r\nCOLORVENTANA = (255, 255, 255)\r\nCOLORFONDO = (0, 0, 0)\r\nFPS = 40\r\nTAMA\u00D1OMINVILLANO = 10\r\nTAMA\u00D1OMAXVILLANO = 40\r\nVELOCIDADMINVILLANO = 1\r\nVELOCIDADMAXVILLANO = 8\r\nTASANUEVOVILLANO = 6\r\nTASAMOVIMIENTOJUGADOR = 5\r\n\r\ndef terminar():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\ndef esperarTeclaJugador():\r\n    while True:\r\n        for evento in pygame.event.get():\r\n            if evento.type == QUIT:\r\n                terminar()\r\n            if evento.type == KEYDOWN:\r\n                if evento.key == K_ESCAPE: # Quita al presionar ESCAPE\r\n                    terminar()\r\n                return\r\n\r\ndef jugadorGolpeaVillano(rectanguloJugador, villanos):\r\n    for v in villanos:\r\n        if rectanguloJugador.colliderect(v[\'rect\']):\r\n            return True\r\n    return False\r\n\r\ndef dibujarTexto(texto, font, superficie, x, y):\r\n    objetotexto = font.render(texto, 1, COLORVENTANA)\r\n    rectangulotexto = objetotexto.get_rect()\r\n    rectangulotexto.topleft = (x, y)\r\n    superficie.blit(objetotexto, rectangulotexto)\r\n\r\n# establece un pygame, la ventana y el cursor del rat\u00F3n\r\npygame.init()\r\nrelojPrincipal = pygame.time.Clock()\r\nsuperficieVentana = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), pygame.FULLSCREEN)\r\npygame.display.set_caption(\'Esquivador\')\r\npygame.mouse.set_visible(False)\r\n\r\n# establece los fonts\r\nfont = pygame.font.SysFont(None, 48)\r\n\r\n# establece los sonidos\r\ngameOverSound = pygame.mixer.Sound(\'juegoterminado.wav\')\r\npygame.mixer.music.load(\'m\u00FAsicaDeFondo.mid\')\r\n\r\n# establece las imagenes\r\nplayerImage = pygame.image.load(\'jugador.png\')\r\nrectanguloJugador = playerImage.get_rect()\r\nbaddieImage = pygame.image.load(\'villano.png\')\r\n\r\n# Muestra la pantalla inicial\r\ndibujarTexto(\'Evasor\', font, superficieVentana, (ANCHOVENTANA \/ 3)+40, (ALTOVENTANA \/ 3))\r\ndibujarTexto(\'Presione una tecla para comenzar.\', font, superficieVentana, (ANCHOVENTANA \/ 3) - 180, (ALTOVENTANA \/ 3) + 50)\r\npygame.display.update()\r\nesperarTeclaJugador()\r\n\r\n\r\npuntajeMax = 0\r\nwhile True:\r\n    # establece el comienzo del juego\r\n    villanos = []\r\n    puntaje = 0\r\n    rectanguloJugador.topleft = (ANCHOVENTANA \/ 2, ALTOVENTANA - 50)\r\n    moverIzquierda = moverDerecha = moverArriba = moverAbajo = False\r\n    trucoReversa = trucoLento = False\r\n    contadorAgregarVillano = 0\r\n    pygame.mixer.music.play(-1, 0.0)\r\n\r\n    while True: # el ciclo del juego se mantiene mientras se este jugando\r\n        puntaje += 1 # incrementa el puntaje\r\n\r\n        for evento in pygame.event.get():\r\n            if evento.type == QUIT:\r\n                terminar()\r\n\r\n            if evento.type == KEYDOWN:\r\n                if evento.key == ord(\'z\'):\r\n                    trucoReversa = True\r\n                if evento.key == ord(\'x\'):\r\n                    trucoLento = True\r\n                if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                    moverDerecha = False\r\n                    moverIzquierda = True\r\n                if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                    moverIzquierda = False\r\n                    moverDerecha = True\r\n                if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                    moverAbajo = False\r\n                    moverArriba = True\r\n                if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                    moverArriba = False\r\n                    moverAbajo = True\r\n\r\n            if evento.type == KEYUP:\r\n                if evento.key == ord(\'z\'):\r\n                    trucoReversa = False\r\n                    puntaje = 0\r\n                if evento.key == ord(\'x\'):\r\n                    trucoLento = False\r\n                    puntaje = 0\r\n                if evento.key == K_ESCAPE:\r\n                        terminar()\r\n\r\n                if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                    moverIzquierda = False\r\n                if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                    moverDerecha = False\r\n                if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                    moverArriba = False\r\n                if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                    moverAbajo = False\r\n\r\n            if evento.type == MOUSEMOTION:\r\n                # Si se mueve el rat\u00F3n, este se mueve adonde el cursor est\u00E9.\r\n                rectanguloJugador.move_ip(evento.pos[0] - rectanguloJugador.centerx, evento.pos[1] - rectanguloJugador.centery)\r\n\r\n        # A\u00F1ade villanos en la parte superior de la pantalla, de ser necesarios.\r\n        if not trucoReversa and not trucoLento:\r\n            contadorAgregarVillano += 1\r\n        if contadorAgregarVillano == TASANUEVOVILLANO:\r\n            contadorAgregarVillano = 0\r\n            baddieSize = random.randint(TAMA\u00D1OMINVILLANO, TAMA\u00D1OMAXVILLANO)\r\n            newBaddie = {\'rect\': pygame.Rect(random.randint(0, ANCHOVENTANA-baddieSize), 0 - baddieSize, baddieSize, baddieSize),\r\n                        \'speed\': random.randint(VELOCIDADMINVILLANO, VELOCIDADMAXVILLANO),\r\n                        \'surface\':pygame.transform.scale(baddieImage, (baddieSize, baddieSize)),\r\n                        }\r\n\r\n            villanos.append(newBaddie)\r\n\r\n        # Mueve el jugador.\r\n        if moverIzquierda and rectanguloJugador.left > 0:\r\n            rectanguloJugador.move_ip(-1 * TASAMOVIMIENTOJUGADOR, 0)\r\n        if moverDerecha and rectanguloJugador.right < ANCHOVENTANA:\r\n            rectanguloJugador.move_ip(TASAMOVIMIENTOJUGADOR, 0)\r\n        if moverArriba and rectanguloJugador.top > 0:\r\n            rectanguloJugador.move_ip(0, -1 * TASAMOVIMIENTOJUGADOR)\r\n        if moverAbajo and rectanguloJugador.bottom < ALTOVENTANA:\r\n            rectanguloJugador.move_ip(0, TASAMOVIMIENTOJUGADOR)\r\n\r\n        # Mueve el cursor del rat\u00F3n hacia el jugador.\r\n        pygame.mouse.set_pos(rectanguloJugador.centerx, rectanguloJugador.centery)\r\n\r\n        # Mueve los villanos hacia abajo.\r\n        for b in villanos:\r\n            if not trucoReversa and not trucoLento:\r\n                b[\'rect\'].move_ip(0, b[\'speed\'])\r\n            elif trucoReversa:\r\n                b[\'rect\'].move_ip(0, -5)\r\n            elif trucoLento:\r\n                b[\'rect\'].move_ip(0, 1)\r\n\r\n        # Elimina los villanos que han caido por debajo.\r\n        for b in villanos[:]:\r\n            if b[\'rect\'].top > ALTOVENTANA:\r\n                villanos.remove(b)\r\n\r\n        # Dibuja el mundo del juego en la ventana.\r\n        superficieVentana.fill(COLORFONDO)\r\n\r\n        # Dibuja el puntaje y el puntaje m\u00E1ximo\r\n        dibujarTexto(\'Puntaje: %s\' % (puntaje), font, superficieVentana, 10, 0)\r\n        dibujarTexto(\'Puntaje M\u00E1ximo: %s\' % (puntajeMax), font, superficieVentana, 10, 40)\r\n\r\n        # Dibuja el rect\u00E1ngulo del jugador\r\n        superficieVentana.blit(playerImage, rectanguloJugador)\r\n\r\n        # Dibuja cada villano\r\n        for b in villanos:\r\n            superficieVentana.blit(b[\'surface\'], b[\'rect\'])\r\n\r\n        pygame.display.update()\r\n\r\n        # Verifica si alg\u00FAn villano impact\u00F3 en el jugador.\r\n        if jugadorGolpeaVillano(rectanguloJugador, villanos):\r\n            if puntaje > puntajeMax:\r\n                puntajeMax = puntaje # Establece nuevo puntaje m\u00E1ximo\r\n            break\r\n\r\n        relojPrincipal.tick(FPS)\r\n\r\n    # Frena el juego y muestra \"Juego Terminado\"\r\n    pygame.mixer.music.stop()\r\n    gameOverSound.play()\r\n\r\n    dibujarTexto(\'Juego Terminado\', font, superficieVentana, (ANCHOVENTANA \/ 3)-40, (ALTOVENTANA \/ 3))\r\n    dibujarTexto(\'Presione una tecla para repetir.\', font, superficieVentana, (ANCHOVENTANA \/ 3) - 150, (ALTOVENTANA \/ 3) + 50)\r\n    pygame.display.update()\r\n    esperarTeclaJugador()\r\n\r\n    gameOverSound.stop()\r\n",
    "evasor":"import pygame, random, sys\r\nfrom pygame.locals import *\r\n\r\nANCHOVENTANA = 600\r\nALTOVENTANA = 600\r\nCOLORVENTANA = (255, 255, 255)\r\nCOLORFONDO = (0, 0, 0)\r\nFPS = 40\r\nTAMA\u00D1OMINVILLANO = 10\r\nTAMA\u00D1OMAXVILLANO = 40\r\nVELOCIDADMINVILLANO = 1\r\nVELOCIDADMAXVILLANO = 8\r\nTASANUEVOVILLANO = 6\r\nTASAMOVIMIENTOJUGADOR = 5\r\n\r\ndef terminar():\r\n    pygame.quit()\r\n    sys.exit()\r\n\r\ndef esperarTeclaJugador():\r\n    while True:\r\n        for evento in pygame.event.get():\r\n            if evento.type == QUIT:\r\n                terminar()\r\n            if evento.type == KEYDOWN:\r\n                if evento.key == K_ESCAPE: # Quita al presionar ESCAPE\r\n                    terminar()\r\n                return\r\n\r\ndef jugadorGolpeaVillano(rectanguloJugador, villanos):\r\n    for v in villanos:\r\n        if rectanguloJugador.colliderect(v[\'rect\']):\r\n            return True\r\n    return False\r\n\r\ndef dibujarTexto(texto, font, superficie, x, y):\r\n    objetotexto = font.render(texto, 1, COLORVENTANA)\r\n    rectangulotexto = objetotexto.get_rect()\r\n    rectangulotexto.topleft = (x, y)\r\n    superficie.blit(objetotexto, rectangulotexto)\r\n\r\n# establece un pygame, la ventana y el cursor del rat\u00F3n\r\npygame.init()\r\nrelojPrincipal = pygame.time.Clock()\r\nsuperficieVentana = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA))\r\npygame.display.set_caption(\'Esquivador\')\r\npygame.mouse.set_visible(False)\r\n\r\n# establece los fonts\r\nfont = pygame.font.SysFont(None, 48)\r\n\r\n# establece los sonidos\r\ngameOverSound = pygame.mixer.Sound(\'juegoterminado.wav\')\r\npygame.mixer.music.load(\'m\u00FAsicaDeFondo.mid\')\r\n\r\n# establece las imagenes\r\nplayerImage = pygame.image.load(\'jugador.png\')\r\nrectanguloJugador = playerImage.get_rect()\r\nbaddieImage = pygame.image.load(\'villano.png\')\r\n\r\n# Muestra la pantalla inicial\r\ndibujarTexto(\'Evasor\', font, superficieVentana, (ANCHOVENTANA \/ 3)+40, (ALTOVENTANA \/ 3))\r\ndibujarTexto(\'Presione una tecla para comenzar.\', font, superficieVentana, (ANCHOVENTANA \/ 3) - 180, (ALTOVENTANA \/ 3) + 50)\r\npygame.display.update()\r\nesperarTeclaJugador()\r\n\r\n\r\npuntajeMax = 0\r\nwhile True:\r\n    # establece el comienzo del juego\r\n    villanos = []\r\n    puntaje = 0\r\n    rectanguloJugador.topleft = (ANCHOVENTANA \/ 2, ALTOVENTANA - 50)\r\n    moverIzquierda = moverDerecha = moverArriba = moverAbajo = False\r\n    trucoReversa = trucoLento = False\r\n    contadorAgregarVillano = 0\r\n    pygame.mixer.music.play(-1, 0.0)\r\n\r\n    while True: # el ciclo del juego se mantiene mientras se este jugando\r\n        puntaje += 1 # incrementa el puntaje\r\n\r\n        for evento in pygame.event.get():\r\n            if evento.type == QUIT:\r\n                terminar()\r\n\r\n            if evento.type == KEYDOWN:\r\n                if evento.key == ord(\'z\'):\r\n                    trucoReversa = True\r\n                if evento.key == ord(\'x\'):\r\n                    trucoLento = True\r\n                if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                    moverDerecha = False\r\n                    moverIzquierda = True\r\n                if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                    moverIzquierda = False\r\n                    moverDerecha = True\r\n                if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                    moverAbajo = False\r\n                    moverArriba = True\r\n                if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                    moverArriba = False\r\n                    moverAbajo = True\r\n\r\n            if evento.type == KEYUP:\r\n                if evento.key == ord(\'z\'):\r\n                    trucoReversa = False\r\n                    puntaje = 0\r\n                if evento.key == ord(\'x\'):\r\n                    trucoLento = False\r\n                    puntaje = 0\r\n                if evento.key == K_ESCAPE:\r\n                        terminar()\r\n\r\n                if evento.key == K_LEFT or evento.key == ord(\'a\'):\r\n                    moverIzquierda = False\r\n                if evento.key == K_RIGHT or evento.key == ord(\'d\'):\r\n                    moverDerecha = False\r\n                if evento.key == K_UP or evento.key == ord(\'w\'):\r\n                    moverArriba = False\r\n                if evento.key == K_DOWN or evento.key == ord(\'s\'):\r\n                    moverAbajo = False\r\n\r\n            if evento.type == MOUSEMOTION:\r\n                # Si se mueve el rat\u00F3n, este se mueve adonde el cursor est\u00E9.\r\n                rectanguloJugador.move_ip(evento.pos[0] - rectanguloJugador.centerx, evento.pos[1] - rectanguloJugador.centery)\r\n\r\n        # A\u00F1ade villanos en la parte superior de la pantalla, de ser necesarios.\r\n        if not trucoReversa and not trucoLento:\r\n            contadorAgregarVillano += 1\r\n        if contadorAgregarVillano == TASANUEVOVILLANO:\r\n            contadorAgregarVillano = 0\r\n            baddieSize = random.randint(TAMA\u00D1OMINVILLANO, TAMA\u00D1OMAXVILLANO)\r\n            newBaddie = {\'rect\': pygame.Rect(random.randint(0, ANCHOVENTANA-baddieSize), 0 - baddieSize, baddieSize, baddieSize),\r\n                        \'speed\': random.randint(VELOCIDADMINVILLANO, VELOCIDADMAXVILLANO),\r\n                        \'surface\':pygame.transform.scale(baddieImage, (baddieSize, baddieSize)),\r\n                        }\r\n\r\n            villanos.append(newBaddie)\r\n\r\n        # Mueve el jugador.\r\n        if moverIzquierda and rectanguloJugador.left > 0:\r\n            rectanguloJugador.move_ip(-1 * TASAMOVIMIENTOJUGADOR, 0)\r\n        if moverDerecha and rectanguloJugador.right < ANCHOVENTANA:\r\n            rectanguloJugador.move_ip(TASAMOVIMIENTOJUGADOR, 0)\r\n        if moverArriba and rectanguloJugador.top > 0:\r\n            rectanguloJugador.move_ip(0, -1 * TASAMOVIMIENTOJUGADOR)\r\n        if moverAbajo and rectanguloJugador.bottom < ALTOVENTANA:\r\n            rectanguloJugador.move_ip(0, TASAMOVIMIENTOJUGADOR)\r\n\r\n        # Mueve el cursor del rat\u00F3n hacia el jugador.\r\n        pygame.mouse.set_pos(rectanguloJugador.centerx, rectanguloJugador.centery)\r\n\r\n        # Mueve los villanos hacia abajo.\r\n        for b in villanos:\r\n            if not trucoReversa and not trucoLento:\r\n                b[\'rect\'].move_ip(0, b[\'speed\'])\r\n            elif trucoReversa:\r\n                b[\'rect\'].move_ip(0, -5)\r\n            elif trucoLento:\r\n                b[\'rect\'].move_ip(0, 1)\r\n\r\n        # Elimina los villanos que han caido por debajo.\r\n        for b in villanos[:]:\r\n            if b[\'rect\'].top > ALTOVENTANA:\r\n                villanos.remove(b)\r\n\r\n        # Dibuja el mundo del juego en la ventana.\r\n        superficieVentana.fill(COLORFONDO)\r\n\r\n        # Dibuja el puntaje y el puntaje m\u00E1ximo\r\n        dibujarTexto(\'Puntaje: %s\' % (puntaje), font, superficieVentana, 10, 0)\r\n        dibujarTexto(\'Puntaje M\u00E1ximo: %s\' % (puntajeMax), font, superficieVentana, 10, 40)\r\n\r\n        # Dibuja el rect\u00E1ngulo del jugador\r\n        superficieVentana.blit(playerImage, rectanguloJugador)\r\n\r\n        # Dibuja cada villano\r\n        for b in villanos:\r\n            superficieVentana.blit(b[\'surface\'], b[\'rect\'])\r\n\r\n        pygame.display.update()\r\n\r\n        # Verifica si alg\u00FAn villano impact\u00F3 en el jugador.\r\n        if jugadorGolpeaVillano(rectanguloJugador, villanos):\r\n            if puntaje > puntajeMax:\r\n                puntajeMax = puntaje # Establece nuevo puntaje m\u00E1ximo\r\n            break\r\n\r\n        relojPrincipal.tick(FPS)\r\n\r\n    # Frena el juego y muestra \"Juego Terminado\"\r\n    pygame.mixer.music.stop()\r\n    gameOverSound.play()\r\n\r\n    dibujarTexto(\'Juego Terminado\', font, superficieVentana, (ANCHOVENTANA \/ 3)-40, (ALTOVENTANA \/ 3))\r\n    dibujarTexto(\'Presione una tecla para repetir.\', font, superficieVentana, (ANCHOVENTANA \/ 3) - 150, (ALTOVENTANA \/ 3) + 50)\r\n    pygame.display.update()\r\n    esperarTeclaJugador()\r\n\r\n    gameOverSound.stop()\r\n",
    "dragn":"import random\r\nimport time\r\n\r\ndef mostrarIntroducci\u00F3n():\r\n    print(\'Est\u00E1s en una tierra llena de dragones. Frente a t\u00ED\')\r\n    print(\'hay dos cuevas. En una de ellas, el drag\u00F3n es generoso y\')\r\n    print(\'amigable y compartir\u00E1 su tesoro contigo. El otro drag\u00F3n\')\r\n    print(\'es codicioso y est\u00E1 hambriento, y te devorar\u00E1 inmediatamente.\')\r\n    print()\r\n\r\ndef elegirCueva():\r\n    cueva = \'\'\r\n    while cueva != \'1\' and cueva != \'2\':\r\n        print(\'\u00BFA qu\u00E9 cueva quieres entrar? (1 \u00F3 2)\')\r\n        cueva = input()\r\n\r\n    return cueva\r\n\r\ndef explorarCueva(cuevaElegida):\r\n    print(\'Te aproximas a la cueva...\')\r\n    time.sleep(2)\r\n    print(\'Es oscura y espeluznante...\')\r\n    time.sleep(2)\r\n    print(\'\u00A1Un gran dragon aparece s\u00FAbitamente frente a t\u00ED! Abre sus fauces y...\')\r\n    print()\r\n    time.sleep(2)\r\n\r\n    cuevaAmigable = random.randint(1, 2)\r\n\r\n    if cuevaElegida == str(cuevaAmigable):\r\n         print(\'\u00A1Te regala su tesoro!\')\r\n    else:\r\n         print(\'\u00A1Te engulle de un bocado!\')\r\n\r\njugarDeNuevo = \'s\u00ED\'\r\nwhile jugarDeNuevo == \'s\u00ED\' or jugarDeNuevo == \'s\':\r\n\r\n    mostrarIntroducci\u00F3n()\r\n\r\n    n\u00FAmeroDeCueva = elegirCueva()\r\n\r\n    explorarCueva(n\u00FAmeroDeCueva)\r\n\r\n    print(\'\u00BFQuieres jugar de nuevo? (s\u00ED o no)\')\r\n    jugarDeNuevo = input()\r\n",
    "deteccionColision":"import pygame, sys, random\r\nfrom pygame.locals import *\r\n\r\ndef hacerSuperposicionRects(rect1, rect2):\r\n    for a, b in [(rect1, rect2), (rect2, rect1)]:\r\n        # Verifica si las esquinas de a se encuentran dentro de b\r\n        if ((puntoDentroDeRect(a.left, a.top, b)) or\r\n            (puntoDentroDeRect(a.left, a.bottom, b)) or\r\n            (puntoDentroDeRect(a.right, a.top, b)) or\r\n            (puntoDentroDeRect(a.right, a.bottom, b))):\r\n            return True\r\n\r\n    return False\r\n\r\ndef puntoDentroDeRect(x, y, rect):\r\n    if (x > rect.left) and (x < rect.right) and (y > rect.top) and (y < rect.bottom):\r\n        return True\r\n    else:\r\n        return False\r\n\r\n\r\n# establece el juego\r\npygame.init()\r\nrelojPrincipal = pygame.time.Clock()\r\n\r\n# establece la ventana\r\nANCHOVENTANA = 400\r\nALTOVENTANA = 400\r\nsuperficieVentana = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), 0, 32)\r\npygame.display.set_caption(\'Deteccion de Colisiones\')\r\n\r\n# establece las variables de direccion\r\nABAJOIZQUIERDA = 1\r\nABAJODERECHA = 3\r\nARRIBAIZQUIERDA = 7\r\nARRIBADERECHA = 9\r\n\r\nVELOCIDADMOVIMIENTO = 4\r\n\r\n# establece los colores\r\nNEGRO = (0, 0, 0)\r\nVERDE = (0, 255, 0)\r\nBLANCO = (255, 255, 255)\r\n\r\n# establece las estructuras de datos de comida y rebotin\r\ncontadorComida = 0\r\nNUEVACOMIDA = 40\r\nTAMANOCOMIDA = 20\r\nrebotin = {\'rect\':pygame.Rect(300, 100, 50, 50), \'dir\':ARRIBAIZQUIERDA}\r\nCOMIDAS = []\r\nfor i in range(20):\r\n    COMIDAS.append(pygame.Rect(random.randint(0, ANCHOVENTANA - TAMANOCOMIDA), random.randint(0, ALTOVENTANA - TAMANOCOMIDA), TAMANOCOMIDA, TAMANOCOMIDA))\r\n\r\n# corre el ciclo de juego\r\nwhile True:\r\n    # busca un evento QUIT\r\n    for evento in pygame.event.get():\r\n        if evento.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n\r\n    contadorComida += 1\r\n    if contadorComida >= NUEVACOMIDA:\r\n        # a\u00F1ade nueva comida\r\n        contadorComida = 0\r\n        COMIDAS.append(pygame.Rect(random.randint(0, ANCHOVENTANA - TAMANOCOMIDA), random.randint(0, ALTOVENTANA - TAMANOCOMIDA), TAMANOCOMIDA, TAMANOCOMIDA))\r\n\r\n    # Dibuja el fondo NEGRO sobre la superficie\r\n    superficieVentana.fill(NEGRO)\r\n\r\n    # Mueve la estructura de datos rebotin\r\n    if rebotin[\'dir\'] == ABAJOIZQUIERDA:\r\n        rebotin[\'rect\'].left -= VELOCIDADMOVIMIENTO\r\n        rebotin[\'rect\'].top += VELOCIDADMOVIMIENTO\r\n    if rebotin[\'dir\'] == ABAJODERECHA:\r\n        rebotin[\'rect\'].left += VELOCIDADMOVIMIENTO\r\n        rebotin[\'rect\'].top += VELOCIDADMOVIMIENTO\r\n    if rebotin[\'dir\'] == ARRIBAIZQUIERDA:\r\n        rebotin[\'rect\'].left -= VELOCIDADMOVIMIENTO\r\n        rebotin[\'rect\'].top -= VELOCIDADMOVIMIENTO\r\n    if rebotin[\'dir\'] == ARRIBADERECHA:\r\n        rebotin[\'rect\'].left += VELOCIDADMOVIMIENTO\r\n        rebotin[\'rect\'].top -= VELOCIDADMOVIMIENTO\r\n\r\n    # Verifica si rebotin se movio fuera de la ventana\r\n    if rebotin[\'rect\'].top < 0:\r\n        # rebotin se movio por arriba de la ventana\r\n        if rebotin[\'dir\'] == ARRIBAIZQUIERDA:\r\n            rebotin[\'dir\'] = ABAJOIZQUIERDA\r\n        if rebotin[\'dir\'] == ARRIBADERECHA:\r\n            rebotin[\'dir\'] = ABAJODERECHA\r\n    if rebotin[\'rect\'].bottom > ALTOVENTANA:\r\n        # rebotin se movio por debajo de la ventana\r\n        if rebotin[\'dir\'] == ABAJOIZQUIERDA:\r\n            rebotin[\'dir\'] = ARRIBAIZQUIERDA\r\n        if rebotin[\'dir\'] == ABAJODERECHA:\r\n            rebotin[\'dir\'] = ARRIBADERECHA\r\n    if rebotin[\'rect\'].left < 0:\r\n        # rebotin se movio por la izquierda de la ventana\r\n        if rebotin[\'dir\'] == ABAJOIZQUIERDA:\r\n            rebotin[\'dir\'] = ABAJODERECHA\r\n        if rebotin[\'dir\'] == ARRIBAIZQUIERDA:\r\n            rebotin[\'dir\'] = ARRIBADERECHA\r\n    if rebotin[\'rect\'].right > ANCHOVENTANA:\r\n        # rebotin se movio por la derecha de la ventana\r\n        if rebotin[\'dir\'] == ABAJODERECHA:\r\n            rebotin[\'dir\'] = ABAJOIZQUIERDA\r\n        if rebotin[\'dir\'] == ARRIBADERECHA:\r\n            rebotin[\'dir\'] = ARRIBAIZQUIERDA\r\n\r\n    # Dibuja a rebotin en la superficie\r\n    pygame.draw.rect(superficieVentana, BLANCO, rebotin[\'rect\'])\r\n\r\n    # Verifica si rebotin intersecto algun cuadrado de comida\r\n    for comida in COMIDAS[:]:\r\n        if hacerSuperposicionRects(rebotin[\'rect\'], comida):\r\n            COMIDAS.remove(comida)\r\n\r\n    # Dibuja la comida\r\n    for i in range(len(COMIDAS)):\r\n        pygame.draw.rect(superficieVentana, VERDE, COMIDAS[i])\r\n\r\n    # Dibuja la ventana en la pantalla\r\n    pygame.display.update()\r\n    relojPrincipal.tick(40)\r\n",
    "cifrado":"# Cifrado Cesar\r\n\r\nTAM_MAX_CLAVE = 26\r\n\r\ndef obtenerModo():\r\n    while True:\r\n        print(\'Deseas encriptar o desencriptar un mensaje?\')\r\n        modo = input().lower()\r\n        if modo in \'encriptar e desencriptar d\'.split():\r\n            return modo\r\n        else:\r\n            print(\'Ingrese \"encriptar\" o \"e\" o \"desencriptar\" o \"d\"\')\r\n\r\ndef obtenerMensaje():\r\n    print(\'Ingrese su mensaje:\')\r\n    return input()\r\n\r\ndef obtenerClave():\r\n    clave = 0\r\n    while True:\r\n        print(\'Ingrese el n\u00FAmero de clave (1-%s)\' % (TAM_MAX_CLAVE))\r\n        clave = int(input())\r\n        if (clave >= 1 and clave <= TAM_MAX_CLAVE):\r\n            return clave\r\n\r\ndef obtenerMensajeTraducido(modo, mensaje, clave):\r\n    if modo[0] == \'d\':\r\n        clave = -clave\r\n    traduccion = \'\'\r\n\r\n    for letra in mensaje:\r\n        if letra.isalpha():\r\n            num = ord(letra)\r\n            num += clave\r\n\r\n            if letra.isupper():\r\n                if num > ord(\'Z\'):\r\n                    num -= 26\r\n                elif num < ord(\'A\'):\r\n                    num += 26\r\n            elif letra.islower():\r\n                if num > ord(\'z\'):\r\n                    num -= 26\r\n                elif num < ord(\'a\'):\r\n                    num += 26\r\n\r\n            traduccion += chr(num)\r\n        else:\r\n            traduccion += letra\r\n    return traduccion\r\n\r\nmodo = obtenerModo()\r\nmensaje = obtenerMensaje()\r\nclave = obtenerClave()\r\n\r\nprint(\'Tu texto traducido es:\')\r\nprint(obtenerMensajeTraducido(modo, mensaje, clave))\r\n",
    "chistes":"print(\'\u00BFQu\u00E9 sale de la cruza entre un mono y un pato?\')\r\ninput()\r\nprint(\'\u00A1Un monopat\u00EDn!\')\r\nprint()\r\nprint(\'\u00BFPorqu\u00E9 vuelan los p\u00E1jaros pa\\\'l sur?\')\r\ninput()\r\nprint(\'\u00A1Porque caminando tardar\u00EDan much\u00EDsimo!\')\r\nprint()\r\nprint(\'\u00BFEn qu\u00E9 se parecen una familia, un bombero y un barco?\')\r\ninput()\r\nprint(\"No s\u00E9... \u00BFen qu\u00E9 se parecen?\")\r\ninput()\r\nprint(\'En que el bombero y el barco tienen casco.\')\r\ninput()\r\nprint(\'\u00BFY la familia?\', end=\'\')\r\nprint(\' -Bien, gracias.\')\r\n",
    "bugs":"import random\r\nnumero1 = random.randint(1, 10)\r\nnumero2 = random.randint(1, 10)\r\nprint(\'\u00BFCu\u00E1nto es \' + str(numero1) + \' + \' + str(numero2) + \'?\')\r\nrespuesta = input()\r\nif respuesta == numero1 + numero2:\r\n    print(\'\u00A1Correcto!\')\r\nelse:\r\n    print(\'\u00A1Nops! La respuesta es \' + str(numero1 + numero2))\r\n",
    "animacion":"import pygame, sys, time\r\nfrom pygame.locals import *\r\n\r\n# Establece pygame\r\npygame.init()\r\n\r\n# Establece la ventana\r\nANCHOVENTANA = 400\r\nALTOVENTANA = 400\r\nwindowSurface = pygame.display.set_mode((ANCHOVENTANA, ALTOVENTANA), 0, 32)\r\npygame.display.set_caption(\'Animaci\u00F3n\')\r\n\r\n# Establece las variables de direcci\u00F3n\r\nABAJOIZQUIERDA = 1\r\nABAJODERECHA = 3\r\nARRIBAIZQUIERDA = 7\r\nARRIBADERECHA = 9\r\n\r\nVELOCIDADMOVIMIENTO = 4\r\n\r\n# Establece los colores\r\nNEGRO = (0, 0, 0)\r\nROJO = (255, 0, 0)\r\nVERDE = (0, 255, 0)\r\nAZUL = (0, 0, 255)\r\n\r\n# Establece la estructura de datos de los bloques.\r\nb1 = {\'rect\':pygame.Rect(300, 80, 50, 100), \'color\':ROJO, \'dir\':ARRIBADERECHA}\r\nb2 = {\'rect\':pygame.Rect(200, 200, 20, 20), \'color\':VERDE, \'dir\':ARRIBAIZQUIERDA}\r\nb3 = {\'rect\':pygame.Rect(100, 150, 60, 60), \'color\':AZUL, \'dir\':ABAJOIZQUIERDA}\r\nbloques = [b1, b2, b3]\r\n\r\n# Corre el ciclo de juego\r\nwhile True:\r\n    # Busca un evento QUIT.\r\n    for evento in pygame.event.get():\r\n        if evento.type == QUIT:\r\n            pygame.quit()\r\n            sys.exit()\r\n\r\n    # Dibuja el fondo negro sobre la superficie\r\n    windowSurface.fill(NEGRO)\r\n\r\n    for b in bloques:\r\n        # mueve la estructura de datos de bloques\r\n        if b[\'dir\'] == ABAJOIZQUIERDA:\r\n            b[\'rect\'].left -= VELOCIDADMOVIMIENTO\r\n            b[\'rect\'].top += VELOCIDADMOVIMIENTO\r\n        if b[\'dir\'] == ABAJODERECHA:\r\n            b[\'rect\'].left += VELOCIDADMOVIMIENTO\r\n            b[\'rect\'].top += VELOCIDADMOVIMIENTO\r\n        if b[\'dir\'] == ARRIBAIZQUIERDA:\r\n            b[\'rect\'].left -= VELOCIDADMOVIMIENTO\r\n            b[\'rect\'].top -= VELOCIDADMOVIMIENTO\r\n        if b[\'dir\'] == ARRIBADERECHA:\r\n            b[\'rect\'].left += VELOCIDADMOVIMIENTO\r\n            b[\'rect\'].top -= VELOCIDADMOVIMIENTO\r\n\r\n        # Verifica si el bloque se movio fuera de la ventana\r\n        if b[\'rect\'].top < 0:\r\n            # el bloque se movio por arriba de la ventana\r\n            if b[\'dir\'] == ARRIBAIZQUIERDA:\r\n                b[\'dir\'] = ABAJOIZQUIERDA\r\n            if b[\'dir\'] == ARRIBADERECHA:\r\n                b[\'dir\'] = ABAJODERECHA\r\n        if b[\'rect\'].bottom > ALTOVENTANA:\r\n            # el bloque se movio por debajo de la ventana\r\n            if b[\'dir\'] == ABAJOIZQUIERDA:\r\n                b[\'dir\'] = ARRIBAIZQUIERDA\r\n            if b[\'dir\'] == ABAJODERECHA:\r\n                b[\'dir\'] = ARRIBADERECHA\r\n        if b[\'rect\'].left < 0:\r\n            # el bloque se movio por la izquierda de la ventana\r\n            if b[\'dir\'] == ABAJOIZQUIERDA:\r\n                b[\'dir\'] = ABAJODERECHA\r\n            if b[\'dir\'] == ARRIBAIZQUIERDA:\r\n                b[\'dir\'] = ARRIBADERECHA\r\n        if b[\'rect\'].right > ANCHOVENTANA:\r\n            # el bloque se movio por la derecha de la ventana\r\n            if b[\'dir\'] == ABAJODERECHA:\r\n                b[\'dir\'] = ABAJOIZQUIERDA\r\n            if b[\'dir\'] == ARRIBADERECHA:\r\n                b[\'dir\'] = ARRIBAIZQUIERDA\r\n\r\n        # Dibuja el bloque en la superficie\r\n        pygame.draw.rect(windowSurface, b[\'color\'], b[\'rect\'])\r\n\r\n    # Dibuja la ventana en la pantalla\r\n    pygame.display.update()\r\n    time.sleep(0.02)\r\n",
    "AISim1":"# Reversi\r\n\r\nimport random\r\nimport sys\r\n\r\ndef dibujarTablero(tablero):\r\n    # Esta funcion dibuja el tablero pasado. Devuelve None\r\n    LINEAH = \'  +---+---+---+---+---+---+---+---+\'\r\n    LINEAV = \'  |   |   |   |   |   |   |   |   |\'\r\n\r\n    print(\'    1   2   3   4   5   6   7   8\')\r\n    print(LINEAH)\r\n    for y in range(8):\r\n        print(LINEAV)\r\n        print(y+1, end=\' \')\r\n        for x in range(8):\r\n            print(\'| %s\' % (tablero[x][y]), end=\' \')\r\n        print(\'|\')\r\n        print(LINEAV)\r\n        print(LINEAH)\r\n\r\n\r\ndef blanquearTablero(tablero):\r\n    # Blanquea el tablero pasado, excepto la posicion original.\r\n    for x in range(8):\r\n        for y in range(8):\r\n            tablero[x][y] = \' \'\r\n\r\n    # Piezas que comienzan:\r\n    tablero[3][3] = \'X\'\r\n    tablero[3][4] = \'O\'\r\n    tablero[4][3] = \'O\'\r\n    tablero[4][4] = \'X\'\r\n\r\n\r\ndef obtenerNuevoTablero():\r\n    # Crea un tablero nuevo, blanqueado.\r\n    tablero = []\r\n    for i in range(8):\r\n        tablero.append([\' \'] * 8)\r\n\r\n    return tablero\r\n\r\n\r\ndef esJugadaValida(tablero, baldosa, comienzox, comienzoy):\r\n    # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida\r\n    # Si es una jugada v\u00E1lida, devuelve una lista de espacios al que el jugador se podr\u00EDa mover.\r\n    if tablero[comienzox][comienzoy] != \' \' or not estaEnTablero(comienzox, comienzoy):\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa # establece temporalmente la baldosa en el tablero.\r\n\r\n    if baldosa == \'X\':\r\n        otraBaldosa = \'O\'\r\n    else:\r\n        otraBaldosa = \'X\'\r\n\r\n    baldosasAGirar = []\r\n    for direccionx, direcciony in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = comienzox, comienzoy\r\n        x += direccionx # primer paso en la direcci\u00F3n\r\n        y += direcciony # primer paso en la direcci\u00F3n\r\n        if estaEnTablero(x, y) and tablero[x][y] == otraBaldosa:\r\n            # Hay una piza perteneciente al otro jugador al lado de nustra pieza\r\n            x += direccionx\r\n            y += direcciony\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            while tablero[x][y] == otraBaldosa:\r\n                x += direccionx\r\n                y += direcciony\r\n                if not estaEnTablero(x, y): # rompe el ciclo while y continua en el ciclo for.\r\n                    break\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            if tablero[x][y] == baldosa:\r\n                # Hay piezas a girar. Ve en aquella direcci\u00F3n hasta que lleguemos al espacio original, observando todas las baldosas.\r\n                while True:\r\n                    x -= direccionx\r\n                    y -= direcciony\r\n                    if x == comienzox and y == comienzoy:\r\n                        break\r\n                    baldosasAGirar.append([x, y])\r\n\r\n    tablero[comienzox][comienzoy] = \' \' # Restaura el espacio vacio.\r\n    if len(baldosasAGirar) == 0: # Si ninguna baldosa fue girada, no fue una jugada v\u00E1lida.\r\n        return False\r\n    return baldosasAGirar\r\n\r\n\r\ndef estaEnTablero(x, y):\r\n    # Devuelve True si las coordenadas se encuentran dentro del tablero\r\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\r\n\r\n\r\ndef obtenerTableroConJugadasValidas(tablero, baldosa):\r\n    # Devuelve un nuevo tablero, marcando las jugadas v\u00E1lidas que el jugador puede realizar.\r\n    dupTablero = obtenerCopiaTablero(tablero)\r\n\r\n    for x, y in obtenerJugadasValidas(dupTablero, baldosa):\r\n        dupTablero[x][y] = \'.\'\r\n    return dupTablero\r\n\r\n\r\ndef obtenerJugadasValidas(tablero, baldosa):\r\n    # Devuelve una lista de [x,y] listas de jugadas v\u00E1lidas para el jugador en el tablero dado.\r\n    jugadasValidas = []\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if esJugadaValida(tablero, baldosa, x, y) != False:\r\n                jugadasValidas.append([x, y])\r\n    return jugadasValidas\r\n\r\n\r\ndef obtenerPuntajeTablero(tablero):\r\n    # Determina el puntaje contando las baldosas. Devuelve un diccionario con las claves \'X\' y \'O\'.\r\n    puntajex = 0\r\n    puntajeo = 0\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if tablero[x][y] == \'X\':\r\n                puntajex += 1\r\n            if tablero[x][y] == \'O\':\r\n                puntajeo += 1\r\n    return {\'X\':puntajex, \'O\':puntajeo}\r\n\r\n\r\ndef ingresarBalsodaJugador():\r\n    # Permite al jugador elegir que baldosa desea ser.\r\n    # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.\r\n    baldosa = \'\'\r\n    while not (baldosa == \'X\' or baldosa == \'O\'):\r\n        print(\'\u00BFDeseas ser X u O?\')\r\n        baldosa = input().upper()\r\n\r\n    #  El primer elemento en la lista es la baldosa del juegador, la segunda la de la computadora.\r\n    if baldosa == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\n\r\ndef quienComienza():\r\n    # Elije al azar que jugador comienza.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computadora\'\r\n    else:\r\n        return \'jugador\'\r\n\r\n\r\ndef volverAJugar():\r\n    # Esta funcion devuelve True si el jugador desea volver a jugar, de lo contrario False.\r\n    print(\'\u00BFDeseas volver a jugar? (si o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\ndef hacerJugada(tablero, baldosa, comienzox, comienzoy):\r\n    # Posiciona la baldosa en el tablero en comienzox, comienzoy y gira cualquiera de las pizas del oponente.\r\n    # Returns False if this is an invalid jugada, True if it is valid.\r\n    baldosasAGirar = esJugadaValida(tablero, baldosa, comienzox, comienzoy)\r\n\r\n    if baldosasAGirar == False:\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa\r\n    for x, y in baldosasAGirar:\r\n        tablero[x][y] = baldosa\r\n    return True\r\n\r\n\r\ndef obtenerCopiaTablero(tablero):\r\n    # Duplica la lista del tablero y devuelve el duplicado.\r\n    dupTablero = obtenerNuevoTablero()\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            dupTablero[x][y] = tablero[x][y]\r\n\r\n    return dupTablero\r\n\r\n\r\ndef esEsquina(x, y):\r\n    # Devuelve True si la posicion es una de las esquinas.\r\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\r\n\r\n\r\ndef obtenerJugadaJugador(tablero, baldosaJugador):\r\n    # Permite al jugador tipear su jugada.\r\n    # Revuelve una jugada como [x,y] (o devuelve las palabras \'pistas\' o \'quitar\')\r\n    DIGITOS1A8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Ingresa tu jugada, quitar para terminar el juego, o pistas para activar\/desactivar pistas.\')\r\n        jugada = input().lower()\r\n        if jugada == \'quitar\':\r\n            return \'quitar\'\r\n        if jugada == \'pistas\':\r\n            return \'pistas\'\r\n\r\n        if len(jugada) == 2 and jugada[0] in DIGITOS1A8 and jugada[1] in DIGITOS1A8:\r\n            x = int(jugada[0]) - 1\r\n            y = int(jugada[1]) - 1\r\n            if esJugadaValida(tablero, baldosaJugador, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'Esta no es una jugada v\u00E1lida. Presiona el digito x (1-8), luego el digoto y (1-8).\')\r\n            print(\'Por ejemplo, 81 ser\u00E1 la esquina superior derecha.\')\r\n\r\n    return [x, y]\r\n\r\n\r\ndef obtenerJugadaComputadora(tablero, baldosaComputadora):\r\n    # Dado un tablero y la bandosa de la computadora, determinar donde\r\n    # realizar la jugada y devuelve esa jugada como una lista [x,y].\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosaComputadora)\r\n\r\n    # ordena al azar el orden de las jugadas posibles\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # siempre elegir una esquina de estar disponible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    # Recorrer todas las jugadas posibles y elegir la de mejor puntaje.\r\n    puntajeMaximo = -1\r\n    for x, y in jugadasPosibles:\r\n        dupTablero = obtenerCopiaTablero(tablero)\r\n        hacerJugada(dupTablero, baldosaComputadora, x, y)\r\n        puntaje = obtenerPuntajeTablero(dupTablero)[baldosaComputadora]\r\n        if puntaje > puntajeMaximo:\r\n            mejorJugada = [x, y]\r\n            puntajeMaximo = puntaje\r\n    return mejorJugada\r\n\r\n\r\ndef mostrarPuntajes(baldosaJugador, baldosaComputadora):\r\n    # Imprime en pantalla el mejor puntaje.\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'Tienes %s puntos. La computadora tiene %s puntos.\' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))\r\n\r\n\r\n\r\nprint(\'\u00A1Bienvenido a Reversi!\')\r\n\r\nwhile True:\r\n    # Resetea el tablero y el juego.\r\n    tableroPrincipal = obtenerNuevoTablero()\r\n    blanquearTablero(tableroPrincipal)\r\n    if quienComienza() == \'player\':\r\n        turno = \'X\'\r\n    else:\r\n         turno = \'O\'\r\n    print(\"La\" + turno + \' ir\u00E1 primero.\')\r\n\r\n    while True:\r\n         dibujarTablero(tableroPrincipal)\r\n         puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n         print(\'X tiene %s puntos. O tiene %s puntos\' % (puntajes[\'X\'], puntajes[\'O\']))\r\n         input(\'Presiona Enter para continuar.\')\r\n\r\n         if turno == \'X\':\r\n              # Turno de X.\r\n              otraBaldosa = \'O\'\r\n              x, y = obtenerJugadaComputadora(tableroPrincipal, \'X\')\r\n              hacerJugada(tableroPrincipal, \'X\', x, y)\r\n         else:\r\n              # Turno de O.\r\n              otraBaldosa = \'X\'\r\n              x, y = obtenerJugadaComputadora(tableroPrincipal, \'O\')\r\n              hacerJugada(tableroPrincipal, \'O\', x, y)\r\n\r\n         if obtenerJugadasValidas(tableroPrincipal, otraBaldosa) == []:\r\n              break\r\n         else:\r\n              turno = otraBaldosa\r\n\r\n    # Muestra el puntaje final.\r\n    dibujarTablero(tableroPrincipal)\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'X obtuvo %s puntos. O obtuvo %s puntos.\' % (puntajes[\'X\'], puntajes[\'O\']))\r\n\r\n    if not volverAJugar():\r\n         sys.exit()\r\n",
    "AISim2":"# Reversi\r\n\r\nimport random\r\nimport sys\r\n\r\ndef dibujarTablero(tablero):\r\n    # Esta funcion dibuja el tablero pasado. Devuelve None\r\n    LINEAH = \'  +---+---+---+---+---+---+---+---+\'\r\n    LINEAV = \'  |   |   |   |   |   |   |   |   |\'\r\n\r\n    print(\'    1   2   3   4   5   6   7   8\')\r\n    print(LINEAH)\r\n    for y in range(8):\r\n        print(LINEAV)\r\n        print(y+1, end=\' \')\r\n        for x in range(8):\r\n            print(\'| %s\' % (tablero[x][y]), end=\' \')\r\n        print(\'|\')\r\n        print(LINEAV)\r\n        print(LINEAH)\r\n\r\n\r\ndef blanquearTablero(tablero):\r\n    # Blanquea el tablero pasado, excepto la posicion original.\r\n    for x in range(8):\r\n        for y in range(8):\r\n            tablero[x][y] = \' \'\r\n\r\n    # Piezas que comienzan:\r\n    tablero[3][3] = \'X\'\r\n    tablero[3][4] = \'O\'\r\n    tablero[4][3] = \'O\'\r\n    tablero[4][4] = \'X\'\r\n\r\n\r\ndef obtenerNuevoTablero():\r\n    # Crea un tablero nuevo, blanqueado.\r\n    tablero = []\r\n    for i in range(8):\r\n        tablero.append([\' \'] * 8)\r\n\r\n    return tablero\r\n\r\n\r\ndef esJugadaValida(tablero, baldosa, comienzox, comienzoy):\r\n    # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida\r\n    # Si es una jugada v\u00E1lida, devuelve una lista de espacios al que el jugador se podr\u00EDa mover.\r\n    if tablero[comienzox][comienzoy] != \' \' or not estaEnTablero(comienzox, comienzoy):\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa # establece temporalmente la baldosa en el tablero.\r\n\r\n    if baldosa == \'X\':\r\n        otraBaldosa = \'O\'\r\n    else:\r\n        otraBaldosa = \'X\'\r\n\r\n    baldosasAGirar = []\r\n    for direccionx, direcciony in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = comienzox, comienzoy\r\n        x += direccionx # primer paso en la direcci\u00F3n\r\n        y += direcciony # primer paso en la direcci\u00F3n\r\n        if estaEnTablero(x, y) and tablero[x][y] == otraBaldosa:\r\n            # Hay una piza perteneciente al otro jugador al lado de nustra pieza\r\n            x += direccionx\r\n            y += direcciony\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            while tablero[x][y] == otraBaldosa:\r\n                x += direccionx\r\n                y += direcciony\r\n                if not estaEnTablero(x, y): # rompe el ciclo while y continua en el ciclo for.\r\n                    break\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            if tablero[x][y] == baldosa:\r\n                # Hay piezas a girar. Ve en aquella direcci\u00F3n hasta que lleguemos al espacio original, observando todas las baldosas.\r\n                while True:\r\n                    x -= direccionx\r\n                    y -= direcciony\r\n                    if x == comienzox and y == comienzoy:\r\n                        break\r\n                    baldosasAGirar.append([x, y])\r\n\r\n    tablero[comienzox][comienzoy] = \' \' # Restaura el espacio vacio.\r\n    if len(baldosasAGirar) == 0: # Si ninguna baldosa fue girada, no fue una jugada v\u00E1lida.\r\n        return False\r\n    return baldosasAGirar\r\n\r\n\r\ndef estaEnTablero(x, y):\r\n    # Devuelve True si las coordenadas se encuentran dentro del tablero\r\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\r\n\r\n\r\ndef obtenerTableroConJugadasValidas(tablero, baldosa):\r\n    # Devuelve un nuevo tablero, marcando las jugadas v\u00E1lidas que el jugador puede realizar.\r\n    dupTablero = obtenerCopiaTablero(tablero)\r\n\r\n    for x, y in obtenerJugadasValidas(dupTablero, baldosa):\r\n        dupTablero[x][y] = \'.\'\r\n    return dupTablero\r\n\r\n\r\ndef obtenerJugadasValidas(tablero, baldosa):\r\n    # Devuelve una lista de [x,y] listas de jugadas v\u00E1lidas para el jugador en el tablero dado.\r\n    jugadasValidas = []\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if esJugadaValida(tablero, baldosa, x, y) != False:\r\n                jugadasValidas.append([x, y])\r\n    return jugadasValidas\r\n\r\n\r\ndef obtenerPuntajeTablero(tablero):\r\n    # Determina el puntaje contando las baldosas. Devuelve un diccionario con las claves \'X\' y \'O\'.\r\n    puntajex = 0\r\n    puntajeo = 0\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if tablero[x][y] == \'X\':\r\n                puntajex += 1\r\n            if tablero[x][y] == \'O\':\r\n                puntajeo += 1\r\n    return {\'X\':puntajex, \'O\':puntajeo}\r\n\r\n\r\ndef ingresarBalsodaJugador():\r\n    # Permite al jugador elegir que baldosa desea ser.\r\n    # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.\r\n    baldosa = \'\'\r\n    while not (baldosa == \'X\' or baldosa == \'O\'):\r\n        print(\'\u00BFDeseas ser X u O?\')\r\n        baldosa = input().upper()\r\n\r\n    #  El primer elemento en la lista es la baldosa del juegador, la segunda la de la computadora.\r\n    if baldosa == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\n\r\ndef quienComienza():\r\n    # Elije al azar que jugador comienza.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computadora\'\r\n    else:\r\n        return \'jugador\'\r\n\r\n\r\ndef volverAJugar():\r\n    # Esta funcion devuelve True si el jugador desea volver a jugar, de lo contrario False.\r\n    print(\'\u00BFDeseas volver a jugar? (si o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\ndef hacerJugada(tablero, baldosa, comienzox, comienzoy):\r\n    # Posiciona la baldosa en el tablero en comienzox, comienzoy y gira cualquiera de las pizas del oponente.\r\n    # Devuelve False si es una jugada inv\u00E1lida, True si es v\u00E1lida.\r\n    baldosasAGirar = esJugadaValida(tablero, baldosa, comienzox, comienzoy)\r\n\r\n    if baldosasAGirar == False:\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa\r\n    for x, y in baldosasAGirar:\r\n        tablero[x][y] = baldosa\r\n    return True\r\n\r\n\r\ndef obtenerCopiaTablero(tablero):\r\n    # Duplica la lista del tablero y devuelve el duplicado.\r\n    dupTablero = obtenerNuevoTablero()\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            dupTablero[x][y] = tablero[x][y]\r\n\r\n    return dupTablero\r\n\r\n\r\ndef esEsquina(x, y):\r\n    # Devuelve True si la posicion es una de las esquinas.\r\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\r\n\r\n\r\ndef obtenerJugadaJugador(tablero, baldosaJugador):\r\n    # Permite al jugador tipear su jugada.\r\n    # Revuelve una jugada como [x,y] (o devuelve las palabras \'pistas\' o \'quitar\')\r\n    DIGITOS1A8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Ingresa tu jugada, quitar para terminar el juego, o pistas para activar\/desactivar pistas.\')\r\n        jugada = input().lower()\r\n        if jugada == \'quitar\':\r\n            return \'quitar\'\r\n        if jugada == \'pistas\':\r\n            return \'pistas\'\r\n\r\n        if len(jugada) == 2 and jugada[0] in DIGITOS1A8 and jugada[1] in DIGITOS1A8:\r\n            x = int(jugada[0]) - 1\r\n            y = int(jugada[1]) - 1\r\n            if esJugadaValida(tablero, baldosaJugador, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'Esta no es una jugada v\u00E1lida. Presiona el digito x (1-8), luego el digoto y (1-8).\')\r\n            print(\'Por ejemplo, 81 ser\u00E1 la esquina superior derecha.\')\r\n\r\n    return [x, y]\r\n\r\n\r\ndef obtenerJugadaComputadora(tablero, baldosaComputadora):\r\n    # Dado un tablero y la bandosa de la computadora, determinar donde\r\n    # realizar la jugada y devuelve esa jugada como una lista [x,y].\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosaComputadora)\r\n\r\n    # ordena al azar el orden de las jugadas posibles\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # siempre elegir una esquina de estar disponible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    # Recorrer todas las jugadas posibles y elegir la de mejor puntaje.\r\n    puntajeMaximo = -1\r\n    for x, y in jugadasPosibles:\r\n        dupTablero = obtenerCopiaTablero(tablero)\r\n        hacerJugada(dupTablero, baldosaComputadora, x, y)\r\n        puntaje = obtenerPuntajeTablero(dupTablero)[baldosaComputadora]\r\n        if puntaje > puntajeMaximo:\r\n            mejorJugada = [x, y]\r\n            puntajeMaximo = puntaje\r\n    return mejorJugada\r\n\r\n\r\ndef mostrarPuntajes(baldosaJugador, baldosaComputadora):\r\n    # Imprime en pantalla el mejor puntaje.\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'Tienes %s puntos. La computadora tiene %s puntos.\' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))\r\n\r\n\r\n\r\nprint(\'\u00A1Bienvenido a Reversi!\')\r\n\r\nganadasx = 0\r\nganadaso = 0\r\nempates = 0\r\nnumJuegos = int(input(\'Ingrese la cantidad de juegos a simular: \'))\r\n\r\nfor juego in range(numJuegos):\r\n    print(\'juego #%s:\' % (juego), end=\' \')\r\n    # Blanquea el tablero y el juego\r\n    tableroPrincipal = obtenerNuevoTablero()\r\n    blanquearTablero(tableroPrincipal)\r\n    if quienComienza() == \'jugador\':\r\n        turno = \'X\'\r\n    else:\r\n        turno = \'O\'\r\n\r\n    while True:\r\n        if turno == \'X\':\r\n            # Turno de X\r\n            otraBaldosa = \'O\'\r\n            x, y = obtenerJugadaComputadora(tableroPrincipal, \'X\')\r\n            hacerJugada(tableroPrincipal, \'X\', x, y)\r\n        else:\r\n            # Turno de O\r\n            otraBaldosa = \'X\'\r\n            x, y = obtenerJugadaComputadora(tableroPrincipal, \'O\')\r\n            hacerJugada(tableroPrincipal, \'O\', x, y)\r\n\r\n        if obtenerJugadasValidas(tableroPrincipal, otraBaldosa) == []:\r\n            break\r\n        else:\r\n            turno = otraBaldosa\r\n\r\n    # Muestra el puntaje final\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'X obtuvo %s puntos. O obtuvo %s puntos.\' % (puntajes[\'X\'], puntajes[\'O\']))\r\n\r\n    if puntajes[\'X\'] > puntajes[\'O\']:\r\n        ganadasx += 1\r\n    elif puntajes[\'X\'] < puntajes[\'O\']:\r\n        ganadaso += 1\r\n    else:\r\n        empates += 1\r\n\r\nnumJuegos = float(numJuegos)\r\nporcientox = round(((ganadasx \/ numJuegos) * 100), 2)\r\nporcientoo = round(((ganadaso \/ numJuegos) * 100), 2)\r\nporcientoempate = round(((empates \/ numJuegos) * 100), 2)\r\nprint(\'X gan\u00F3 %s juegos (%s%%), O gan\u00F3 %s juegos (%s%%), y hubo %s juegos empatados (%s%%) of %s juegos total.\' % (ganadasx, porcientox, ganadaso, porcientoo, empates, porcientoempate, numJuegos))\r\n",
    "AISim3":"# Reversi\r\n\r\nimport random\r\nimport sys\r\n\r\ndef dibujarTablero(tablero):\r\n    # Esta funcion dibuja el tablero pasado. Devuelve None\r\n    LINEAH = \'  +---+---+---+---+---+---+---+---+\'\r\n    LINEAV = \'  |   |   |   |   |   |   |   |   |\'\r\n\r\n    print(\'    1   2   3   4   5   6   7   8\')\r\n    print(LINEAH)\r\n    for y in range(8):\r\n        print(LINEAV)\r\n        print(y+1, end=\' \')\r\n        for x in range(8):\r\n            print(\'| %s\' % (tablero[x][y]), end=\' \')\r\n        print(\'|\')\r\n        print(LINEAV)\r\n        print(LINEAH)\r\n\r\n\r\ndef blanquearTablero(tablero):\r\n    # Blanquea el tablero pasado, excepto la posicion original.\r\n    for x in range(8):\r\n        for y in range(8):\r\n            tablero[x][y] = \' \'\r\n\r\n    # Piezas que comienzan:\r\n    tablero[3][3] = \'X\'\r\n    tablero[3][4] = \'O\'\r\n    tablero[4][3] = \'O\'\r\n    tablero[4][4] = \'X\'\r\n\r\n\r\ndef obtenerNuevoTablero():\r\n    # Crea un tablero nuevo, blanqueado.\r\n    tablero = []\r\n    for i in range(8):\r\n        tablero.append([\' \'] * 8)\r\n\r\n    return tablero\r\n\r\n\r\ndef esJugadaValida(tablero, baldosa, comienzox, comienzoy):\r\n    # Devuelve False si la jugada del jugador en comienzox, comienzoy es invalida\r\n    # Si es una jugada v\u00E1lida, devuelve una lista de espacios al que el jugador se podr\u00EDa mover.\r\n    if tablero[comienzox][comienzoy] != \' \' or not estaEnTablero(comienzox, comienzoy):\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa # establece temporalmente la baldosa en el tablero.\r\n\r\n    if baldosa == \'X\':\r\n        otraBaldosa = \'O\'\r\n    else:\r\n        otraBaldosa = \'X\'\r\n\r\n    baldosasAGirar = []\r\n    for direccionx, direcciony in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:\r\n        x, y = comienzox, comienzoy\r\n        x += direccionx # primer paso en la direcci\u00F3n\r\n        y += direcciony # primer paso en la direcci\u00F3n\r\n        if estaEnTablero(x, y) and tablero[x][y] == otraBaldosa:\r\n            # Hay una piza perteneciente al otro jugador al lado de nustra pieza\r\n            x += direccionx\r\n            y += direcciony\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            while tablero[x][y] == otraBaldosa:\r\n                x += direccionx\r\n                y += direcciony\r\n                if not estaEnTablero(x, y): # rompe el ciclo while y continua en el ciclo for.\r\n                    break\r\n            if not estaEnTablero(x, y):\r\n                continue\r\n            if tablero[x][y] == baldosa:\r\n                # Hay piezas a girar. Ve en aquella direcci\u00F3n hasta que lleguemos al espacio original, observando todas las baldosas.\r\n                while True:\r\n                    x -= direccionx\r\n                    y -= direcciony\r\n                    if x == comienzox and y == comienzoy:\r\n                        break\r\n                    baldosasAGirar.append([x, y])\r\n\r\n    tablero[comienzox][comienzoy] = \' \' # Restaura el espacio vacio.\r\n    if len(baldosasAGirar) == 0: # Si ninguna baldosa fue girada, no fue una jugada v\u00E1lida.\r\n        return False\r\n    return baldosasAGirar\r\n\r\n\r\ndef estaEnTablero(x, y):\r\n    # Devuelve True si las coordenadas se encuentran dentro del tablero\r\n    return x >= 0 and x <= 7 and y >= 0 and y <=7\r\n\r\n\r\ndef obtenerTableroConJugadasValidas(tablero, baldosa):\r\n    # Devuelve un nuevo tablero, marcando las jugadas v\u00E1lidas que el jugador puede realizar.\r\n    dupTablero = obtenerCopiaTablero(tablero)\r\n\r\n    for x, y in obtenerJugadasValidas(dupTablero, baldosa):\r\n        dupTablero[x][y] = \'.\'\r\n    return dupTablero\r\n\r\n\r\ndef obtenerJugadasValidas(tablero, baldosa):\r\n    # Devuelve una lista de [x,y] listas de jugadas v\u00E1lidas para el jugador en el tablero dado.\r\n    jugadasValidas = []\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if esJugadaValida(tablero, baldosa, x, y) != False:\r\n                jugadasValidas.append([x, y])\r\n    return jugadasValidas\r\n\r\n\r\ndef obtenerPuntajeTablero(tablero):\r\n    # Determina el puntaje contando las baldosas. Devuelve un diccionario con las claves \'X\' y \'O\'.\r\n    puntajex = 0\r\n    puntajeo = 0\r\n    for x in range(8):\r\n        for y in range(8):\r\n            if tablero[x][y] == \'X\':\r\n                puntajex += 1\r\n            if tablero[x][y] == \'O\':\r\n                puntajeo += 1\r\n    return {\'X\':puntajex, \'O\':puntajeo}\r\n\r\n\r\ndef ingresarBalsodaJugador():\r\n    # Permite al jugador elegir que baldosa desea ser.\r\n    # Devuelve una lista con la baldosa del jugador como primer elemento y el de la computadora como segundo.\r\n    baldosa = \'\'\r\n    while not (baldosa == \'X\' or baldosa == \'O\'):\r\n        print(\'\u00BFDeseas ser X u O?\')\r\n        baldosa = input().upper()\r\n\r\n    #  El primer elemento en la lista es la baldosa del juegador, la segunda la de la computadora.\r\n    if baldosa == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\n\r\ndef quienComienza():\r\n    # Elije al azar que jugador comienza.\r\n    if random.randint(0, 1) == 0:\r\n        return \'computadora\'\r\n    else:\r\n        return \'jugador\'\r\n\r\n\r\ndef volverAJugar():\r\n    # Esta funcion devuelve True si el jugador desea volver a jugar, de lo contrario False.\r\n    print(\'\u00BFDeseas volver a jugar? (si o no)\')\r\n    return input().lower().startswith(\'s\')\r\n\r\n\r\ndef hacerJugada(tablero, baldosa, comienzox, comienzoy):\r\n    # Posiciona la baldosa en el tablero en comienzox, comienzoy y gira cualquiera de las pizas del oponente.\r\n    # Devuelve False si es una jugada inv\u00E1lida, True si es v\u00E1lida\r\n    baldosasAGirar = esJugadaValida(tablero, baldosa, comienzox, comienzoy)\r\n\r\n    if baldosasAGirar == False:\r\n        return False\r\n\r\n    tablero[comienzox][comienzoy] = baldosa\r\n    for x, y in baldosasAGirar:\r\n        tablero[x][y] = baldosa\r\n    return True\r\n\r\n\r\ndef obtenerCopiaTablero(tablero):\r\n    # Duplica la lista del tablero y devuelve el duplicado.\r\n    dupTablero = obtenerNuevoTablero()\r\n\r\n    for x in range(8):\r\n        for y in range(8):\r\n            dupTablero[x][y] = tablero[x][y]\r\n\r\n    return dupTablero\r\n\r\n\r\ndef esEsquina(x, y):\r\n    # Devuelve True si la posicion es una de las esquinas.\r\n    return (x == 0 and y == 0) or (x == 7 and y == 0) or (x == 0 and y == 7) or (x == 7 and y == 7)\r\n\r\n\r\ndef obtenerJugadaJugador(tablero, baldosaJugador):\r\n    # Permite al jugador tipear su jugada.\r\n    # Revuelve una jugada como [x,y] (o devuelve las palabras \'pistas\' o \'quitar\')\r\n    DIGITOS1A8 = \'1 2 3 4 5 6 7 8\'.split()\r\n    while True:\r\n        print(\'Ingresa tu jugada, quitar para terminar el juego, o pistas para activar\/desactivar pistas.\')\r\n        jugada = input().lower()\r\n        if jugada == \'quitar\':\r\n            return \'quitar\'\r\n        if jugada == \'pistas\':\r\n            return \'pistas\'\r\n\r\n        if len(jugada) == 2 and jugada[0] in DIGITOS1A8 and jugada[1] in DIGITOS1A8:\r\n            x = int(jugada[0]) - 1\r\n            y = int(jugada[1]) - 1\r\n            if esJugadaValida(tablero, baldosaJugador, x, y) == False:\r\n                continue\r\n            else:\r\n                break\r\n        else:\r\n            print(\'Esta no es una jugada v\u00E1lida. Presiona el digito x (1-8), luego el digoto y (1-8).\')\r\n            print(\'Por ejemplo, 81 ser\u00E1 la esquina superior derecha.\')\r\n\r\n    return [x, y]\r\n\r\n\r\ndef obtenerJugadaComputadora(tablero, baldosaComputadora):\r\n    # Dado un tablero y la bandosa de la computadora, determinar donde\r\n    # realizar la jugada y devuelve esa jugada como una lista [x,y].\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosaComputadora)\r\n\r\n    # ordena al azar el orden de las jugadas posibles\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # siempre elegir una esquina de estar disponible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    # Recorrer todas las jugadas posibles y elegir la de mejor puntaje.\r\n    puntajeMaximo = -1\r\n    for x, y in jugadasPosibles:\r\n        dupTablero = obtenerCopiaTablero(tablero)\r\n        hacerJugada(dupTablero, baldosaComputadora, x, y)\r\n        puntaje = obtenerPuntajeTablero(dupTablero)[baldosaComputadora]\r\n        if puntaje > puntajeMaximo:\r\n            mejorJugada = [x, y]\r\n            puntajeMaximo = puntaje\r\n    return mejorJugada\r\n\r\n\r\ndef mostrarPuntajes(baldosaJugador, baldosaComputadora):\r\n    # Imprime en pantalla el mejor puntaje.\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'Tienes %s puntos. La computadora tiene %s puntos.\' % (puntajes[baldosaJugador], puntajes[baldosaComputadora]))\r\n\r\n\r\ndef obtenerJugadaAzar(tablero, baldosa):\r\n    # Devuelve una jugada al azar.\r\n    return random.choice( obtenerJugadasValidas(tablero, baldosa) )\r\n\r\n\r\ndef estaEnBorde(x, y):\r\n    return x == 0 or x == 7 or y == 0 or y ==7\r\n\r\n\r\ndef obtenerJugadaEsquinaBordeMejor(tablero, baldosa):\r\n    # Devuelve una jugada a una esquina, lado o la mejor jugada.\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosa)\r\n\r\n    # Ordena al azar las jugadas posibles.\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # Siempre ir por una esquina de ser posible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    # Si no hay ninguna esquina, devuelve una jugada de lado.\r\n    for x, y in jugadasPosibles:\r\n        if estaEnBorde(x, y):\r\n            return [x, y]\r\n\r\n    return obtenerJugadaComputadora(tablero, baldosa)\r\n\r\n\r\ndef obtenerBordeMejorJugada(tablero, baldosa):\r\n    # Devuelve una jugada a una esquina, un lado o la mejor jugada posible.\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosa)\r\n\r\n    # Ordena al azar las jugadas posibles.\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # Devuelve una jugada hacia un lado, de estar disponible.\r\n    for x, y in jugadasPosibles:\r\n        if estaEnBorde(x, y):\r\n            return [x, y]\r\n\r\n    return obtenerJugadaComputadora(tablero, baldosa)\r\n\r\n\r\ndef obtenerPeorJugada(tablero, baldosa):\r\n    # Devuelve la jugada que que voltea la menor cantidad de baldosas.\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosa)\r\n\r\n    # Ordena al azar las jugadas posibles.\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # Recorre todas las jugadas posibles y recuerda la de mejor puntaje.\r\n    peorPuntaje = 64\r\n    for x, y in jugadasPosibles:\r\n        dupTablero = getBoardCopy(tablero)\r\n        hacerJugada(dupTablero, baldosa, x, y)\r\n        puntaje = getScoreOfBoard(dupTablero)[baldosa]\r\n        if puntaje < peorPuntaje:\r\n            peorJugada = [x, y]\r\n            peorPuntaje = puntaje\r\n\r\n    return peorJugada\r\n\r\n\r\ndef obtenerEsquinaPeorJugada(tablero, baldosa):\r\n    # Devuelve la esquina, el especio o la jugada que voltea la menor cantidad de baldosas.\r\n    jugadasPosibles = obtenerJugadasValidas(tablero, baldosa)\r\n\r\n    # Ordena al azar las jugadas posibles.\r\n    random.shuffle(jugadasPosibles)\r\n\r\n    # Siempre ir hacia una esquina de ser posible.\r\n    for x, y in jugadasPosibles:\r\n        if esEsquina(x, y):\r\n            return [x, y]\r\n\r\n    return obtenerPeorJugada(tablero, baldosa)\r\n\r\n\r\n\r\nprint(\'\u00A1Bienvenido a Reversi!\')\r\n\r\nganadasx = 0\r\nganadaso = 0\r\nempates = 0\r\nnumJuegos = int(input(\'Ingrese la cantidad de juegos a simular: \'))\r\n\r\nfor juego in range(numJuegos):\r\n    print(\'juego #%s:\' % (juego), end=\' \')\r\n    # Blanquea el tablero y el juego\r\n    tableroPrincipal = obtenerNuevoTablero()\r\n    blanquearTablero(tableroPrincipal)\r\n    if quienComienza() == \'jugador\':\r\n        turno = \'X\'\r\n    else:\r\n        turno = \'O\'\r\n\r\n    while True:\r\n        if turno == \'X\':\r\n            # Turno de X\r\n            otraBaldosa = \'O\'\r\n            x, y = obtenerJugadaComputadora(tableroPrincipal, \'X\')\r\n            hacerJugada(tableroPrincipal, \'X\', x, y)\r\n        else:\r\n            # Turno de O\r\n            otraBaldosa = \'X\'\r\n            x, y = obtenerJugadaComputadora(tableroPrincipal, \'O\')\r\n            hacerJugada(tableroPrincipal, \'O\', x, y)\r\n\r\n        if obtenerJugadasValidas(tableroPrincipal, otraBaldosa) == []:\r\n            break\r\n        else:\r\n            turno = otraBaldosa\r\n\r\n    # Muestra el puntaje final\r\n    puntajes = obtenerPuntajeTablero(tableroPrincipal)\r\n    print(\'X obtuvo %s puntos. O obtuvo %s puntos.\' % (puntajes[\'X\'], puntajes[\'O\']))\r\n\r\n    if puntajes[\'X\'] > puntajes[\'O\']:\r\n        ganadasx += 1\r\n    elif puntajes[\'X\'] < puntajes[\'O\']:\r\n        ganadaso += 1\r\n    else:\r\n        empates += 1\r\n\r\nnumJuegos = float(numJuegos)\r\nporcientox = round(((ganadasx \/ numJuegos) * 100), 2)\r\nporcientoo = round(((ganadaso \/ numJuegos) * 100), 2)\r\nporcientoempate = round(((empates \/ numJuegos) * 100), 2)\r\nprint(\'X gan\u00F3 %s juegos (%s%%), O gan\u00F3 %s juegos (%s%%), y hubo %s juegos empatados (%s%%) of %s juegos total.\' % (ganadasx, porcientox, ganadaso, porcientoo, empates, porcientoempate, numJuegos))\r\n",
    "tateti":"# Ta Te Ti\r\n\r\nimport random\r\n\r\ndef dibujarTablero(tablero):\r\n    # Esta funci\u00F3n dibuja el tablero recibido como argumento.\r\n\r\n    # \"tablero\" es una lista de 10 cadenas representando la pizarra (ignora \u00EDndice 0)\r\n    print(\'   |   |\')\r\n    print(\' \' + tablero[7] + \' | \' + tablero[8] + \' | \' + tablero[9])\r\n    print(\'   |   |\')\r\n    print(\'-----------\')\r\n    print(\'   |   |\')\r\n    print(\' \' + tablero[4] + \' | \' + tablero[5] + \' | \' + tablero[6])\r\n    print(\'   |   |\')\r\n    print(\'-----------\')\r\n    print(\'   |   |\')\r\n    print(\' \' + tablero[1] + \' | \' + tablero[2] + \' | \' + tablero[3])\r\n    print(\'   |   |\')\r\n\r\ndef ingresaLetraJugador():\r\n    # Permite al jugador typear que letra desea ser.\r\n    # Devuelve una lista con las letras de los jugadores como primer item, y la de la computadora como segundo.\r\n    letra = \'\'\r\n    while not (letra == \'X\' or letra == \'O\'):\r\n        print(\'\u00BFDeseas ser X o O?\')\r\n        letra = input().upper()\r\n\r\n    # el primer elemento de la lista es la letra del jugador, el segundo es la letra de la computadora.\r\n    if letra == \'X\':\r\n        return [\'X\', \'O\']\r\n    else:\r\n        return [\'O\', \'X\']\r\n\r\ndef quienComienza():\r\n    # Elije al azar que jugador comienza.\r\n    if random.randint(0, 1) == 0:\r\n        return \'La computadora\'\r\n    else:\r\n        return \'El jugador\'\r\n\r\ndef jugarDeNuevo():\r\n    # Esta funcion devuelve True (Verdadero) si el jugador desea volver a jugar, de lo contrario devuelve False (Falso).\r\n    print(\'\u00BFDeseas volver a jugar? (s\u00ED\/no)?\')\r\n    return input().lower().startswith(\'s\')\r\n\r\ndef hacerJugada(tablero, letra, jugada):\r\n    tablero[jugada] = letra\r\n\r\ndef esGanador(ta, le):\r\n    # Dado un tablero y la letra de un jugador, devuelve True (verdadero) si el mismo ha ganado.\r\n    # Utilizamos reemplazamos tablero por ta y letra por le para no escribir tanto.\r\n    return ((ta[7] == le and ta[8] == le and ta[9] == le) or # horizontal superior\r\n    (ta[4] == le and ta[5] == le and ta[6] == le) or # horizontal medio\r\n    (ta[1] == le and ta[2] == le and ta[3] == le) or # horizontal inferior\r\n    (ta[7] == le and ta[4] == le and ta[1] == le) or # vertical izquierda\r\n    (ta[8] == le and ta[5] == le and ta[2] == le) or # vertical medio\r\n    (ta[9] == le and ta[6] == le and ta[3] == le) or # vertical derecha\r\n    (ta[7] == le and ta[5] == le and ta[3] == le) or # diagonal\r\n    (ta[9] == le and ta[5] == le and ta[1] == le)) # diagonal\r\n\r\ndef obtenerDuplicadoTablero(tablero):\r\n    # Duplica la lista del tablero y devuelve el duplicado.\r\n    dupTablero = []\r\n\r\n    for i in tablero:\r\n        dupTablero.append(i)\r\n\r\n    return dupTablero\r\n\r\ndef hayEspacioLibre(tablero, jugada):\r\n    # Devuelte true si hay espacio para efectuar la jugada en el tablero.\r\n    return tablero[jugada] == \' \'\r\n\r\ndef obtenerJugadaJugador(tablero):\r\n    # Permite al jugador escribir su jugada.\r\n    jugada = \' \'\r\n    while jugada not in \'1 2 3 4 5 6 7 8 9\'.split() or not hayEspacioLibre(tablero, int(jugada)):\r\n        print(\'\u00BFCu\u00E1l es tu pr\u00F3xima jugada? (1-9)\')\r\n        jugada = input()\r\n    return int(jugada)\r\n\r\ndef elegirAzarDeLista(tablero, listaJugada):\r\n    # Devuelve una jugada v\u00E1lida en el tablero de la lista recibida.\r\n    # Devuelve None si no hay ninguna jugada v\u00E1lida.\r\n    jugadasPosibles = []\r\n    for i in listaJugada:\r\n        if hayEspacioLibre(tablero, i):\r\n            jugadasPosibles.append(i)\r\n\r\n    if len(jugadasPosibles) != 0:\r\n        return random.choice(jugadasPosibles)\r\n    else:\r\n        return None\r\n\r\ndef obtenerJugadaComputadora(tablero, letraComputadora):\r\n    # Dado un tablero y la letra de la computadora, determina que jugada efectuar.\r\n    if letraComputadora == \'X\':\r\n        letraJugador = \'O\'\r\n    else:\r\n        letraJugador = \'X\'\r\n\r\n    # Aqu\u00ED est\u00E1 nuestro algoritmo para nuestra IA (Inteligencia Artifical) del Ta Te Ti.\r\n    # Primero, verifica si podemos ganar en la pr\u00F3xima jugada\r\n    for i in range(1, 10):\r\n        copia = obtenerDuplicadoTablero(tablero)\r\n        if hayEspacioLibre(copia, i):\r\n            hacerJugada(copia, letraComputadora, i)\r\n            if esGanador(copia, letraComputadora):\r\n                return i\r\n\r\n    # Verifica si el jugador podr\u00EDa ganar en su pr\u00F3xima jugada, y lo bloquea.\r\n    for i in range(1, 10):\r\n        copia = obtenerDuplicadoTablero(tablero)\r\n        if hayEspacioLibre(copia, i):\r\n            hacerJugada(copia, letraJugador, i)\r\n            if esGanador(copia, letraJugador):\r\n                return i\r\n\r\n    # Intenta ocupar una de las esquinas de estar libre.\r\n    jugada = elegirAzarDeLista(tablero, [1, 3, 7, 9])\r\n    if jugada != None:\r\n        return jugada\r\n\r\n    # De estar libre, intenta ocupar el centro.\r\n    if hayEspacioLibre(tablero, 5):\r\n        return 5\r\n\r\n    # Ocupa alguno de los lados.\r\n    return elegirAzarDeLista(tablero, [2, 4, 6, 8])\r\n\r\ndef tableroCompleto(tablero):\r\n    # Devuelve True si cada espacio del tablero fue ocupado, caso contrario devuele False.\r\n    for i in range(1, 10):\r\n        if hayEspacioLibre(tablero, i):\r\n            return False\r\n    return True\r\n\r\n\r\nprint(\'\u00A1Bienvenido al Ta Te Ti!\')\r\n\r\nwhile True:\r\n    # Resetea el tablero\r\n    elTablero = [\' \'] * 10\r\n    letraJugador, letraComputadora = ingresaLetraJugador()\r\n    turno = quienComienza()\r\n    print(turno + \' ir\u00E1 primero.\')\r\n    juegoEnCurso = True\r\n\r\n    while juegoEnCurso:\r\n        if turno == \'El jugador\':\r\n            # Turno del jugador\r\n            dibujarTablero(elTablero)\r\n            jugada = obtenerJugadaJugador(elTablero)\r\n            hacerJugada(elTablero, letraJugador, jugada)\r\n\r\n            if esGanador(elTablero, letraJugador):\r\n                dibujarTablero(elTablero)\r\n                print(\'\u00A1Felicidades, has ganado!\')\r\n                juegoEnCurso = False\r\n            else:\r\n                if tableroCompleto(elTablero):\r\n                    dibujarTablero(elTablero)\r\n                    print(\'\u00A1Es un empate!\')\r\n                    break\r\n                else:\r\n                    turno = \'La computadora\'\r\n\r\n        else:\r\n            # Turno de la computadora\r\n            jugada = obtenerJugadaComputadora(elTablero, letraComputadora)\r\n            hacerJugada(elTablero, letraComputadora, jugada)\r\n\r\n            if esGanador(elTablero, letraComputadora):\r\n                dibujarTablero(elTablero)\r\n                print(\'\u00A1La computadora te ha vencido! Has perdido.\')\r\n                juegoEnCurso = False\r\n            else:\r\n                if tableroCompleto(elTablero):\r\n                    dibujarTablero(elTablero)\r\n                    print(\'\u00A1Es un empate!\')\r\n                    break\r\n                else:\r\n                    turno = \'El jugador\'\r\n\r\n    if not jugarDeNuevo():\r\n        break\r\n"
};
