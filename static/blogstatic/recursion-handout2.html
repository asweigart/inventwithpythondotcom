<ol>
<li>To understand recursion, you must first understand <input type="text" value="stacks" />.</li>
<li>In a stack data structure, you can only add and remove from the <input type="text" value="top" /> of the stack.</li>
<li>The term for adding to a stack is <input type="text" value="pushing" />, while removing from a stack is <input type="text" value="popping" />.</li>
<li>Python lists can be used as a stack, with the <input type="text" value="append()" /> method for pushing and <input type="text" value="pop()" /> method for popping.</li>
<li>Function calls make use of a stack called the <input type="text" value="call stack" />.</li>
<li>The call stack pushes <input type="text" value="frame objects" /> when functions are called and pops them when functions return.</li>
<li>Frame objects contain the <input type="text" value="local variables" /> and <input type="text" value="return address" /> for a function call.</li>
<li>The sys.setrecursionlimit() function can change the maximum recursion depth. The times that it’s appropriate to call this is <input type="text" value="never" />.</li>
<li>Recursive functions must always have <input type="text" value="at least one" /> base case and <input type="text" value="at least one" /> recursive case.</li>
<li>"Iterative" means the code uses a <input type="text" value="loop" />.</li>
<li>Unlike recursive algorithms, iterative algorithms will never <input type="text" value="stack overflow" />.</li>
<li>Recursion and iteration are equally powerful. There is nothing recursion can do that you can't do with a <input type="text" value="loop" /> and a <input type="text" value="stack" />.</li>
<li>The recursive factorial solution can be confusing because code is run both <input type="text" value="before" /> and <input type="text" value="after" /> the recursive call.</li>
<li>The recursive factorial solution isn’t used in real world code because calculating large factorials results in a <input type="text" value="stack overflow" />.</li>
<li>The recursive Fibonacci solution isn’t used in real world code because calculating large Fibonacci numbers requires <input type="text" value="like trillions of years" />.</li>
<li>Recursion is a good technique to use when the problem involves <input type="text" value="tree-like data structures" /> and <input type="text" value="back-tracking" />.</li>
</ol>