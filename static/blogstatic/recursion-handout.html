<ol>
<li>To understand recursion, you must first understand <input type="text" />.</li>
<li>In a stack data structure, you can only add and remove from the <input type="text" /> of the stack.</li>
<li>The term for adding to a stack is <input type="text" />, while removing from a stack is <input type="text" />.</li>
<li>Python lists can be used as a stack, with the <input type="text" /> method for pushing and <input type="text" /> method for popping.</li>
<li>Function calls make use of a stack called the <input type="text" />.</li>
<li>The call stack pushes <input type="text" /> when functions are called and pops them when functions return.</li>
<li>Frame objects contain the <input type="text" /> and <input type="text" /> for a function call.</li>
<li>The sys.setrecursionlimit() function can change the maximum recursion depth. The times that it’s appropriate to call this is <input type="text" />.</li>
<li>Recursive functions must always have <input type="text" /> base case and <input type="text" /> recursive case.</li>
<li>"Iterative" means the code uses a <input type="text" />.</li>
<li>Unlike recursive algorithms, iterative algorithms will never <input type="text" />.</li>
<li>Recursion and iteration are equally powerful. There is nothing recursion can do that you can't do with a <input type="text" /> and a <input type="text" />.</li>
<li>The recursive factorial solution can be confusing because code is run <input type="text" /> and <input type="text" /> the recursive call.</li>
<li>The recursive factorial solution isn’t used in real world code because calculating large factorials results in a <input type="text" />.</li>
<li>The recursive Fibonacci solution isn’t used in real world code because calculating large Fibonacci numbers requires <input type="text" />.</li>
<li>Recursion is a good technique to use when the problem involves <input type="text" /> and <input type="text" />.</li>
</ol>