<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="recursion-style.css" rel="stylesheet" type="text/css" /><title>Chapter 3 - Classic Recursion Algorithms</title></head><body>



<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.webp" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get a discount on the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<div><a href="chapter2.html">Prev: Chapter 2 - Recursion vs. Iteration</a> | <a href="chapter4.html">Next: Chapter 4 - Backtracking and Tree Traversal Algorithms</a></div>




<div type="bodymatter chapter" class="calibre1" id="calibre_link-279">
<section class="toclist">
<header class="calibre14">
<h1 class="chapter">
<span class="partnumber"><span type="pagebreak" title="45" id="calibre_link-494" class="calibre36"></span>3</span><br class="calibre18" />
<span class="parttitle">Classic Recursion Algorithms</span></h1>
</header>
<figure class="opener">
<img src="images/000060.webp" alt="" class="calibre16" />
</figure>
<p class="chapterintro">If you take a computer science course, the unit on recursion is sure to cover some of the classic algorithms presented in this chapter. Coding interviews (which, for lack of suitable ways to evaluate candidates, often crib notes from freshman computer science curricula) can touch upon them too. This chapter covers six classic problems in recursion, along with their solutions.</p>
<p class="calibre24">We begin with three simple algorithms: summing the numbers in an array, reversing a text string, and detecting whether a string is a palindrome. Then we explore an algorithm for solving the Tower of Hanoi puzzle, implement the flood fill drawing algorithm, and tackle the absurdly recursive Ackermann function.</p>
<p class="calibre22">In the process, you’ll learn about the head-tail technique for splitting up the data in the recursive function arguments. We’ll also ask ourselves three questions when trying to come up with recursive solutions: What is the base case? What argument is passed to the recursive function call? And <span type="pagebreak" title="46" id="calibre_link-122" class="calibre17"></span>how do the arguments passed to the recursive function calls become closer to the base case? As you gain more experience, answering these questions should come more naturally.</p>
<h2 id="calibre_link-280" class="calibre6">Summing Numbers in an Array</h2>
<p class="bodyfirst">Our first example is simple: given a list (in Python) or an array (in JavaScript) of integers, return the total sum of all the integers. For example, a call such as <code class="calibre11">sum([5, 2, 4, 8])</code> should return <code class="calibre11">19</code>.</p>
<p class="calibre22">This is easy to solve with a loop, but solving it with recursion requires more thought. After reading <span class="calibre" itemid="xref_target_Chapter 2">Chapter 2</span>, you might also notice that this algorithm doesn’t map well enough to recursion’s capabilities to justify recursion’s added complexity. Still, summing numbers in an array (or some other calculation based on processing data in a linear data structure) is a common enough recursion problem in coding interviews that it deserves our attention. </p>
<p class="calibre22">To solve this problem, let’s examine the <em class="calibre10">head-tail technique</em> for implementing recursive functions. This technique splits the recursive function’s array argument into two parts: the <em class="calibre10">head</em> (the first element of the array) and the <em class="calibre10">tail</em> (a new array including everything after the first element). We define the recursive <code class="calibre11">sum()</code> function to find the sum of the array argument’s integers by adding the head to the sum of the tail array. To find out the sum of the tail array, we recursively pass it as the array argument to <code class="calibre11">sum()</code>.</p>
<p class="calibre22">Because the tail array is one element smaller than the original array argument, we’ll eventually end up calling the recursive function and passing it an empty array. An empty array argument is trivial to sum and doesn’t require more recursive calls; it is merely <code class="calibre11">0</code>. From these facts, our answers to the three questions are as follows:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case?</span>  An empty array, which has the sum of <code class="calibre11">0</code>.</li>
<li class="calibre9"><span class="runinhead">What argument is passed to the recursive function call?</span>  The tail of the original number array, which has one less number than the original array argument.</li>
<li class="calibre9"><span class="runinhead">How does this argument become closer to the base case?</span>  The array argument shrinks by one element for each recursive call until it becomes a zero-length, or empty, array.</li>
</ol>
<p class="calibre22">Here is <em class="calibre10">sumHeadTail.py</em>, a Python program to sum a list of numbers:</p>
<p class="codelabel"><b class="calibre7">Python</b></p>
<pre class="calibre23">def sum(numbers):<br class="calibre49" />    if len(numbers) == 0: # BASE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation1">❶</span> return 0<br class="calibre49" />    else: # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> head = numbers[0]<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> tail = numbers[1:]<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation4">❹</span> return head + sum(tail)<br class="calibre49" /><br class="calibre49" />nums = [1, 2, 3, 4, 5]<br class="calibre49" />print('The sum of', nums, 'is', sum(nums))<br class="calibre49" />nums = [5, 2, 4, 8]<br class="calibre49" /><span type="pagebreak" title="47" id="calibre_link-176" class="calibre17"></span>print('The sum of', nums, 'is', sum(nums))<br class="calibre49" />nums = [1, 10, 100, 1000]<br class="calibre49" />print('The sum of', nums, 'is', sum(nums))</pre>
<p class="calibre22">And here is the equivalent JavaScript program, <em class="calibre10">sumHeadTail.html</em>:</p>
<p class="codelabel"><b class="calibre7">JavaScript</b></p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;<br class="calibre49" />function sum(numbers) {<br class="calibre49" />    if (numbers.length === 0) { // BASE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation1">❶</span> return 0;<br class="calibre49" />    } else { // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> let head = numbers[0];<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> let tail = numbers.slice(1, numbers.length);<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation4">❹</span> return head + sum(tail);<br class="calibre49" />    }<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />let nums = [1, 2, 3, 4, 5];<br class="calibre49" />document.write('The sum of ' + nums + ' is ' + sum(nums) + "&lt;br /&gt;");<br class="calibre49" />nums = [5, 2, 4, 8];<br class="calibre49" />document.write('The sum of ' + nums + ' is ' + sum(nums) + "&lt;br /&gt;");<br class="calibre49" />nums = [1, 10, 100, 1000];<br class="calibre49" />document.write('The sum of ' + nums + ' is ' + sum(nums) + "&lt;br /&gt;");<br class="calibre49" />&lt;/script&gt;</pre>
<p class="calibre22">The output of these programs is shown here:</p>
<pre class="calibre23">The sum of [1, 2, 3, 4, 5] is 15<br class="calibre49" />The sum of [5, 2, 4, 8] is 19<br class="calibre49" />The sum of [1, 10, 100, 1000] is 1111</pre>
<p class="calibre22">When called with an empty array argument, the base case of our function simply returns <code class="calibre11">0</code> <span class="codeannotation" aria-label="annotation1">❶</span>. In the recursive case, we form the head <span class="codeannotation" aria-label="annotation2">❷</span> and the tail <span class="codeannotation" aria-label="annotation3">❸</span> from the original <code class="calibre11">numbers</code> argument. Keep in mind that the data type of <code class="calibre11">tail</code> is an array of numbers, just like the <code class="calibre11">numbers</code> argument. But the data type of <code class="calibre11">head</code> is just a single number value, and not an array with one number value. The return value of the <code class="calibre11">sum()</code> function is also a single number value and not an array of numbers; this is why we can add <code class="calibre11">head</code> and <code class="calibre11">sum(tail)</code> together in the recursive case <span class="codeannotation" aria-label="annotation4">❹</span>. </p>
<p class="calibre22">Each recursive call passes a smaller and smaller array to <code class="calibre11">sum()</code>, bringing it closer to the base case of an empty array. For example, <a href="#calibre_link-447" id="calibre_link-631" class="linkurl">Figure 3-1</a> shows the state of the call stack for <code class="calibre11">sum([5, 2, 4, 8])</code>.</p>
<p class="calibre22">In this figure, each card in the stack represents a function call. At the top of each card is the function name with the argument it was passed when called. Beneath that are the local variables: the <code class="calibre11">numbers</code> parameter, and the <code class="calibre11">head</code> and <code class="calibre11">tail</code> local variables created during the call. At the bottom of the card is the <code class="calibre11">head + sum(tail)</code> expression that the function call returns. When a new recursive function is made, a new card is pushed to the stack. When the function call returns, the top card is popped from the stack.</p>
<span type="pagebreak" title="48" id="calibre_link-39" class="calibre17"></span><figure class="calibre25">
<img src="images/000080.webp" class="calibre16" alt="A series of stacks of cards representing frame objects on the call stack. In order, the new top card represents a call to sum() passing [5, 2, 4, 8], then passing [2, 4, 8], then passing [4, 8], then passing [8], then passing an empty list. Then the top cards are removed, first removing the empty list card, then the [8] card, then [4, 8], then [2, 4, 8], then [5, 2, 4, 8]." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-447" class="linkurl">Figure 3-1</a>: The state of the call stack when <span class="calibre"><code class="calibre39">sum([5, 2, 4, 8])</code></span> runs</p></figcaption>
</figure>
<p class="calibre22">We can use the <code class="calibre11">sum()</code> function as a template for applying the head-tail technique to other recursive functions. For example, you can change the <code class="calibre11">sum()</code> function from one that sums an array of numbers to a <code class="calibre11">concat()</code> function that concatenates an array of strings together. The base case would return an empty string for an empty array argument, while the recursive case would return the head string joined with the return value of the recursive call that is passed the tail.</p>
<p class="calibre22">Recall from <span class="calibre" itemid="xref_target_Chapter 2 ">Chapter 2 </span>that recursion is especially suited for problems that involve a tree-like structure and backtracking. An array, string, or other linear data structure can be considered a tree-like structure, albeit a tree that has only one branch at each node, as in <a href="#calibre_link-448" id="calibre_link-632" class="linkurl">Figure 3-2</a>.</p>
<span type="pagebreak" title="49" id="calibre_link-123" class="calibre17"></span><figure class="calibre25">
<img src="images/000061.webp" class="calibre16" alt="Two images, one of a tree with every node circled, and one of a crooked branch with every bend circled and the numbers 8, 4, 2, and 5 written in the circles." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-448" class="linkurl">Figure 3-2</a>: A <span class="calibre"><code class="calibre39">[5, 2, 4, 8]</code></span> array (right) is like a tree data structure (left) with only one branch at each node.</p></figcaption>
</figure>
<p class="calibre22">The key “tell” that our recursive function is unnecessary is that it never does any backtracking over the data it processes. It makes a single pass over each element in the array from beginning to end, which is something a basic loop can accomplish. Additionally, the Python recursive summation function is about 100 times slower than a straightforward iterative algorithm. Even if performance weren’t an issue, the recursive <code class="calibre11">sum()</code> function would cause a stack overflow if passed a list with tens of thousands of numbers to sum. Recursion is an advanced technique, but it isn’t always the best approach.</p>
<p class="calibre22">In <span class="calibre" itemid="xref_target_Chapter 5">Chapter 5</span>, we’ll examine a recursive summation function that uses a divide-and-conquer strategy, and in <span class="calibre" itemid="xref_target_Chapter 8 ">Chapter 8 </span>we’ll examine one that uses tail call optimization. These alternate recursive approaches work around some of the problems in the summation function in this chapter.</p>
<h2 id="calibre_link-281" class="calibre6">Reversing a String</h2>
<p class="bodyfirst">Like summing the numbers in an array, reversing a string is another frequently cited recursive algorithm even though the iterative solution is straightforward. Because a string is essentially an array of single characters, we’ll employ the head and tail approach for our <code class="calibre11">rev()</code> function just as we did for the summation algorithm.</p>
<p class="calibre22">Let’s start with the smallest strings possible. A blank string and a single-character string are already the reverse of themselves. These naturally form our base cases: if the string argument is a string such as <code class="calibre11">''</code> or <code class="calibre11">'A'</code>, our function should simply return the string argument.</p>
<p class="calibre22">For larger strings, let’s try splitting the string into a head (just the first character) and tail (all characters after the first). For a two-character string like <code class="calibre11">'XY'</code>, <code class="calibre11">'X'</code> is the head and <code class="calibre11">'Y'</code> is the tail. To reverse the string, we need to place the head behind the tail: <code class="calibre11">'YX'</code>.</p>
<p class="calibre22">Does this algorithm hold for longer strings? To reverse a string like <code class="calibre11">'CAT'</code>, we would break it into the head <code class="calibre11">'C'</code> and the tail <code class="calibre11">'AT'</code>. But placing the head behind the tail alone doesn’t reverse the string; it gives us <code class="calibre11">'ATC'</code>. What we actually want to do is put the head behind <em class="calibre10">the reverse of</em> the tail. In other <span type="pagebreak" title="50" id="calibre_link-147" class="calibre17"></span>words, <code class="calibre11">'AT'</code> would reverse to <code class="calibre11">'TA'</code>, and then adding the head to the end of that would produce the reversed string, <code class="calibre11">'TAC'</code>.</p>
<p class="calibre22">How can we reverse the tail? Well, we can recursively call <code class="calibre11">rev()</code> and pass it the tail. Forget about the implementation of our function for a moment and focus on its input and output: <code class="calibre11">rev()</code> takes one string argument and returns a string with the argument’s characters reversed. </p>
<p class="calibre22">Thinking about how to implement a recursive function like <code class="calibre11">rev()</code> can be difficult because it involves a chicken-and-egg problem. In order to write <code class="calibre11">rev()</code>’s recursive case, we need to call a function that reverses a string&mdash;that is, <code class="calibre11">rev()</code>. As long as we have a solid understanding of what our recursive function’s arguments and return value will be, we can use the <em class="calibre10">leap-of-faith</em> technique to get around this chicken-and-egg problem by writing our recursive case assuming the <code class="calibre11">rev()</code> function call returns the correct value even though we haven’t finished writing it yet.</p>
<p class="calibre22">Taking a leap of faith in recursion is not a magical technique that guarantees your code works bug free. It is merely a perspective to hold to break past the mental programmer’s block you can have when thinking about how to implement your recursive function. The leap of faith requires you to have a firm understanding of your recursive function’s arguments and return value.</p>
<p class="calibre22">Note that the leap-of-faith technique only helps you write the recursive case. You must pass to the recursive call an argument that is closer to the base case. You can’t simply pass the same argument that the recursive function received, like this:</p>
<pre class="calibre23">def rev(theString):<br class="calibre49" />    return rev(theString) # This won't magically work.</pre>
<p class="calibre22">To continue our <code class="calibre11">'CAT'</code> example, when we pass the tail <code class="calibre11">'AT'</code> to <code class="calibre11">rev()</code>, the head is <code class="calibre11">'A'</code> and the tail is <code class="calibre11">'T'</code> in <em class="calibre10">that</em> function call. We already know that the reverse of a single-character string like <code class="calibre11">'T'</code> is simply <code class="calibre11">'T'</code>; that’s our base case. So this second call to <code class="calibre11">rev()</code> will reverse <code class="calibre11">'AT'</code> to <code class="calibre11">'TA'</code>, which is precisely what the previous call to <code class="calibre11">rev()</code> needs. <a href="#calibre_link-449" id="calibre_link-633" class="linkurl">Figure 3-3</a> shows the state of the call stack during all the recursive calls to <code class="calibre11">rev()</code>.</p>
<p class="calibre22">Let’s ask our three recursive algorithm questions about the <code class="calibre11">rev()</code> function:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case? </span>  A zero- or one-character string.</li>
<li class="calibre9"><span class="runinhead">What argument is passed to the recursive function call? </span>  The tail of the original string argument, which has one less character than the original string argument.</li>
<li class="calibre9"><span class="runinhead">How does this argument become closer to the base case? </span>  The array argument shrinks by one element for each recursive call until it becomes a one- or zero-length array.</li>
</ol>
<span type="pagebreak" title="51" id="calibre_link-181" class="calibre17"></span><figure class="calibre25">
<img src="images/000070.webp" class="calibre16" alt="Timeline showing the state of the call stack during each recursive call to the rev function. It begins with rev called with the argument “CAT,” the theString variable equal to “CAT,” the head variable equal to “C,” the tail variable equal to “AT,” and a return value of rev(‘AT’) + ‘C’. Next, rev is called with the argument “AT,” theString is “AT,” head is “A,” tail is “T,” and the return value is rev(‘T’) + ‘A’. Then, rev is called with the argument “T,” theString is equal to “T,” and the function returns ‘T’. In the fourth state, rev is called with an argument of “AT,” theString is “AT,” head is “A,” tail is “T,” and the function returns ‘T’ + ‘A’. Finally, rev is called with the argument “CAT,” theString is “CAT,” head is “C,” tail is “AT,” and the function returns ‘TA’ + ‘C’. After this, the call stack is empty." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-449" class="linkurl">Figure 3-3</a>: The state of the call stack as the <span class="calibre"><code class="calibre39">rev()</code></span> function reverses the <span class="calibre"><code class="calibre39">CAT</code></span> string</p></figcaption>
</figure>
<p class="calibre22">Here is <em class="calibre10">reverseString.py</em>, a Python program to reverse a string:</p>
<p class="codelabel"><b class="calibre7">Python</b></p>
<pre class="calibre23">def rev(theString):<br class="calibre49" />  <span class="codeannotationcode" aria-label="annotation1">❶</span> if len(theString) == 0 or len(theString) == 1:<br class="calibre49" />        # BASE CASE<br class="calibre49" />        return theString<br class="calibre49" />    else:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> head = theString[0]<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> tail = theString[1:]<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation4">❹</span> return rev(tail) + head<br class="calibre49" /><br class="calibre49" />print(rev('abcdef'))<br class="calibre49" />print(rev('Hello, world!'))<br class="calibre49" />print(rev(''))<br class="calibre49" />print(rev('X'))</pre>
<p class="calibre22">And here is the equivalent JavaScript code in <em class="calibre10">reverseString.html</em>:</p>
<p class="codelabel"><b class="calibre7">JavaScript</b></p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;<br class="calibre49" />function rev(theString) {<br class="calibre49" />  <span class="codeannotationcode" aria-label="annotation1">❶</span> if (theString.length === 0 || theString.length === 1) {<br class="calibre49" />        // BASE CASE<br class="calibre49" />        return theString;<br class="calibre49" />    } else {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> let head = theString[0];<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> let tail = theString.substring(1, theString.length);<br class="calibre49" /><span type="pagebreak" title="52" id="calibre_link-124" class="calibre17"></span>      <span class="codeannotationcode" aria-label="annotation4">❹</span> return rev(tail) + head;<br class="calibre49" />    }<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />document.write(rev("abcdef") + "&lt;br /&gt;");<br class="calibre49" />document.write(rev("Hello, world!") + "&lt;br /&gt;");<br class="calibre49" />document.write(rev("") + "&lt;br /&gt;");<br class="calibre49" />document.write(rev("X") + "&lt;br /&gt;");<br class="calibre49" />&lt;/script&gt;</pre>
<p class="calibre22">Here is the output of these programs:</p>
<pre class="calibre23">fedcba<br class="calibre49" />!dlrow ,olleH<br class="calibre49" /><br class="calibre49" />X</pre>
<p class="calibre22">Our recursive function <code class="calibre11">rev()</code> returns the string that is the reverse of the argument, <code class="calibre11">theString</code>. Let’s consider the simplest strings to reverse: the empty string and a single-character string would “reverse” to themselves. These are the two base cases with which we’ll start (though we combine them with an <code class="calibre11">or</code> or <code class="calibre11">||</code> Boolean operator <span class="codeannotation" aria-label="annotation1">❶</span>). For the recursive case, we form <code class="calibre11">head</code> from the first character in <code class="calibre11">theString</code> <span class="codeannotation" aria-label="annotation2">❷</span>, and <code class="calibre11">tail</code> from every character after the first <span class="codeannotation" aria-label="annotation3">❸</span>. The recursive case then returns the reverse of <code class="calibre11">tail</code> followed by the <code class="calibre11">head</code> character <span class="codeannotation" aria-label="annotation4">❹</span>.</p>
<h2 id="calibre_link-282" class="calibre6">Detecting Palindromes</h2>
<p class="bodyfirst">A <em class="calibre10">palindrome</em> is a word or phrase that is spelled the same when written forward and backward. <em class="calibre10">Level</em>, <em class="calibre10">race car</em>, <em class="calibre10">taco cat</em>, and <em class="calibre10">a man, a plan, a canal . . . Panama</em> are all examples of palindromes. If you would like to detect whether a string is a palindrome, you can write a recursive <code class="calibre11">isPalindrome()</code> function. </p>
<p class="calibre22">The base case is a zero- or one-character string, which by its nature is always the same, whether forward or backward. We’ll use an approach similar to the head-tail technique, except that we’ll split the string argument into head, middle, and last strings instead. If the head and last characters are the same and the middle characters also form a palindrome, the string is a palindrome. The recursion comes from passing the middle string to <code class="calibre11">isPalindrome()</code>.</p>
<p class="calibre22">Let’s ask the three recursive algorithm questions about the <code class="calibre11">isPalindrome()</code> function:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case?</span>  A zero- or one-character string, which returns <code class="calibre11">True</code> because it is always a palindrome.</li>
<li class="calibre9"><span class="runinhead">What argument is passed to the recursive function call?</span>  The middle characters of the string argument.</li>
<li class="calibre9"><span class="runinhead">How does this argument become closer to the base case?</span>  The string argument shrinks by two characters for each recursive call until it becomes a zero- or one-character string.</li>
</ol>
<p class="calibre22"><span type="pagebreak" title="53" id="calibre_link-169" class="calibre17"></span>Here is <em class="calibre10">palindrome.py</em>, a Python program to detect palindromes:</p>
<p class="codelabel"><b class="calibre7">Python</b></p>
<pre class="calibre23">def isPalindrome(theString):
    if len(theString) == 0 or len(theString) == 1:
        # BASE CASE
        return True
    else:
        # RECURSIVE CASE
      <span class="codeannotationcode" aria-label="annotation1">❶ head = theString[0]</span>
      <span class="codeannotationcode" aria-label="annotation2">❷ middle = theString[1:-1]</span>
      <span class="codeannotationcode" aria-label="annotation3">❸ last = theString[-1]</span>
      <span class="codeannotationcode" aria-label="annotation4">❹ return head == last and isPalindrome(middle)</span>

text = 'racecar'
print(text + ' is a palindrome: ' + str(isPalindrome(text)))
text = 'amanaplanacanalpanama'
print(text + ' is a palindrome: ' + str(isPalindrome(text)))
text = 'tacocat'
print(text + ' is a palindrome: ' + str(isPalindrome(text)))
text = 'zophie'
print(text + ' is a palindrome: ' + str(isPalindrome(text)))</pre>
<p class="calibre22">Here is the equivalent JavaScript code in <em class="calibre10">palindrome.html</em>:</p>
<p class="codelabel"><b class="calibre7">JavaScript</b></p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;
function isPalindrome(theString) {
    if (theString.length === 0 || theString.length === 1) {
        // BASE CASE
        return true;
    } else {
        // RECURSIVE CASE
      <span class="codeannotationcode" aria-label="annotation1">❶ let head = theString[0];</span>
      <span class="codeannotationcode" aria-label="annotation2">❷ let middle = theString.substring(1, theString.length -1);</span>
      <span class="codeannotationcode" aria-label="annotation3">❸ let last = theString[theString.length - 1];</span>
      <span class="codeannotationcode" aria-label="annotation4">❹ return head === last &amp;&amp; isPalindrome(middle);</span>
    }
}

text = "racecar";
document.write(text + " is a palindrome: " + isPalindrome(text) + "&lt;br /&gt;");
text = "amanaplanacanalpanama";
document.write(text + " is a palindrome: " + isPalindrome(text) + "&lt;br /&gt;");
text = "tacocat";
document.write(text + " is a palindrome: " + isPalindrome(text) + "&lt;br /&gt;");
text = "zophie";
document.write(text + " is a palindrome: " + isPalindrome(text) + "&lt;br /&gt;");
&lt;/script&gt;</pre>
<p class="calibre22">Here is the output of these programs:</p>
<pre class="calibre23">racecar is a palindrome: True<br class="calibre49" />amanaplanacanalpanama is a palindrome: True<br class="calibre49" />tacocat is a palindrome: True<br class="calibre49" />zophie is a palindrome: False</pre>
<p class="calibre22"><span type="pagebreak" title="54" id="calibre_link-25" class="calibre17"></span>The base case returns <code class="calibre11">True</code> because a zero- or one-character string is always a palindrome. Otherwise, the string argument is broken into three pieces: the first character <span class="codeannotation" aria-label="annotation1">❶</span>, the last character <span class="codeannotation" aria-label="annotation3">❸</span>, and the middle characters between them <span class="codeannotation" aria-label="annotation2">❷</span>.</p>
<p class="calibre22">The <code class="calibre11">return</code> statement in the recursive case <span class="codeannotation" aria-label="annotation4">❹</span> makes use of <em class="calibre10">Boolean short-circuiting</em>, a feature of almost every programming language. In an expression joined with the <code class="calibre11">and</code> or <code class="calibre11">&amp;&amp;</code> Boolean operators, if the left-side expression is <code class="calibre11">False</code>, it doesn’t matter if the right-side expression is <code class="calibre11">True</code> or <code class="calibre11">False</code> because the entire expression will be <code class="calibre11">False</code>. Boolean short-circuiting is an optimization that skips the evaluation of the right-side expression of an <code class="calibre11">and</code> operator if the left side is <code class="calibre11">False</code>. So, in the expression <code class="calibre11">head == last and isPalindrome(middle)</code>, if <code class="calibre11">head == last</code> is <code class="calibre11">False</code>, the recursive call to <code class="calibre11">isPalindrome()</code> is skipped. This means that as soon as the head and last strings don’t match, the recursion stops and simply returns <code class="calibre11">False</code>.</p>
<p class="calibre22">This recursive algorithm is still sequential, like the summation and reverse-string functions in the previous sections, except that instead of going from the start of the data to the end, it goes from both ends of the data toward the middle. The iterative version of this algorithm that uses a simple loop is more straightforward. We cover the recursive version in this book because it’s a common coding interview problem.</p>
<h2 id="calibre_link-283" class="calibre6">Solving the Tower of Hanoi</h2>
<p class="bodyfirst">The <em class="calibre10">Tower of Hanoi</em> is a puzzle involving a tower of stacked disks. The puzzle begins with the largest disk on the bottom, and the disk sizes decrease going up. Each disk has a hole in its center so that the disks can be stacked on top of one another on a pole. <a href="#calibre_link-450" id="calibre_link-634" class="linkurl">Figure 3-4</a> shows a wooden Tower of Hanoi puzzle.</p>
<figure class="calibre25">
<img src="images/000034.webp" class="calibre16" alt="Picture of a wooden surface with three poles sticking out of it and a stack of disks, decreasing in size from bottom to top, placed on the first pole." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-450" class="linkurl">Figure 3-4</a>: A wooden Tower of Hanoi puzzle set</p></figcaption>
</figure>
<p class="calibre22"><span type="pagebreak" title="55" id="calibre_link-196" class="calibre17"></span>To solve the puzzle, the player must move the stack of disks from one pole to another while following three rules:</p>
<ul class="calibre38">
<li class="calibre9">The player can move only one disk at a time.</li>
<li class="calibre9">The player can move disks only to and from the top of a tower.</li>
<li class="calibre9">The player can never place a larger disk on top of a smaller disk.</li>
</ul>
<p class="calibre22">Python’s built-in <code class="calibre11">turtledemo</code> module has a Tower of Hanoi demonstration that you can see by running <code class="bold">python -m turtledemo</code> on Windows or <code class="bold">python3 -m turtledemo</code> on macOS/Linux, and then selecting <b class="calibre7">minimum_hanoi</b> from the Examples menu. Tower of Hanoi animations are readily found through an internet search as well.</p>
<p class="calibre22">The recursive algorithm for solving the Tower of Hanoi puzzle is not intuitive. Let’s start with the smallest case: a Tower of Hanoi with one disk. The solution is trivial: move the disk to another pole and you’re finished. Solving for two disks is slightly more complicated: move the smaller disk to one pole (we’ll call it the <em class="calibre10">temporary pole</em>) and the larger disk to the other pole (we’ll call it the <em class="calibre10">end pole</em>), and then finally move the smaller disk from the temporary pole to the end pole. Both disks are now on the end pole in the correct order. </p>
<p class="calibre22">Once you solve the three-disk tower, you’ll notice that a pattern emerges. To solve a tower of <em class="calibre10">n</em> disks from the start pole to the end pole, you must do the following:</p>
<ol class="decimal">
<li value="1" class="calibre9">Solve the <em class="calibre10">n </em>&ndash; 1 disks puzzle by moving those disks from the start pole to the temporary pole.</li>
<li value="2" class="calibre9">Move the <em class="calibre10">n</em>th disk from the start pole to the end pole.</li>
<li value="3" class="calibre9">Solve the <em class="calibre10">n </em>&ndash; 1 disks puzzle by moving those disks from the temporary pole to the end pole.</li>
</ol>
<p class="calibre22">Like the Fibonacci algorithm, the recursive case for the Tower of Hanoi algorithm makes two recursive calls instead of just one. If we draw a tree diagram of the operations for solving a four-disk Tower of Hanoi, it looks like <a href="#calibre_link-452" id="calibre_link-635" class="linkurl">Figure 3-5</a>. Solving the four-disk puzzle requires the same steps as solving the three-disk puzzle, as well as moving the fourth disk and performing the steps of solving the three-disk puzzle again. Likewise, solving the three-disk puzzle requires the same steps as the two-disk puzzle plus moving the third disk, and so on. Solving the one-disk puzzle is the trivial base case: it involves only moving the disk. </p>
<p class="calibre22">The tree-like structure in <a href="#calibre_link-451" id="calibre_link-636" class="linkurl">Figure 3-5</a> hints that a recursive approach is ideal for solving the Tower of Hanoi puzzle. In this tree, the execution moves from top to bottom and from left to right.</p>
<p class="calibre22">While a three-disk or four-disk Tower of Hanoi is easy for a human to solve, increasing numbers of disks require an exponentially increasing number of operations to complete. For <em class="calibre10">n</em> disks, it takes a minimum of 2^<em class="calibre10">n </em>&ndash; 1 moves to solve. This means a 30-disk tower requires over a billion moves to complete!</p>
<span type="pagebreak" title="56" id="calibre_link-184" class="calibre17"></span><figure class="calibre25">
<img src="images/000043.webp" class="calibre16" alt="Tree diagram showing a series of operations needed to solve a four-disk Tower of Hanoi. The root node, “Solve 4,” branches into three nodes: one representing the move necessary to place the fourth disk in the correct spot, “Move 4,” and two “Solve 3” nodes. Each “Solve 3” node branches into its own series of nodes representing moves and steps." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-451" class="linkurl">Figure 3-5</a>: The series of operations for solving a four-disk Tower of Hanoi</p></figcaption>
</figure>
<p class="calibre22">Let’s ask ourselves the three questions for creating a recursive solution:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case? </span>  Solving a tower of one disk.</li>
<li class="calibre9"><span class="runinhead">What argument is passed to the recursive function call? </span>  Solving a tower of size one less than the current size.</li>
<li class="calibre9"><span class="runinhead">How does this argument become closer to the base case? </span>  The size of the tower to solve decreases by one disk for each recursive call until it is a one-disk tower.</li>
</ol>
<p class="calibre22">The following <em class="calibre10">towerOfHanoiSolver.py</em> program solves the Tower of Hanoi puzzle and displays a visualization of each step:</p>
<pre class="calibre23">import sys<br class="calibre49" /><br class="calibre49" /># Set up towers A, B, and C. The end of the list is the top of the tower.<br class="calibre49" />  TOTAL_DISKS = 6 <span class="codeannotationcode" aria-label="annotation1">❶</span><br class="calibre49" /><br class="calibre49" /># Populate Tower A:<br class="calibre49" />  TOWERS = {'A': list(reversed(range(1, TOTAL_DISKS + 1))), <span class="codeannotationcode" aria-label="annotation2">❷</span><br class="calibre49" />          'B': [],<br class="calibre49" />          'C': []}<br class="calibre49" /><br class="calibre49" />def printDisk(diskNum):<br class="calibre49" />    # Print a single disk of width diskNum.<br class="calibre49" />    emptySpace = ' ' * (TOTAL_DISKS - diskNum)<br class="calibre49" />    if diskNum == 0:<br class="calibre49" />        # Just draw the pole.<br class="calibre49" />        sys.stdout.write(emptySpace + '||' + emptySpace)<br class="calibre49" />    else:<br class="calibre49" />        # Draw the disk.<br class="calibre49" />        diskSpace = '@' * diskNum<br class="calibre49" />        diskNumLabel = str(diskNum).rjust(2, '_')<br class="calibre49" />        sys.stdout.write(emptySpace + diskSpace + diskNumLabel + diskSpace + emptySpace)<br class="calibre49" /><br class="calibre49" />def printTowers():<br class="calibre49" />    # Print all three towers.<br class="calibre49" /><span type="pagebreak" title="57" id="calibre_link-183" class="calibre17"></span>    for level in range(TOTAL_DISKS, -1, -1):<br class="calibre49" />        for tower in (TOWERS['A'], TOWERS['B'], TOWERS['C']):<br class="calibre49" />            if level &gt;= len(tower):<br class="calibre49" />                printDisk(0)<br class="calibre49" />            else:<br class="calibre49" />                printDisk(tower[level])<br class="calibre49" />        sys.stdout.write('\n')<br class="calibre49" />    # Print the tower labels A, B, and C.<br class="calibre49" />    emptySpace = ' ' * (TOTAL_DISKS)<br class="calibre49" />    print('%s A%s%s B%s%s C\n' % (emptySpace, emptySpace, emptySpace, emptySpace, emptySpace))<br class="calibre49" /><br class="calibre49" />def moveOneDisk(startTower, endTower):<br class="calibre49" />    # Move the top disk from startTower to endTower.<br class="calibre49" />    disk = TOWERS[startTower].pop()<br class="calibre49" />    TOWERS[endTower].append(disk)<br class="calibre49" /><br class="calibre49" />def solve(numberOfDisks, startTower, endTower, tempTower):<br class="calibre49" />    # Move the top numberOfDisks disks from startTower to endTower.<br class="calibre49" />    if numberOfDisks == 1:<br class="calibre49" />        # BASE CASE<br class="calibre49" />        moveOneDisk(startTower, endTower) <span class="codeannotationcode" aria-label="annotation3">❸</span><br class="calibre49" />        printTowers()<br class="calibre49" />        return<br class="calibre49" />    else:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />        solve(numberOfDisks - 1, startTower, tempTower, endTower) <span class="codeannotationcode" aria-label="annotation4">❹</span><br class="calibre49" />        moveOneDisk(startTower, endTower) <span class="codeannotationcode" aria-label="annotation5">❺</span><br class="calibre49" />        printTowers()<br class="calibre49" />        solve(numberOfDisks - 1, tempTower, endTower, startTower) <span class="codeannotationcode" aria-label="annotation6">❻</span><br class="calibre49" />        return<br class="calibre49" /><br class="calibre49" /># Solve:<br class="calibre49" />printTowers()<br class="calibre49" />solve(TOTAL_DISKS, 'A', 'B', 'C')<br class="calibre49" /><br class="calibre49" /># Uncomment to enable interactive mode:<br class="calibre49" />#while True:<br class="calibre49" />#    printTowers()<br class="calibre49" />#    print('Enter letter of start tower and the end tower. (A, B, C) Or Q to quit.')<br class="calibre49" />#    move = input().upper()<br class="calibre49" />#    if move == 'Q':<br class="calibre49" />#        sys.exit()<br class="calibre49" />#    elif move[0] in 'ABC' and move[1] in 'ABC' and move[0] != move[1]:<br class="calibre49" />#        moveOneDisk(move[0], move[1])</pre>
<p class="calibre22">This <em class="calibre10">towerOfHanoiSolver.html</em> program contains the equivalent JavaScript code:</p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;<br class="calibre49" />// Set up towers A, B, and C. The end of the array is the top of the tower.<br class="calibre49" />  let TOTAL_DISKS = 6; <span class="codeannotationcode" aria-label="annotation1">❶</span><br class="calibre49" />  let TOWERS = {"A": [], <span class="codeannotationcode" aria-label="annotation2">❷</span><br class="calibre49" />              "B": [],<br class="calibre49" />              "C": []};<br class="calibre49" /><br class="calibre49" /><span type="pagebreak" title="58" id="calibre_link-495" class="calibre17"></span>// Populate Tower A:<br class="calibre49" />for (let i = TOTAL_DISKS; i &gt; 0; i--) {<br class="calibre49" />    TOWERS["A"].push(i);<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />function printDisk(diskNum) {<br class="calibre49" />    // Print a single disk of width diskNum.<br class="calibre49" />    let emptySpace = " ".repeat(TOTAL_DISKS - diskNum);<br class="calibre49" />    if (diskNum === 0) {<br class="calibre49" />        // Just draw the pole.<br class="calibre49" />        document.write(emptySpace + "||" + emptySpace);<br class="calibre49" />    } else {<br class="calibre49" />        // Draw the disk.<br class="calibre49" />        let diskSpace = "@".repeat(diskNum);<br class="calibre49" />        let diskNumLabel = String("___" + diskNum).slice(-2);<br class="calibre49" />        document.write(emptySpace + diskSpace + diskNumLabel + diskSpace + emptySpace);<br class="calibre49" />    }<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />function printTowers() {<br class="calibre49" />    // Print all three towers.<br class="calibre49" />    let towerLetters = "ABC";<br class="calibre49" />    for (let level = TOTAL_DISKS; level &gt;= 0; level--) {<br class="calibre49" />        for (let towerLetterIndex = 0; towerLetterIndex &lt; 3; towerLetterIndex++) {<br class="calibre49" />            let tower = TOWERS[towerLetters[towerLetterIndex]];<br class="calibre49" />            if (level &gt;= tower.length) {<br class="calibre49" />                printDisk(0);<br class="calibre49" />            } else {<br class="calibre49" />                printDisk(tower[level]);<br class="calibre49" />            }<br class="calibre49" />        }<br class="calibre49" />        document.write("&lt;br /&gt;");<br class="calibre49" />    }<br class="calibre49" />    // Print the tower labels A, B, and C.<br class="calibre49" />    let emptySpace = " ".repeat(TOTAL_DISKS);<br class="calibre49" />    document.write(emptySpace + " A" + emptySpace + emptySpace +<br class="calibre49" />" B" + emptySpace + emptySpace + " C&lt;br /&gt;&lt;br /&gt;");<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />function moveOneDisk(startTower, endTower) {<br class="calibre49" />    // Move the top disk from startTower to endTower.<br class="calibre49" />    let disk = TOWERS[startTower].pop();<br class="calibre49" />    TOWERS[endTower].push(disk);<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />function solve(numberOfDisks, startTower, endTower, tempTower) {<br class="calibre49" />    // Move the top numberOfDisks disks from startTower to endTower.<br class="calibre49" />    if (numberOfDisks == 1) {<br class="calibre49" />        // BASE CASE<br class="calibre49" />        moveOneDisk(startTower, endTower); <span class="codeannotationcode" aria-label="annotation3">❸</span><br class="calibre49" />        printTowers();<br class="calibre49" />        return;<br class="calibre49" />    } else {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />        solve(numberOfDisks - 1, startTower, tempTower, endTower); <span class="codeannotationcode" aria-label="annotation4">❹</span><br class="calibre49" /><span type="pagebreak" title="59" id="calibre_link-496" class="calibre17"></span>        moveOneDisk(startTower, endTower); <span class="codeannotationcode" aria-label="annotation5">❺</span><br class="calibre49" />        printTowers();<br class="calibre49" />        solve(numberOfDisks - 1, tempTower, endTower, startTower); <span class="codeannotationcode" aria-label="annotation6">❻</span><br class="calibre49" />        return;<br class="calibre49" />    }<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />// Solve:<br class="calibre49" />document.write("&lt;pre&gt;");<br class="calibre49" />printTowers();<br class="calibre49" />solve(TOTAL_DISKS, "A", "B", "C");<br class="calibre49" />document.write("&lt;/pre&gt;");<br class="calibre49" />&lt;/script&gt;</pre>
<p class="calibre22">When you run this code, the output shows each move of the disks until the entire tower has moved from Tower A to Tower B:</p>
<pre class="calibre23">      ||            ||            ||      <br class="calibre49" />     @_1@           ||            ||      <br class="calibre49" />    @@_2@@          ||            ||      <br class="calibre49" />   @@@_3@@@         ||            ||      <br class="calibre49" />  @@@@_4@@@@        ||            ||      <br class="calibre49" /> @@@@@_5@@@@@       ||            ||      <br class="calibre49" />@@@@@@_6@@@@@@      ||            ||      <br class="calibre49" />       A             B             C<br class="calibre49" /><br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||            ||            ||      <br class="calibre49" />    @@_2@@          ||            ||      <br class="calibre49" />   @@@_3@@@         ||            ||      <br class="calibre49" />  @@@@_4@@@@        ||            ||      <br class="calibre49" /> @@@@@_5@@@@@       ||            ||      <br class="calibre49" />@@@@@@_6@@@@@@      ||           @_1@     <br class="calibre49" />       A             B             C<br class="calibre49" /><var class="calibre13">--snip--</var><br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||          @@_2@@          ||      <br class="calibre49" />     @_1@        @@@_3@@@         ||      <br class="calibre49" />@@@@@@_6@@@@@@  @@@@_4@@@@   @@@@@_5@@@@@ <br class="calibre49" /><var class="calibre13">--snip--</var><br class="calibre49" />       A             B             C<br class="calibre49" />      ||            ||            ||      <br class="calibre49" />      ||           @_1@           ||      <br class="calibre49" />      ||          @@_2@@          ||      <br class="calibre49" />      ||         @@@_3@@@         ||      <br class="calibre49" />      ||        @@@@_4@@@@        ||      <br class="calibre49" />      ||       @@@@@_5@@@@@       ||      <br class="calibre49" />      ||      @@@@@@_6@@@@@@      ||      <br class="calibre49" />       A             B             C</pre>
<p class="calibre22"><span type="pagebreak" title="60" id="calibre_link-109" class="calibre17"></span>The Python version has an interactive mode too, where you can solve the puzzle yourself. Uncomment the lines of code at the end of <em class="calibre10">towerOfHanoiSolver.py</em> to play the interactive version.</p>
<p class="calibre22">You can start by running the program with the smaller cases by setting the <code class="calibre11">TOTAL_DISKS</code> constant <span class="codeannotation" aria-label="annotation1">❶</span> at the top of the program to <code class="calibre11">1</code> or <code class="calibre11">2</code>. In our program, a list of integers in Python and an array of integers in JavaScript represent a pole. The integer represents a disk, with larger integers representing larger disks. The integer at the start of the list or array is at the bottom of the pole, and the integer at the end is at the pole’s top. For example, <code class="calibre11">[6, 5, 4, 3, 2, 1]</code> represents the starting pole with six disks with the largest on the bottom, while <code class="calibre11">[]</code> represents a pole with no disks. The <code class="calibre11">TOWERS</code> variable contains three of these lists <span class="codeannotation" aria-label="annotation2">❷</span>.</p>
<p class="calibre22">The base case merely moves the smallest disk from the start pole to the end pole <span class="codeannotation" aria-label="annotation3">❸</span>. The recursive case for a tower of <em class="calibre10">n</em> disks carries out three steps: solving the <em class="calibre10">n</em> &ndash; 1 case <span class="codeannotation" aria-label="annotation4">❹</span>, moving the <em class="calibre10">n</em>th disk <span class="codeannotation" aria-label="annotation5">❺</span>, and then solving the <em class="calibre10">n</em> &ndash; 1 case again <span class="codeannotation" aria-label="annotation6">❻</span>.</p>
<h2 id="calibre_link-284" class="calibre6">Using Flood Fill</h2>
<p class="bodyfirst">Graphics programs commonly use the <em class="calibre10">flood fill algorithm</em> to fill an arbitrarily shaped area of the same color with another color. <a href="#calibre_link-452" class="linkurl">Figure 3-6</a> shows one such shape at the top left. The subsequent panels show three different sections of the shape flood-filled with a gray color. The flood fill begins on a white pixel and spreads until it meets a non-white pixel, filling the enclosed space.</p>
<p class="calibre22">The flood fill algorithm is recursive: it begins by changing a single pixel to a new color. The recursive function is then called on any neighbors of the pixel with its same old color. It then moves on to the neighbors of the neighbors, and so on, converting each pixel to the new color until the enclosed space is filled in. </p>
<p class="calibre22">The base case is a pixel whose color is the edge of the image or is not the old color. Since reaching the base case is the only way to stop the “spread” of recursive calls for every pixel in the image, this algorithm has the emergent behavior of changing all the contiguous pixels from the old color to the new color.</p>
<p class="calibre22">Let’s ask the three recursive algorithm questions about our <code class="calibre11">floodFill()</code> function:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case?</span>  When the x- and y-coordinates are for a pixel that is not the old color, or are at the edge of the image.</li>
<li class="calibre9"><span class="runinhead">What arguments are passed to the recursive function call?</span>  The x- and y-coordinates of the four neighboring pixels of the current pixel are the arguments to four recursive calls.</li>
<li class="calibre9"><span class="runinhead">How do these arguments become closer to the base case?</span>  The neighboring pixels run up to a different color than the old color or the edge of the image. Either way, eventually the algorithm runs out of pixels to check.</li>
</ol>
<span type="pagebreak" title="61" id="calibre_link-111" class="calibre17"></span><figure class="calibre25">
<img src="images/000052.webp" class="calibre16" alt="Four screenshots of MS Paint windows containing the same abstract, squiggly shape. Each screenshot shows a different closed portion of the drawing colored gray." />
<figcaption class="calibre26"><p class="calibre27"><a id="calibre_link-452" class="linkurl">Figure 3-6</a>: The original shape in a graphics editor (top left) and the same shape with three different areas flood-filled with a light gray color</p></figcaption>
</figure>
<p class="calibre22">Instead of an image for our sample program, we’ll use a list of single-character strings to form a 2D grid of text characters to represent an “image.” Each string represents a “pixel,” and the specific character represents the “color.” The <em class="calibre10">floodfill.py</em> Python program implements the flood fill algorithm, the image data, and a function to print the image on the screen:</p>
<p class="codelabel"><b class="calibre7">Python</b></p>
<pre class="calibre23">import sys<br class="calibre49" /><br class="calibre49" /># Create the image (make sure it's rectangular!)<br class="calibre49" /><span class="codeannotationhang" aria-label="annotation1">❶</span> im = [list('..########################...........'),<br class="calibre49" />      list('..#......................#...#####...'),<br class="calibre49" />      list('..#..........########....#####...#...'),<br class="calibre49" />      list('..#..........#......#............#...'),<br class="calibre49" />      list('..#..........########.........####...'),<br class="calibre49" />      list('..######......................#......'),<br class="calibre49" />      list('.......#..#####.....###########......'),<br class="calibre49" />      list('.......####...#######................')]<br class="calibre49" /><br class="calibre49" />HEIGHT = len(im)<br class="calibre49" /><span type="pagebreak" title="62" id="calibre_link-110" class="calibre17"></span>WIDTH = len(im[0])<br class="calibre49" /><br class="calibre49" />def floodFill(image, x, y, newChar, oldChar=None):<br class="calibre49" />    if oldChar == None:<br class="calibre49" />        # oldChar defaults to the character at x, y.<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> oldChar = image[y][x]<br class="calibre49" />    if oldChar == newChar or image[y][x] != oldChar:<br class="calibre49" />        # BASE CASE<br class="calibre49" />        return<br class="calibre49" /><br class="calibre49" />    image[y][x] = newChar # Change the character.<br class="calibre49" /><br class="calibre49" />    # Uncomment to view each step:<br class="calibre49" />    #printImage(image)<br class="calibre49" /><br class="calibre49" />    # Change the neighboring characters.<br class="calibre49" />    if y + 1 &lt; HEIGHT and image[y + 1][x] == oldChar:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> floodFill(image, x, y + 1, newChar, oldChar)<br class="calibre49" />    if y - 1 &gt;= 0 and image[y - 1][x] == oldChar:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation4">❹</span> floodFill(image, x, y - 1, newChar, oldChar)<br class="calibre49" />    if x + 1 &lt; WIDTH and image[y][x + 1] == oldChar:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation5">❺</span> floodFill(image, x + 1, y, newChar, oldChar)<br class="calibre49" />    if x - 1 &gt;= 0 and image[y][x - 1] == oldChar:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation6">❻</span> floodFill(image, x - 1, y, newChar, oldChar)<br class="calibre49" />  <span class="codeannotationcode" aria-label="annotation7">❼</span> return # BASE CASE<br class="calibre49" /><br class="calibre49" />def printImage(image):<br class="calibre49" />    for y in range(HEIGHT):<br class="calibre49" />        # Print each row.<br class="calibre49" />        for x in range(WIDTH):<br class="calibre49" />            # Print each column.<br class="calibre49" />            sys.stdout.write(image[y][x])<br class="calibre49" />        sys.stdout.write('\n')<br class="calibre49" />    sys.stdout.write('\n')<br class="calibre49" /><br class="calibre49" />printImage(im)<br class="calibre49" />floodFill(im, 3, 3, 'o')<br class="calibre49" />printImage(im)</pre>
<p class="calibre22">The <em class="calibre10">floodfill.html</em> program contains the equivalent JavaScript code:</p>
<p class="codelabel"><b class="calibre7">JavaScript</b></p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;<br class="calibre49" />// Create the image (make sure it's rectangular!)<br class="calibre49" /><span class="codeannotationhang" aria-label="annotation1">❶</span> let im = ["..########################...........".split(""),<br class="calibre49" />          "..#......................#...#####...".split(""),<br class="calibre49" />          "..#..........########....#####...#...".split(""),<br class="calibre49" />          "..#..........#......#............#...".split(""),<br class="calibre49" />          "..#..........########.........####...".split(""),<br class="calibre49" />          "..######......................#......".split(""),<br class="calibre49" />          ".......#..#####.....###########......".split(""),<br class="calibre49" />          ".......####...#######................".split("")];<br class="calibre49" /><br class="calibre49" /><span type="pagebreak" title="63" id="calibre_link-497" class="calibre17"></span>let HEIGHT = im.length;<br class="calibre49" />let WIDTH = im[0].length;<br class="calibre49" /><br class="calibre49" />function floodFill(image, x, y, newChar, oldChar) {<br class="calibre49" />    if (oldChar === undefined) {<br class="calibre49" />        // oldChar defaults to the character at x, y.<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation2">❷</span> oldChar = image[y][x];<br class="calibre49" />    }<br class="calibre49" />    if ((oldChar == newChar) || (image[y][x] != oldChar)) {<br class="calibre49" />        // BASE CASE<br class="calibre49" />        return;<br class="calibre49" />    }<br class="calibre49" /><br class="calibre49" />    image[y][x] = newChar; // Change the character.<br class="calibre49" /><br class="calibre49" />    // Uncomment to view each step:<br class="calibre49" />    //printImage(image);<br class="calibre49" /><br class="calibre49" />    // Change the neighboring characters.<br class="calibre49" />    if ((y + 1 &lt; HEIGHT) &amp;&amp; (image[y + 1][x] == oldChar)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation3">❸</span> floodFill(image, x, y + 1, newChar, oldChar);<br class="calibre49" />    }<br class="calibre49" />    if ((y - 1 &gt;= 0) &amp;&amp; (image[y - 1][x] == oldChar)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation4">❹</span> floodFill(image, x, y - 1, newChar, oldChar);<br class="calibre49" />    }<br class="calibre49" />    if ((x + 1 &lt; WIDTH) &amp;&amp; (image[y][x + 1] == oldChar)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation5">❺</span> floodFill(image, x + 1, y, newChar, oldChar);<br class="calibre49" />    }<br class="calibre49" />    if ((x - 1 &gt;= 0) &amp;&amp; (image[y][x - 1] == oldChar)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />      <span class="codeannotationcode" aria-label="annotation6">❻</span> floodFill(image, x - 1, y, newChar, oldChar);<br class="calibre49" />    }<br class="calibre49" />  <span class="codeannotationcode" aria-label="annotation7">❼</span> return; // BASE CASE<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />function printImage(image) {<br class="calibre49" />    document.write("&lt;pre&gt;");<br class="calibre49" />    for (let y = 0; y &lt; HEIGHT; y++) {<br class="calibre49" />        // Print each row.<br class="calibre49" />        for (let x = 0; x &lt; WIDTH; x++) {<br class="calibre49" />            // Print each column.<br class="calibre49" />            document.write(image[y][x]);<br class="calibre49" />        }<br class="calibre49" />        document.write("\n");<br class="calibre49" />    }<br class="calibre49" />    document.write("\n&lt;/pre&gt;");<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />printImage(im);<br class="calibre49" />floodFill(im, 3, 3, "o");<br class="calibre49" />printImage(im);<br class="calibre49" />&lt;/script&gt;</pre>
<p class="calibre22"><span type="pagebreak" title="64" id="calibre_link-498" class="calibre17"></span>When you run this code, the program fills the interior of the shape drawn by the <code class="calibre11">#</code> characters <span class="codeannotation" aria-label="annotation1">❶</span> starting at coordinates 3, 3. It replaces all the period characters (<code class="calibre11">.</code>) with <code class="calibre11">o</code> characters. The following output shows the before and after images:</p>
<pre class="calibre23">..########################...........<br class="calibre49" />..#......................#...#####...<br class="calibre49" />..#..........########....#####...#...<br class="calibre49" />..#..........#......#............#...<br class="calibre49" />..#..........########.........####...<br class="calibre49" />..######......................#......<br class="calibre49" />.......#..#####.....###########......<br class="calibre49" />.......####...#######................<br class="calibre49" /><br class="calibre49" />..########################...........<br class="calibre49" />..#oooooooooooooooooooooo#...#####...<br class="calibre49" />..#oooooooooo########oooo#####ooo#...<br class="calibre49" />..#oooooooooo#......#oooooooooooo#...<br class="calibre49" />..#oooooooooo########ooooooooo####...<br class="calibre49" />..######oooooooooooooooooooooo#......<br class="calibre49" />.......#oo#####ooooo###########......<br class="calibre49" />.......####...#######................</pre>
<p class="calibre22">If you want to see every step of the flood fill algorithm as it fills in the new character, uncomment the <code class="calibre11">printImage(image)</code> line in the <code class="calibre11">floodFill()</code> function and run the program again.</p>
<p class="calibre22">The image is represented by a 2D array of string characters. We can pass this <code class="calibre11">image</code> data structure, an <code class="calibre11">x</code> coordinate and a <code class="calibre11">y</code> coordinate, and a new character to the <code class="calibre11">floodFill()</code> function. The function notes the character currently at the <code class="calibre11">x</code> and <code class="calibre11">y</code> coordinates and saves it to the <code class="calibre11">oldChar</code> variable <span class="codeannotation" aria-label="annotation2">❷</span>.</p>
<p class="calibre22">If the current characters at coordinates <code class="calibre11">x</code> and <code class="calibre11">y</code> in <code class="calibre11">image</code> are not the same as <code class="calibre11">oldChar</code>, this is our base case, and the function simply returns. Otherwise, the function continues on to its four recursive cases: passing the x- and y-coordinates of the bottom <span class="codeannotation" aria-label="annotation3">❸</span>, top <span class="codeannotation" aria-label="annotation4">❹</span>, right <span class="codeannotation" aria-label="annotation5">❺</span>, and left <span class="codeannotation" aria-label="annotation6">❻</span> neighbors of the current coordinates. After these four potential recursive calls are made, the end of the function is an implicit base case, made explicit in our program with a <code class="calibre11">return</code> statement <span class="codeannotation" aria-label="annotation7">❼</span>.</p>
<p class="calibre22">The flood fill algorithm doesn’t have to be recursive. For large images, a recursive function could cause stack overflows. If we were to implement flood fill with a loop and a stack instead, the stack would begin with the x- and y-coordinates of the starting pixel. The code in the loop would pop the coordinates off the top of the stack, and if that coordinate’s pixel matches <code class="calibre11">oldChar</code>, it would push the coordinates of the four neighboring pixels. When the stack is empty because the base case is no longer pushing neighbors to the stack, the loop is finished.</p>
<p class="calibre22">However, the flood fill algorithm doesn’t necessarily have to use a stack. The pushing and popping of a first-in, last-out stack is effective for backtracking behavior, but the order that the pixels are processed in the flood fill algorithm can be arbitrary. This means we could equally effectively use a set data structure that removes elements randomly. You can <span type="pagebreak" title="65" id="calibre_link-29" class="calibre17"></span>find these iterative flood fill algorithms implemented in <em class="calibre10">floodFillIterative.py</em> and <em class="calibre10">floodFillIterative.html</em> in the downloadable resources at <a href="https://nostarch.com/recursive-book-recursion" class="linkurl">https://nostarch.com/recursive-book-recursion</a>.</p>
<h2 id="calibre_link-285" class="calibre6">Using the Ackermann Function</h2>
<p class="bodyfirst">The <em class="calibre10">Ackermann function</em> is named after its discoverer, Wilhelm Ackermann. A student of mathematician David Hilbert (whose Hilbert curve fractal we discuss in <span class="calibre" itemid="xref_target_Chapter 9">Chapter 9</span>), Ackermann published his function in 1928. Mathematicians Rózsa Péter and Raphael Robinson later developed the version of the function featured in this section. </p>
<p class="calibre22">While the Ackermann function has some application in advanced mathematics, it is mostly known for being an example of a highly recursive function. Even slight increases to its two integer arguments cause a large increase in the number of recursive calls it makes.</p>
<p class="calibre22">The Ackermann function takes two arguments, <code class="calibre11">m</code> and <code class="calibre11">n</code>, and has a base case of returning <code class="calibre11">n + 1</code> when <code class="calibre11">m</code> is <code class="calibre11">0</code>. There are two recursive cases: when <code class="calibre11">n</code> is <code class="calibre11">0</code>, the function returns <code class="calibre11">ackermann(m - 1, 1)</code>, and when <code class="calibre11">n</code> is greater than <code class="calibre11">0</code>, the function returns <code class="calibre11">ackermann(m - 1, ackermann(m, n - 1))</code>. These cases likely aren’t meaningful to you, but suffice it to say, the number of recursive calls the Ackermann function makes grows quickly. Calling <code class="calibre11">ackermann(1, 1)</code> results in three recursive function calls. Calling <code class="calibre11">ackermann(2, 3)</code> results in 43 recursive function calls. Calling <code class="calibre11">ackermann(3, 5)</code> results in 42,437 recursive function calls. And calling <code class="calibre11">ackermann(5, 7)</code> results in . . . well, actually I don’t know how many recursive function calls, because it would take several times the age of the universe to calculate.</p>
<p class="calibre22">Let’s answer the three questions we ask when constructing recursive algorithms:</p>
<ol class="none">
<li class="calibre9"><span class="runinhead">What is the base case?</span>  When <code class="calibre11">m</code> is <code class="calibre11">0</code>.</li>
<li class="calibre9"><span class="runinhead">What arguments are passed to the recursive function call?</span>  Either <code class="calibre11">m</code> or <code class="calibre11">m - 1</code> is passed for the next <code class="calibre11">m</code> parameter; and <code class="calibre11">1</code>, <code class="calibre11">n - 1</code>, or the return value of <code class="calibre11">ackermann(m, n - 1)</code> is passed for the next <code class="calibre11">n</code> parameter.</li>
<li class="calibre9"><span class="runinhead">How do these arguments become closer to the base case?</span>  The <code class="calibre11">m</code> argument is always either decreasing or staying the same size, so it will eventually reach <code class="calibre11">0</code>.</li>
</ol>
<p class="calibre22">Here is an <em class="calibre10">ackermann.py</em> Python program:</p>
<pre class="calibre23">def ackermann(m, n, indentation=None):<br class="calibre49" />    if indentation is None:<br class="calibre49" />        indentation = 0<br class="calibre49" />    print('%sackermann(%s, %s)' % (' ' * indentation, m, n))<br class="calibre49" /><br class="calibre49" />    if m == 0:<br class="calibre49" />        # BASE CASE<br class="calibre49" />        return n + 1<br class="calibre49" />    elif m &gt; 0 and n == 0:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" /><span type="pagebreak" title="66" id="calibre_link-30" class="calibre17"></span>        return ackermann(m - 1, 1, indentation + 1)<br class="calibre49" />    elif m &gt; 0 and n &gt; 0:<br class="calibre49" />        # RECURSIVE CASE<br class="calibre49" />        return ackermann(m - 1, ackermann(m, n - 1, indentation + 1), indentation + 1)<br class="calibre49" /><br class="calibre49" />print('Starting with m = 1, n = 1:')<br class="calibre49" />print(ackermann(1, 1))<br class="calibre49" />print('Starting with m = 2, n = 3:')<br class="calibre49" />print(ackermann(2, 3))</pre>
<p class="calibre22">And here is the equivalent <em class="calibre10">ackermann.html</em> JavaScript program:</p>
<pre class="calibre23">&lt;script type="text/javascript"&gt;<br class="calibre49" />function ackermann(m, n, indentation) {<br class="calibre49" />    if (indentation === undefined) {<br class="calibre49" />        indentation = 0;<br class="calibre49" />    }<br class="calibre49" />    document.write(" ".repeat(indentation) + "ackermann(" + m + ", " + n + ")\n");<br class="calibre49" /><br class="calibre49" />    if (m === 0) {<br class="calibre49" />        // BASE CASE<br class="calibre49" />        return n + 1;<br class="calibre49" />    } else if ((m &gt; 0) &amp;&amp; (n === 0)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />        return ackermann(m - 1, 1, indentation + 1);<br class="calibre49" />    } else if ((m &gt; 0) &amp;&amp; (n &gt; 0)) {<br class="calibre49" />        // RECURSIVE CASE<br class="calibre49" />        return ackermann(m - 1, ackermann(m, n - 1, indentation + 1), indentation + 1);<br class="calibre49" />    }<br class="calibre49" />}<br class="calibre49" /><br class="calibre49" />document.write("&lt;pre&gt;");<br class="calibre49" />document.write("Starting with m = 1, n = 1:&lt;br /&gt;");<br class="calibre49" />document.write(ackermann(1, 1) + "&lt;br /&gt;");<br class="calibre49" />document.write("Starting with m = 2, n = 3:&lt;br /&gt;");<br class="calibre49" />document.write(ackermann(2, 3) + "&lt;br /&gt;");<br class="calibre49" />document.write("&lt;/pre&gt;");<br class="calibre49" />&lt;/script&gt;</pre>
<p class="calibre22">When you run this code, the output’s indentation (set by the <code class="calibre11">indentation</code> argument) tells you how deep on the call stack the given recursive function call is:</p>
<pre class="calibre23">Starting with m = 1, n = 1:<br class="calibre49" />ackermann(1, 1)<br class="calibre49" /> ackermann(1, 0)<br class="calibre49" />  ackermann(0, 1)<br class="calibre49" /> ackermann(0, 2)<br class="calibre49" />3<br class="calibre49" />Starting with m = 2, n = 3:<br class="calibre49" />ackermann(2, 3)<br class="calibre49" /> ackermann(2, 2)<br class="calibre49" />  ackermann(2, 1)<br class="calibre49" />   ackermann(2, 0)<br class="calibre49" /><var class="calibre13"><span type="pagebreak" title="67" id="calibre_link-31" class="calibre17"></span>--snip--</var><br class="calibre49" />    ackermann(0, 6)<br class="calibre49" />   ackermann(0, 7)<br class="calibre49" />  ackermann(0, 8)<br class="calibre49" />9</pre>
<p class="calibre22">You can also try <code class="calibre11">ackermann(3, 3)</code>, but anything with larger arguments will probably take far too long to calculate. To speed up the calculation, try commenting out all <code class="calibre11">print()</code> and <code class="calibre11">document.write()</code> calls except the ones that print the final return value of <code class="calibre11">ackermann()</code>.</p>
<p class="calibre22">Remember, even a recursive algorithm like the Ackermann function can be implemented as an iterative function. The iterative Ackermann algorithms are implemented in <em class="calibre10">ackermannIterative.py</em> and <em class="calibre10">ackermannIterative.html</em> in the downloadable resources at <a href="https://nostarch.com/recursive-book-recursion" class="linkurl">https://nostarch.com/recursive-book-recursion</a>.</p>
<h2 id="calibre_link-286" class="calibre6">Summary</h2>
<p class="bodyfirst">This chapter covered some classic recursive algorithms. For each, we asked the three important questions you should always ask when designing your own recursive functions: What is the base case? What arguments are passed to the recursive function call? How do these arguments become closer to the base case? If they don’t, your function will continue to recurse until it causes a stack overflow.</p>
<p class="calibre22">The summation, string reversing, and palindrome detection recursive functions could have easily been implemented with a simple loop. The key giveaway is that they all make a single pass through the data given to them with no backtracking. As explained in <span class="calibre" itemid="xref_target_Chapter 2">Chapter 2</span>, recursive algorithms are especially suited to problems that involve a tree-like structure and require backtracking. </p>
<p class="calibre22">The tree-like structures for solving the Tower of Hanoi puzzle suggest that it involves backtracking, as the program execution runs from top to bottom, left to right, in the tree. This makes it a prime candidate for recursion, especially since the solution requires two recursive calls of smaller towers.</p>
<p class="calibre22">The flood fill algorithm is directly applicable to graphics and drawing programs, as well as other algorithms to detect the shape of contiguous areas. If you’ve used the paint-bucket tool in a graphics program, you’ve likely used a version of the flood fill algorithm.</p>
<p class="calibre22">The Ackermann function is an excellent example of how quickly a recursive function can grow as its inputs increase. While it doesn’t have many practical applications in day-to-day programming, no discussion about recursion would be complete without it. But as recursive as it is, like all recursive functions it can be implemented iteratively with a loop and a stack.</p>
<h2 id="calibre_link-287" class="calibre6">Further Reading</h2>
<p class="bodyfirst">Wikipedia has more information on the Tower of Hanoi problem at <a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" class="linkurl">https://en.wikipedia.org/wiki/Tower_of_Hanoi</a>, and the Computerphile video <span type="pagebreak" title="68" id="calibre_link-121" class="calibre17"></span>“Recursion ‘Super Power’ (in Python)” covers solving the Tower of Hanoi in Python at <a href="https://youtu.be/8lhxIOAfDss" class="linkurl">https://youtu.be/8lhxIOAfDss</a>. The 3Blue1Brown two-part video series, “Binary, Hanoi, and Sierpiński,” goes into even more detail by exploring the relationships among the Tower of Hanoi, binary numbers, and the Sierpiński Triangle fractal starting at <a href="https://youtu.be/2SUvWfNJSsM" class="linkurl">https://youtu.be/2SUvWfNJSsM</a>.</p>
<p class="calibre22">Wikipedia has an animation of the flood fill algorithm working on a small image at <a href="https://en.wikipedia.org/wiki/Flood_fill" class="linkurl">https://en.wikipedia.org/wiki/Flood_fill</a>.</p>
<p class="calibre22">The Computerphile video “The Most Difficult Program to Compute?” discusses the Ackermann function at <a href="https://youtu.be/i7sm9dzFtEI" class="linkurl">https://youtu.be/i7sm9dzFtEI</a>. If you’d like to learn more about the Ackermann function’s place in computability theory, the Hackers in Cambridge channel has a five-part video series on primitive recursive and partial recursive functions at <a href="https://youtu.be/yaDQrOUK-KY" class="linkurl">https://youtu.be/yaDQrOUK-KY</a>. The series requires a lot of mathematical thinking on the part of the viewer, but you don’t need a lot of prior mathematical knowledge.</p>
<h2 id="calibre_link-288" class="calibre6"> Practice Questions</h2>
<p class="bodyfirst">Test your comprehension by answering the following questions:</p>
<ol class="decimal">
<li value="1" class="calibre9">What is the head of an array or string?</li>
<li value="2" class="calibre9">What is the tail of an array or string?</li>
<li value="3" class="calibre9">What are the three questions this chapter presents for each recursive algorithm?</li>
<li value="4" class="calibre9">What is the leap of faith in recursion?</li>
<li value="5" class="calibre9">What do you need to understand about the recursive function you are writing before you can take a leap of faith?</li>
<li value="6" class="calibre9">How does a linear data structure such as an array or string resemble a tree-like structure?</li>
<li value="7" class="calibre9">Does the recursive <code class="calibre11">sum()</code> function involve any backtracking over the data it works on?</li>
<li value="8" class="calibre9">In the flood fill program, try changing the <code class="calibre11">im</code> variable’s strings to create a <em class="calibre10">C</em> shape that is not fully enclosed. What happens when you attempt to flood-fill the image from the middle of the <em class="calibre10">C</em>?</li>
<li value="9" class="calibre9">Answer the three questions about recursive solutions for each of the recursive algorithms presented in this chapter:
<ol class="lower-alpha">
<li value="1" class="calibre9">What is the base case? </li>
<li value="2" class="calibre9">What argument is passed to the recursive function call? </li>
<li value="3" class="calibre9">How does this argument become closer to the base case? </li>
</ol>
<p class="bodyfirst">Then re-create the recursive algorithms from this chapter without looking at the original code.</p></li>
</ol>
<h2 id="calibre_link-289" class="calibre6"><span type="pagebreak" title="69" id="calibre_link-499" class="calibre20"></span>Practice Projects</h2>
<p class="bodyfirst">For practice, write a function for each of the following tasks:</p>
<ol class="decimal">
<li value="1" class="calibre9">Using the head-tail technique, create a recursive <code class="calibre11">concat()</code> function that is passed an array of strings and returns these strings concatenated together into a single string. For example, <code class="calibre11">concat(['Hello', 'World'])</code> should return <code class="calibre11">HelloWorld</code>.</li>
<li value="2" class="calibre9">Using the head-tail technique, create a recursive <code class="calibre11">product()</code> function that is passed an array of integers and returns the total multiplied product of them. This code will be almost identical to the <code class="calibre11">sum()</code> function in this chapter. However, note that the base case of an array with just one integer returns the integer, and the base case of an empty array returns <code class="calibre11">1</code>.</li>
<li value="3" class="calibre9">Using the flood fill algorithm, count the number of “rooms,” or enclosed spaces, in a 2D grid. You can do this by creating nested <code class="calibre11">for</code> loops that call the flood fill function on each character in the grid if it is a period, in order to change the periods into hash characters. For example, the following data would result in the program finding six places in the grid with periods, meaning there are five rooms (and the space outside all the rooms).
<pre class="calibre23">...##########....................................<br class="calibre49" />...#........#....####..................##########<br class="calibre49" />...#........#....#..#...############...#........#<br class="calibre49" />...##########....#..#...#..........#...##.......#<br class="calibre49" />.......#....#....####...#..........#....##......#<br class="calibre49" />.......#....#....#......############.....##.....#<br class="calibre49" />.......######....#........................##....#<br class="calibre49" />.................####........####..........######</pre></li>
</ol>
</section>
</div>


<div><a href="chapter2.html">Prev: Chapter 2 - Recursion vs. Iteration</a> | <a href="chapter4.html">Next: Chapter 4 - Backtracking and Tree Traversal Algorithms</a></div></body></html>