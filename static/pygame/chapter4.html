<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=UTF-8">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;
	font-weight:normal;}
h1.CxSpFirst
	{mso-style-link:"Heading 1 Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;
	font-weight:normal;}
h1.CxSpMiddle
	{mso-style-link:"Heading 1 Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;
	font-weight:normal;}
h1.CxSpLast
	{mso-style-link:"Heading 1 Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;
	font-weight:normal;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:"Cambria","serif";
	color:black;}
h3
	{mso-style-link:"Heading 3 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:12.0pt;
	font-family:"Cambria","serif";
	color:#4F81BD;}
p.MsoToc1, li.MsoToc1, div.MsoToc1
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoToc2, li.MsoToc2, div.MsoToc2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:11.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoToc3, li.MsoToc3, div.MsoToc3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:22.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoToc4, li.MsoToc4, div.MsoToc4
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:33.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc5, li.MsoToc5, div.MsoToc5
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:44.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc6, li.MsoToc6, div.MsoToc6
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:55.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc7, li.MsoToc7, div.MsoToc7
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:66.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc8, li.MsoToc8, div.MsoToc8
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:77.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoToc9, li.MsoToc9, div.MsoToc9
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:5.0pt;
	margin-left:88.0pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{mso-style-link:"Comment Text Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"Header Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"Footer Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	color:#4F81BD;
	font-weight:bold;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	color:black;
	letter-spacing:.25pt;}
p.MsoTitleCxSpFirst, li.MsoTitleCxSpFirst, div.MsoTitleCxSpFirst
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	color:black;
	letter-spacing:.25pt;}
p.MsoTitleCxSpMiddle, li.MsoTitleCxSpMiddle, div.MsoTitleCxSpMiddle
	{mso-style-link:"Title Char";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	color:black;
	letter-spacing:.25pt;}
p.MsoTitleCxSpLast, li.MsoTitleCxSpLast, div.MsoTitleCxSpLast
	{mso-style-link:"Title Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:48.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	color:black;
	letter-spacing:.25pt;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.MsoCommentSubject, li.MsoCommentSubject, div.MsoCommentSubject
	{mso-style-link:"Comment Subject Char";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	font-weight:bold;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Tahoma","sans-serif";}
span.MsoPlaceholderText
	{color:gray;}
p.MsoRMPane, li.MsoRMPane, div.MsoRMPane
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
p.MsoTocHeading, li.MsoTocHeading, div.MsoTocHeading
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.MsoTocHeadingCxSpFirst, li.MsoTocHeadingCxSpFirst, div.MsoTocHeadingCxSpFirst
	{margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.MsoTocHeadingCxSpMiddle, li.MsoTocHeadingCxSpMiddle, div.MsoTocHeadingCxSpMiddle
	{margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.MsoTocHeadingCxSpLast, li.MsoTocHeadingCxSpLast, div.MsoTocHeadingCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Cambria","serif";
	color:black;
	font-weight:bold;}
span.Heading3Char
	{mso-style-name:"Heading 3 Char";
	mso-style-link:"Heading 3";
	font-family:"Cambria","serif";
	color:#4F81BD;
	font-weight:bold;}
span.TitleChar
	{mso-style-name:"Title Char";
	mso-style-link:Title;
	font-family:"Franklin Gothic Demi","sans-serif";
	color:black;
	letter-spacing:.25pt;}
span.Definition
	{mso-style-name:Definition;
	font-weight:bold;}
span.HeaderChar
	{mso-style-name:"Header Char";
	mso-style-link:Header;
	font-family:"Times New Roman","serif";}
span.FooterChar
	{mso-style-name:"Footer Char";
	mso-style-link:Footer;
	font-family:"Times New Roman","serif";}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-link:"Balloon Text";
	font-family:"Tahoma","sans-serif";}
span.TableHeading
	{mso-style-name:"Table Heading";
	font-weight:bold;}
p.ChapterTitle, li.ChapterTitle, div.ChapterTitle
	{mso-style-name:"Chapter Title";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.ChapterTitleCxSpFirst, li.ChapterTitleCxSpFirst, div.ChapterTitleCxSpFirst
	{mso-style-name:"Chapter TitleCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.ChapterTitleCxSpMiddle, li.ChapterTitleCxSpMiddle, div.ChapterTitleCxSpMiddle
	{mso-style-name:"Chapter TitleCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
p.ChapterTitleCxSpLast, li.ChapterTitleCxSpLast, div.ChapterTitleCxSpLast
	{mso-style-name:"Chapter TitleCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:15.0pt;
	margin-left:0in;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	letter-spacing:.25pt;}
span.URL
	{mso-style-name:URL;
	color:black;
	text-decoration:underline;}
p.SourceCodeFeatured, li.SourceCodeFeatured, div.SourceCodeFeatured
	{mso-style-name:"Source Code \(Featured\)";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.SourceCodeFeaturedCxSpFirst, li.SourceCodeFeaturedCxSpFirst, div.SourceCodeFeaturedCxSpFirst
	{mso-style-name:"Source Code \(Featured\)CxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.SourceCodeFeaturedCxSpMiddle, li.SourceCodeFeaturedCxSpMiddle, div.SourceCodeFeaturedCxSpMiddle
	{mso-style-name:"Source Code \(Featured\)CxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.SourceCodeFeaturedCxSpLast, li.SourceCodeFeaturedCxSpLast, div.SourceCodeFeaturedCxSpLast
	{mso-style-name:"Source Code \(Featured\)CxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.SampleRun, li.SampleRun, div.SampleRun
	{mso-style-name:"Sample Run";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";
	color:#1F497D;}
p.SampleRunCxSpFirst, li.SampleRunCxSpFirst, div.SampleRunCxSpFirst
	{mso-style-name:"Sample RunCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";
	color:#1F497D;}
p.SampleRunCxSpMiddle, li.SampleRunCxSpMiddle, div.SampleRunCxSpMiddle
	{mso-style-name:"Sample RunCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";
	color:#1F497D;}
p.SampleRunCxSpLast, li.SampleRunCxSpLast, div.SampleRunCxSpLast
	{mso-style-name:"Sample RunCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";
	color:#1F497D;}
span.SampleRunResponse
	{mso-style-name:"Sample Run Response";
	color:black;}
span.SourceCodeComment
	{mso-style-name:"Source Code Comment";
	color:#7F7F7F;}
span.SourceLineNumber
	{mso-style-name:"Source Line Number";
	color:gray;}
p.CodeExample, li.CodeExample, div.CodeExample
	{mso-style-name:"Code Example";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.CodeExampleCxSpFirst, li.CodeExampleCxSpFirst, div.CodeExampleCxSpFirst
	{mso-style-name:"Code ExampleCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.CodeExampleCxSpMiddle, li.CodeExampleCxSpMiddle, div.CodeExampleCxSpMiddle
	{mso-style-name:"Code ExampleCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
p.CodeExampleCxSpLast, li.CodeExampleCxSpLast, div.CodeExampleCxSpLast
	{mso-style-name:"Code ExampleCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Courier";}
span.Literal
	{mso-style-name:Literal;
	font-family:Courier;}
p.SourceCodeHeadline, li.SourceCodeHeadline, div.SourceCodeHeadline
	{mso-style-name:"Source Code Headline";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
p.SourceCodeHeadlineCxSpFirst, li.SourceCodeHeadlineCxSpFirst, div.SourceCodeHeadlineCxSpFirst
	{mso-style-name:"Source Code HeadlineCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
p.SourceCodeHeadlineCxSpMiddle, li.SourceCodeHeadlineCxSpMiddle, div.SourceCodeHeadlineCxSpMiddle
	{mso-style-name:"Source Code HeadlineCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
p.SourceCodeHeadlineCxSpLast, li.SourceCodeHeadlineCxSpLast, div.SourceCodeHeadlineCxSpLast
	{mso-style-name:"Source Code HeadlineCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:12.0pt;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
span.CommentTextChar
	{mso-style-name:"Comment Text Char";
	mso-style-link:"Comment Text";
	font-family:"Times New Roman","serif";}
span.CommentSubjectChar
	{mso-style-name:"Comment Subject Char";
	mso-style-link:"Comment Subject";
	font-family:"Times New Roman","serif";
	font-weight:bold;}
span.XXX
	{mso-style-name:XXX;
	font-family:Courier;
	color:red;}
p.TableListing, li.TableListing, div.TableListing
	{mso-style-name:"Table Listing";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";}
.MsoChpDefault
	{font-family:"Calibri","sans-serif";}
.MsoPapDefault
	{margin-bottom:10.0pt;
	line-height:115%;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple style="background-color: #fffeee;">


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">Other programming books by Al Sweigart:<br>
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">X</a>

  <a target="_blank" href="https://www.amazon.com/gp/product/1593275994/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593275994&linkCode=as2&tag=playwithpyth-20&linkId=385b77199fa1e9f4fd21652cc57dab33" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/gp/product/1503212300?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1503212300" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://www.amazon.com/gp/product/1482614375/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1482614375&amp;linkCode=as2&amp;tag=playwithpyth-20" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/gp/product/1593277628/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593277628&linkCode=as2&tag=playwithpyth-20&linkId=0f1bd157c25d2e97db13d6434e5476a8"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://www.udemy.com/automate/?couponCode=INVENT_WITH_PYTHON">Use this link to get 80%% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>




<div class=WordSection1>

<div style='border:none;border-bottom:solid #4F81BD 1.0pt;padding:0in 0in 4.0pt 0in'>

<h1><a name="_Toc316488581"><span style='font-variant:normal !important;
text-transform:uppercase'>Chapter 4 – Slide Puzzle</span></a></h1>

</div>

<p class=MsoNormal align=center style='text-align:center'><img width=286
height=226 id="Picture 47" src="chapter4_files/image001.jpg"></p>

<h2><a name="_Toc316488582">How to Play Slide Puzzle</a></h2>

<p class=MsoNormal>The board is a 4x4 grid with fifteen tiles (numbered 1
through 15 going left to right) and one blank space. The tiles start out in
random positions, and the player must slide tiles around until the tiles are
back in their original order.</p>

<h2><a name="_Toc316488583">Source Code to Slide Puzzle</a></h2>

<p class=MsoNormal>This source code can be downloaded from <span class=URL><a href="http://invpy.com/slidepuzzle.py">http://invpy.com/slidepuzzle.py</a></span>.
If you get any error messages, look at the line number that is mentioned in the
error message and check your code for any typos. You can also copy and paste
your code into the web form at <span class=URL><a href="http://invpy.com/diff/slidepuzzle">http://invpy.com/diff/slidepuzzle</a></span>
to see if the differences between your code and the code in the book.</p>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>  1. </span><span
class=SourceCodeComment># Slide Puzzle</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  2. </span><span
class=SourceCodeComment># By Al Sweigart al@inventwithpython.com</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  3. </span><span
class=SourceCodeComment># http://inventwithpython.com/pygame</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  4. </span><span
class=SourceCodeComment># Creative Commons BY-NC-SA 3.0 US</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  5. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  6. </span>import
pygame, sys, random</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  7. </span>from
pygame.locals import *</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  8. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  9. </span><span
class=SourceCodeComment># Create the constants (go ahead and experiment with
different values)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 10. </span>BOARDWIDTH
= 4  <span class=SourceCodeComment># number of columns in the board</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 11. </span>BOARDHEIGHT
= 4 <span class=SourceCodeComment># number of rows in the board</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 12. </span>TILESIZE
= 80</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 13. </span>WINDOWWIDTH
= 640</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 14. </span>WINDOWHEIGHT
= 480</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 15. </span>FPS
= 30</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 16. </span>BLANK
= None</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 17. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 18. </span><span
class=SourceCodeComment>#                 R    G    B</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 19. </span>BLACK
=         (  0,   0,   0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 20. </span>WHITE
=         (255, 255, 255)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 21. </span>BRIGHTBLUE
=    (  0,  50, 255)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 22. </span>DARKTURQUOISE
= (  3,  54,  73)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 23. </span>GREEN
=         (  0, 204,   0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 24. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 25. </span>BGCOLOR
= DARKTURQUOISE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 26. </span>TILECOLOR
= GREEN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 27. </span>TEXTCOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 28. </span>BORDERCOLOR
= BRIGHTBLUE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 29. </span>BASICFONTSIZE
= 20</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 30. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 31. </span>BUTTONCOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 32. </span>BUTTONTEXTCOLOR
= BLACK</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 33. </span>MESSAGECOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 34. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 35. </span>XMARGIN
= int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / 2)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 36. </span>YMARGIN
= int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - 1))) / 2)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 37. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 38. </span>UP
= 'up'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 39. </span>DOWN
= 'down'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 40. </span>LEFT
= 'left'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 41. </span>RIGHT
= 'right'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 42. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 43. </span>def
main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 44. </span>    global
FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, NEW_SURF, NEW_RECT,
SOLVE_SURF, SOLVE_RECT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 45. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 46. </span>    pygame.init()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 47. </span>    FPSCLOCK
= pygame.time.Clock()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 48. </span>    DISPLAYSURF
= pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 49. </span>    pygame.display.set_caption('Slide
Puzzle')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 50. </span>    BASICFONT
= pygame.font.Font('freesansbold.ttf', BASICFONTSIZE)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 51. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 52. </span>    <span
class=SourceCodeComment># Store the option buttons and their rectangles in
OPTIONS.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 53. </span>    RESET_SURF,
RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 90)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 54. </span>    NEW_SURF,
NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 60)</p>

<p class=SourceCodeFeaturedCxSpMiddle>&nbsp;</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 55. </span>    SOLVE_SURF,
SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 30)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 56. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 57. </span>    mainBoard,
solutionSeq = generateNewPuzzle(80)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 58. </span>    SOLVEDBOARD
= getStartingBoard() <span class=SourceCodeComment># a solved board is the same
as the board in a start state.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 59. </span>    allMoves
= [] <span class=SourceCodeComment># list of moves made from the solved
configuration</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 60. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 61. </span>    while
True: <span class=SourceCodeComment># main game loop</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 62. </span>        slideTo
= None <span class=SourceCodeComment># the direction, if any, a tile should
slide</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 63. </span>        msg
= '' <span class=SourceCodeComment># contains the message to show in the upper
left corner.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 64. </span>        if
mainBoard == SOLVEDBOARD:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 65. </span>            msg
= 'Solved!'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 66. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 67. </span>        drawBoard(mainBoard,
msg)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 68. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 69. </span>        checkForQuit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 70. </span>        for
event in pygame.event.get(): <span class=SourceCodeComment># event handling
loop</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 71. </span>            if
event.type == MOUSEBUTTONUP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 72. </span>                spotx,
spoty = getSpotClicked(mainBoard, event.pos[0], event.pos[1])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 73. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 74. </span>                if
(spotx, spoty) == (None, None):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 75. </span>                    <span
class=SourceCodeComment># check if the user clicked on an option button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 76. </span>                    if
RESET_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 77. </span>                        resetAnimation(mainBoard,
allMoves) <span class=SourceCodeComment># clicked on Reset button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 78. </span>                        allMoves
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 79. </span>                    elif
NEW_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 80. </span>                        mainBoard,
solutionSeq = generateNewPuzzle(80) <span class=SourceCodeComment># clicked on
New Game button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 81. </span>                        allMoves
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 82. </span>                    elif
SOLVE_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 83. </span>                        resetAnimation(mainBoard,
solutionSeq + allMoves) <span class=SourceCodeComment># clicked on Solve button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 84. </span>                        allMoves
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 85. </span>                else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 86. </span>                    <span
class=SourceCodeComment># check if the clicked tile was next to the blank spot</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 87. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 88. </span>                    blankx,
blanky = getBlankPosition(mainBoard)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 89. </span>                    if
spotx == blankx + 1 and spoty == blanky:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 90. </span>                        slideTo
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 91. </span>                    elif
spotx == blankx - 1 and spoty == blanky:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 92. </span>                        slideTo
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 93. </span>                    elif
spotx == blankx and spoty == blanky + 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 94. </span>                        slideTo
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 95. </span>                    elif
spotx == blankx and spoty == blanky - 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 96. </span>                        slideTo
= DOWN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 97. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 98. </span>            elif
event.type == KEYUP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 99. </span>                <span
class=SourceCodeComment># check if the user pressed a key to slide a tile</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>100. </span>                if
event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>101. </span>                    slideTo
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>102. </span>                elif
event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>103. </span>                    slideTo
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>104. </span>                elif
event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>105. </span>                    slideTo
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>106. </span>                elif
event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>107. </span>                    slideTo
= DOWN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>108. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>109. </span>        if
slideTo:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>110. </span>            slideAnimation(mainBoard,
slideTo, 'Click tile or press arrow keys to slide.', 8) <span
class=SourceCodeComment># show slide on screen</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>111. </span>            makeMove(mainBoard,
slideTo)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>112. </span>            allMoves.append(slideTo)
<span class=SourceCodeComment># record the slide</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>113. </span>        pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>114. </span>        FPSCLOCK.tick(FPS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>115. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>116. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>117. </span>def
terminate():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>118. </span>    pygame.quit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>119. </span>    sys.exit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>120. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>121. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>122. </span>def
checkForQuit():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>123. </span>    for
event in pygame.event.get(QUIT): <span class=SourceCodeComment># get all the
QUIT events</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>124. </span>        terminate()
<span class=SourceCodeComment># terminate if any QUIT events are present</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>125. </span>    for
event in pygame.event.get(KEYUP): <span class=SourceCodeComment># get all the
KEYUP events</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>126. </span>        if
event.key == K_ESCAPE:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>127. </span>            terminate()
<span class=SourceCodeComment># terminate if the KEYUP event was for the Esc
key</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>128. </span>        pygame.event.post(event)
<span class=SourceCodeComment># put the other KEYUP event objects back</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>129. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>130. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>131. </span>def
getStartingBoard():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>132. </span>    <span
class=SourceCodeComment># Return a board data structure with tiles in the
solved state.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>133. </span>    <span
class=SourceCodeComment># For example, if BOARDWIDTH and BOARDHEIGHT are both
3, this function</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>134. </span>    <span
class=SourceCodeComment># returns [[1, 4, 7], [2, 5, 8], [3, 6, None]]</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>135. </span>    counter
= 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>136. </span>    board
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>137. </span>    for
x in range(BOARDWIDTH):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>138. </span>        column
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>139. </span>        for
y in range(BOARDHEIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>140. </span>            column.append(counter)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>141. </span>            counter
+= BOARDWIDTH</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>142. </span>        board.append(column)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>143. </span>        counter
-= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>144. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>145. </span>    board[BOARDWIDTH-1][BOARDHEIGHT-1]
= None</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>146. </span>    return
board</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>147. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>148. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>149. </span>def
getBlankPosition(board):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>150. </span>    <span
class=SourceCodeComment># Return the x and y of board coordinates of the blank
space.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>151. </span>    for
x in range(BOARDWIDTH):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>152. </span>        for
y in range(BOARDHEIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>153. </span>            if
board[x][y] == None:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>154. </span>                return
(x, y)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>155. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>156. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>157. </span>def
makeMove(board, move):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>158. </span>    <span
class=SourceCodeComment># This function does not check if the move is valid.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>159. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>160. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>161. </span>    if
move == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>162. </span>        board[blankx][blanky],
board[blankx][blanky + 1] = board[blankx][blanky + 1], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>163. </span>    elif
move == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>164. </span>        board[blankx][blanky],
board[blankx][blanky - 1] = board[blankx][blanky - 1], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>165. </span>    elif
move == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>166. </span>        board[blankx][blanky],
board[blankx + 1][blanky] = board[blankx + 1][blanky], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>167. </span>    elif
move == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>168. </span>        board[blankx][blanky],
board[blankx - 1][blanky] = board[blankx - 1][blanky], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>169. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>170. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>171. </span>def
isValidMove(board, move):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>172. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>173. </span>    return
(move == UP and blanky != len(board[0]) - 1) or \</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>174. </span>           (move
== DOWN and blanky != 0) or \</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>175. </span>           (move
== LEFT and blankx != len(board) - 1) or \</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>176. </span>           (move
== RIGHT and blankx != 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>177. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>178. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>179. </span>def
getRandomMove(board, lastMove=None):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>180. </span>    <span
class=SourceCodeComment># start with a full list of all four moves</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>181. </span>    validMoves
= [UP, DOWN, LEFT, RIGHT]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>182. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>183. </span>    <span
class=SourceCodeComment># remove moves from the list as they are disqualified</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>184. </span>    if
lastMove == UP or not isValidMove(board, DOWN):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>185. </span>        validMoves.remove(DOWN)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>186. </span>    if
lastMove == DOWN or not isValidMove(board, UP):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>187. </span>        validMoves.remove(UP)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>188. </span>    if
lastMove == LEFT or not isValidMove(board, RIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>189. </span>        validMoves.remove(RIGHT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>190. </span>    if
lastMove == RIGHT or not isValidMove(board, LEFT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>191. </span>        validMoves.remove(LEFT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>192. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>193. </span>    <span
class=SourceCodeComment># return a random move from the list of remaining moves</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>194. </span>    return
random.choice(validMoves)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>195. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>196. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>197. </span>def
getLeftTopOfTile(tileX, tileY):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>198. </span>    left
= XMARGIN + (tileX * TILESIZE) + (tileX - 1)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>199. </span>    top
= YMARGIN + (tileY * TILESIZE) + (tileY - 1)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>200. </span>    return
(left, top)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>201. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>202. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>203. </span>def
getSpotClicked(board, x, y):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>204. </span>    <span
class=SourceCodeComment># from the x &amp; y pixel coordinates, get the x &amp;
y board coordinates</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>205. </span>    for
tileX in range(len(board)):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>206. </span>        for
tileY in range(len(board[0])):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>207. </span>            left,
top = getLeftTopOfTile(tileX, tileY)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>208. </span>            tileRect
= pygame.Rect(left, top, TILESIZE, TILESIZE)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>209. </span>            if
tileRect.collidepoint(x, y):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>210. </span>                return
(tileX, tileY)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>211. </span>    return
(None, None)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>212. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>213. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>214. </span>def
drawTile(tilex, tiley, number, adjx=0, adjy=0):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>215. </span>    <span
class=SourceCodeComment># draw a tile at board coordinates tilex and tiley,
optionally a few</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>216. </span>    <span
class=SourceCodeComment># pixels over (determined by adjx and adjy)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>217. </span>    left,
top = getLeftTopOfTile(tilex, tiley)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>218. </span>    pygame.draw.rect(DISPLAYSURF,
TILECOLOR, (left + adjx, top + adjy, TILESIZE, TILESIZE))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>219. </span>    textSurf
= BASICFONT.render(str(number), True, TEXTCOLOR)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>220. </span>    textRect
= textSurf.get_rect()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>221. </span>    textRect.center
= left + int(TILESIZE / 2) + adjx, top + int(TILESIZE / 2) + adjy</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>222. </span>    DISPLAYSURF.blit(textSurf,
textRect)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>223. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>224. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>225. </span>def
makeText(text, color, bgcolor, top, left):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>226. </span>    <span
class=SourceCodeComment># create the Surface and Rect objects for some text.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>227. </span>    textSurf
= BASICFONT.render(text, True, color, bgcolor)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>228. </span>    textRect
= textSurf.get_rect()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>229. </span>    textRect.topleft
= (top, left)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>230. </span>    return
(textSurf, textRect)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>231. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>232. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>233. </span>def
drawBoard(board, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>234. </span>    DISPLAYSURF.fill(BGCOLOR)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>235. </span>    if
message:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>236. </span>        textSurf,
textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, 5)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>237. </span>        DISPLAYSURF.blit(textSurf,
textRect)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>238. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>239. </span>    for
tilex in range(len(board)):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>240. </span>        for
tiley in range(len(board[0])):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>241. </span>            if
board[tilex][tiley]:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>242. </span>                drawTile(tilex,
tiley, board[tilex][tiley])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>243. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>244. </span>    left,
top = getLeftTopOfTile(0, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>245. </span>    width
= BOARDWIDTH * TILESIZE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>246. </span>    height
= BOARDHEIGHT * TILESIZE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>247. </span>    pygame.draw.rect(DISPLAYSURF,
BORDERCOLOR, (left - 5, top - 5, width + 11, height + 11), 4)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>248. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>249. </span>    DISPLAYSURF.blit(RESET_SURF,
RESET_RECT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>250. </span>    DISPLAYSURF.blit(NEW_SURF,
NEW_RECT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>251. </span>    DISPLAYSURF.blit(SOLVE_SURF,
SOLVE_RECT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>252. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>253. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>254. </span>def
slideAnimation(board, direction, message, animationSpeed):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>255. </span>    <span
class=SourceCodeComment># Note: This function does not check if the move is
valid.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>256. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>257. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>258. </span>    if
direction == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>259. </span>        movex
= blankx</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>260. </span>        movey
= blanky + 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>261. </span>    elif
direction == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>262. </span>        movex
= blankx</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>263. </span>        movey
= blanky - 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>264. </span>    elif
direction == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>265. </span>        movex
= blankx + 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>266. </span>        movey
= blanky</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>267. </span>    elif
direction == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>268. </span>        movex
= blankx - 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>269. </span>        movey
= blanky</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>270. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>271. </span>    <span
class=SourceCodeComment># prepare the base surface</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>272. </span>    drawBoard(board,
message)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>273. </span>    baseSurf
= DISPLAYSURF.copy()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>274. </span>    <span
class=SourceCodeComment># draw a blank space over the moving tile on the
baseSurf Surface.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>275. </span>    moveLeft,
moveTop = getLeftTopOfTile(movex, movey)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>276. </span>    pygame.draw.rect(baseSurf,
BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>277. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>278. </span>    for
i in range(0, TILESIZE, animationSpeed):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>279. </span>        <span
class=SourceCodeComment># animate the tile sliding over</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>280. </span>        checkForQuit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>281. </span>        DISPLAYSURF.blit(baseSurf,
(0, 0))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>282. </span>        if
direction == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>283. </span>            drawTile(movex,
movey, board[movex][movey], 0, -i)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>284. </span>        if
direction == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>285. </span>            drawTile(movex,
movey, board[movex][movey], 0, i)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>286. </span>        if
direction == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>287. </span>            drawTile(movex,
movey, board[movex][movey], -i, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>288. </span>        if
direction == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>289. </span>            drawTile(movex,
movey, board[movex][movey], i, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>290. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>291. </span>        pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>292. </span>        FPSCLOCK.tick(FPS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>293. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>294. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>295. </span>def
generateNewPuzzle(numSlides):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>296. </span>    <span
class=SourceCodeComment># From a starting configuration, make numSlides number
of moves (and</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>297. </span>    <span
class=SourceCodeComment># animate these moves).</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>298. </span>    sequence
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>299. </span>    board
= getStartingBoard()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>300. </span>    drawBoard(board,
'')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>301. </span>    pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>302. </span>    pygame.time.wait(500)
<span class=SourceCodeComment># pause 500 milliseconds for effect</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>303. </span>    lastMove
= None</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>304. </span>    for
i in range(numSlides):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>305. </span>        move
= getRandomMove(board, lastMove)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>306. </span>        slideAnimation(board,
move, 'Generating new puzzle...', int(TILESIZE / 3))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>307. </span>        makeMove(board,
move)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>308. </span>        sequence.append(move)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>309. </span>        lastMove
= move</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>310. </span>    return
(board, sequence)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>311. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>312. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>313. </span>def
resetAnimation(board, allMoves):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>314. </span>    <span
class=SourceCodeComment># make all of the moves in allMoves in reverse.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>315. </span>    revAllMoves
= allMoves[:] <span class=SourceCodeComment># gets a copy of the list</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>316. </span>    revAllMoves.reverse()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>317. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>318. </span>    for
move in revAllMoves:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>319. </span>        if
move == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>320. </span>            oppositeMove
= DOWN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>321. </span>        elif
move == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>322. </span>            oppositeMove
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>323. </span>        elif
move == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>324. </span>            oppositeMove
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>325. </span>        elif
move == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>326. </span>            oppositeMove
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>327. </span>        slideAnimation(board,
oppositeMove, '', int(TILESIZE / 2))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>328. </span>        makeMove(board,
oppositeMove)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>329. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>330. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>331. </span>if
__name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>332. </span>    main()</p>

</div>

<h2><a name="_Toc316488584">Second Verse, Same as the First</a></h2>

<p class=MsoNormal>Much of the code in Wormy is similar to the previous games
we’ve looked at, especially the constants being set at the start of the code.</p>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>  1. </span><span
class=SourceCodeComment># Slide Puzzle</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  2. </span><span
class=SourceCodeComment># By Al Sweigart al@inventwithpython.com</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  3. </span><span
class=SourceCodeComment># http://inventwithpython.com/pygame</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  4. </span><span
class=SourceCodeComment># Creative Commons BY-NC-SA 3.0 US</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  5. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  6. </span>import
pygame, sys, random</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  7. </span>from
pygame.locals import *</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  8. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>  9. </span><span
class=SourceCodeComment># Create the constants (go ahead and experiment with
different values)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 10. </span>BOARDWIDTH
= 4  <span class=SourceCodeComment># number of columns in the board</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 11. </span>BOARDHEIGHT
= 4 <span class=SourceCodeComment># number of rows in the board</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 12. </span>TILESIZE
= 80</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 13. </span>WINDOWWIDTH
= 640</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 14. </span>WINDOWHEIGHT
= 480</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 15. </span>FPS
= 30</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 16. </span>BLANK
= None</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 17. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 18. </span><span
class=SourceCodeComment>#                 R    G    B</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 19. </span>BLACK
=         (  0,   0,   0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 20. </span>WHITE
=         (255, 255, 255)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 21. </span>BRIGHTBLUE
=    (  0,  50, 255)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 22. </span>DARKTURQUOISE
= (  3,  54,  73)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 23. </span>GREEN
=         (  0, 204,   0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 24. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 25. </span>BGCOLOR
= DARKTURQUOISE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 26. </span>TILECOLOR
= GREEN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 27. </span>TEXTCOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 28. </span>BORDERCOLOR
= BRIGHTBLUE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 29. </span>BASICFONTSIZE
= 20</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 30. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 31. </span>BUTTONCOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 32. </span>BUTTONTEXTCOLOR
= BLACK</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 33. </span>MESSAGECOLOR
= WHITE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 34. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 35. </span>XMARGIN
= int((WINDOWWIDTH - (TILESIZE * BOARDWIDTH + (BOARDWIDTH - 1))) / 2)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 36. </span>YMARGIN
= int((WINDOWHEIGHT - (TILESIZE * BOARDHEIGHT + (BOARDHEIGHT - 1))) / 2)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 37. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 38. </span>UP
= 'up'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 39. </span>DOWN
= 'down'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 40. </span>LEFT
= 'left'</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 41. </span>RIGHT
= 'right'</p>

</div>

<p class=MsoNormal>This code at the top of the program just handles all the
basic importing of modules and creating constants. This is just like the
beginning of the Memory Puzzle game from the last chapter.</p>

<h2><a name="_Toc316488585">Setting Up the Buttons</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 43. </span>def
main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 44. </span>    global
FPSCLOCK, DISPLAYSURF, BASICFONT, RESET_SURF, RESET_RECT, NEW_SURF, NEW_RECT,
SOLVE_SURF, SOLVE_RECT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 45. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 46. </span>    pygame.init()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 47. </span>    FPSCLOCK
= pygame.time.Clock()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 48. </span>    DISPLAYSURF
= pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 49. </span>    pygame.display.set_caption('Slide
Puzzle')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 50. </span>    BASICFONT
= pygame.font.Font('freesansbold.ttf', BASICFONTSIZE)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 51. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 52. </span>    <span
class=SourceCodeComment># Store the option buttons and their rectangles in
OPTIONS.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 53. </span>    RESET_SURF,
RESET_RECT = makeText('Reset',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 90)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 54. </span>    NEW_SURF,
NEW_RECT   = makeText('New Game', TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 60)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 55. </span>    SOLVE_SURF,
SOLVE_RECT = makeText('Solve',    TEXTCOLOR, TILECOLOR, WINDOWWIDTH - 120,
WINDOWHEIGHT - 30)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 56. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 57. </span>    mainBoard,
solutionSeq = generateNewPuzzle(80)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 58. </span>    SOLVEDBOARD
= getStartingBoard() <span class=SourceCodeComment># a solved board is the same
as the board in a start state.</span></p>

</div>

<p class=MsoNormal>Just like in the last chapter, the functions called from the
<span class=Literal>main()</span> function calls will be explained later in the
chapter. For now, you just need to know what they do and what values they
return. You don’t need to know how they work.</p>

<p class=MsoNormal>The first part of the <span class=Literal>main()</span>
function will handle creating the window, Clock object, and Font object. The <span
class=Literal>makeText()</span> function is defined later in the program, but
for now you just need to know that it returns a <span class=Literal>pygame.Surface</span>
object and <span class=Literal>pygame.Rect</span> object which can be used to
make clickable buttons. The Slide Puzzle game will have three buttons: a
“Reset” button that will undo any moves the player has made, a “New” button
that will create a new slide puzzle, and a “Solve” button that will solve the
puzzle for the player.</p>

<p class=MsoNormal>We will need to have two board data structures for this
program. One board will represent the current game state. The other board will
have its tiles in the “solved” state, meaning that all the tiles are lined up
in order. When the current game state’s board is exactly the same as the solved
board, then we know the player has won. (We won’t ever change this second one.
It’ll just be there to compare the current game state board to.)</p>

<p class=MsoNormal>The <span class=Literal>generateNewPuzzle()</span> will
create a board data structure that started off in the ordered, solved state and
then had 80 random slide moves performed on it (because we passed the integer <span
class=Literal>80</span> to it. If we want the board to be even more jumbled,
then we can pass a larger integer to it). This will make the board into a randomly
jumbled state that the player will have to solve (which will be stored in a
variable named <span class=Literal>mainBoard</span>). The <span class=Literal>generateNewBoard()</span>
also returns a list of all the random moves that were performed on it (which
will be stored in a variable named <span class=Literal>solutionSeq</span>).</p>

<h2><a name="_Toc316488586">Being Smart By Using Stupid Code</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeatured><span class=SourceLineNumber> 59. </span>    allMoves
= [] <span class=SourceCodeComment># list of moves made from the solved
configuration</span></p>

</div>

<p class=MsoNormal>Solving a slide puzzle can be really tricky. We could
program the computer to do it, but that would require us to figure out an
algorithm that can solve the slide puzzle. That would be very difficult and
involve a lot of cleverness and effort to put into this program. </p>

<p class=MsoNormal>Fortunately, there’s an easier way. We could just have the
computer memorize all the random slides it made when it created the board data
structure, and then the board can be solved just by performing the opposite
slide. Since the board originally started in the solved state, undoing all the
slides would return it to the solved state.</p>

<p class=MsoNormal>For example, below we perform a “right” slide on the board
on the left side of the page, which leaves the board in the state that is on
the right side of the page:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=349
height=143 id="Picture 58" src="chapter4_files/image002.jpg"></p>

<p class=MsoNormal>After the right slide, if we do the opposite slide (a left
slide) then the board will be back in the original state. So to get back to the
original state after several slides, we just have to do the opposite slides in
reverse order. If we did a right slide, then another right slide, then a down
slide, we would have to do an up slide, left slide, and left slide to undo
those first three slides. This is much easier than writing a function that can
solve these puzzles simply by looking at the current state of them.</p>

<h2><a name="_Toc316488587">The Main Game Loop</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 61. </span>    while
True: <span class=SourceCodeComment># main game loop</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 62. </span>        slideTo
= None <span class=SourceCodeComment># the direction, if any, a tile should
slide</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 63. </span>        msg
= '' <span class=SourceCodeComment># contains the message to show in the upper
left corner.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 64. </span>        if
mainBoard == SOLVEDBOARD:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 65. </span>            msg
= 'Solved!'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 66. </span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 67. </span>        drawBoard(mainBoard,
msg)</p>

</div>

<p class=MsoNormal>In the main game loop, the <span class=Literal>slideTo</span>
variable will track which direction the player wants to slide a tile (it starts
off at the beginning of the game loop as <span class=Literal>None</span> and is
set later) and the <span class=Literal>msg</span> variable tracks what string
to display at the top of the window. The program does a quick check on line 64
to see if the board data structure has the same value as the solved board data
structure stored in <span class=Literal>SOLVEDBOARD</span>. If so, then the <span
class=Literal>msg</span> variable is changed to the string <span class=Literal>'Solved!'</span>.
This won’t appear on the screen until <span class=Literal>drawBoard()</span>
has been called to draw it to the <span class=Literal>DISPLAYSURF</span> Surface
object (which is done on line 67) and <span class=Literal>pygame.display.update()</span>
is called to draw the display Surface object on the actual computer screen
(which is done on line 291 at the end of the game loop).</p>

<h2><a name="_Toc316488588">Clicking on the Buttons</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 69. </span>        checkForQuit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 70. </span>        for
event in pygame.event.get(): <span class=SourceCodeComment># event handling
loop</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 71. </span>            if
event.type == MOUSEBUTTONUP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 72. </span>                spotx,
spoty = getSpotClicked(mainBoard, event.pos[0], event.pos[1])</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 73. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 74. </span>                if
(spotx, spoty) == (None, None):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 75. </span>                    <span
class=SourceCodeComment># check if the user clicked on an option button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 76. </span>                    if
RESET_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 77. </span>                        resetAnimation(mainBoard,
allMoves) <span class=SourceCodeComment># clicked on Reset button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 78. </span>                        allMoves
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 79. </span>                    elif
NEW_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 80. </span>                        mainBoard,
solutionSeq = generateNewPuzzle(80) <span class=SourceCodeComment># clicked on
New Game button</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 81. </span>                        allMoves
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 82. </span>                    elif
SOLVE_RECT.collidepoint(event.pos):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 83. </span>                        resetAnimation(mainBoard,
solutionSeq + allMoves) <span class=SourceCodeComment># clicked on Solve button</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 84. </span>                        allMoves
= []</p>

</div>

<p class=MsoNormal>Before going into the event loop, the program calls <span
class=Literal>checkForQuit()</span> on line 69 to see if any <span
class=Literal>QUIT</span> events have been created (and terminates the program
if there have). Why we have a separate function (the <span class=Literal>checkForQuit()</span>
function) for handling the <span class=Literal>QUIT</span> events will be
explained later. The <span class=Literal>for</span> loop on line 70 executes
the event handling code for any other event created since the last time <span
class=Literal>pygame.event.get()</span> was called (or since the program
started, if <span class=Literal>pygame.event.get()</span> has never been called
before).</p>

<p class=MsoNormal>If the type of event was a <span class=Literal>MOUSEBUTTONUP</span>
event (that is, the player had released a mouse button somewhere over the
window), then we pass the mouse coordinates to our <span class=Literal>getSpotClicked()</span>
function which will return the board coordinates of the spot on the board the
mouse release happened. The <span class=Literal>event.pos[0]</span> is the X
coordinate and <span class=Literal>event.pos[1]</span> is the Y coordinate.</p>

<p class=MsoNormal>If the mouse button release did not happen over one of the
spaces on the board (but obviously still happened somewhere on the window,
since a <span class=Literal>MOUSEBUTTONUP</span> event was created), then <span
class=Literal>getSpotClicked()</span> will return <span class=Literal>None</span>.
If this is the case, we want to do an additional check to see if the player
might have clicked on the Reset, New, or Solve buttons (which are not located
on the board). </p>

<p class=MsoNormal>The coordinates of where these buttons are on the window are
stored in the <span class=Literal>pygame.Rect</span> objects that are stored in
the <span class=Literal>RESET_RECT</span>, <span class=Literal>NEW_RECT</span>,
and <span class=Literal>SOLVE_RECT</span> variables. We can pass the mouse
coordinates from the Event object to the <span class=Literal>collidepoint()</span>
method. This method will return <span class=Literal>True</span> if the mouse
coordinates are within the Rect object’s area and <span class=Literal>False</span>
otherwise.</p>

<h2><a name="_Toc316488589">Sliding Tiles with the Mouse</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 85. </span>                else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 86. </span>                    <span
class=SourceCodeComment># check if the clicked tile was next to the blank spot</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 87. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 88. </span>                    blankx,
blanky = getBlankPosition(mainBoard)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 89. </span>                    if
spotx == blankx + 1 and spoty == blanky:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 90. </span>                        slideTo
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 91. </span>                    elif
spotx == blankx - 1 and spoty == blanky:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 92. </span>                        slideTo
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 93. </span>                    elif
spotx == blankx and spoty == blanky + 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 94. </span>                        slideTo
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 95. </span>                    elif
spotx == blankx and spoty == blanky - 1:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 96. </span>                        slideTo
= DOWN</p>

</div>

<p class=MsoNormal>If <span class=Literal>getSpotClicked()</span> did not
return <span class=Literal>(None, None)</span>, then it will have returned a
tuple of two integer values that represent the X and Y coordinate of the spot
on the board that was clicked. Then the <span class=Literal>if</span> and <span
class=Literal>elif</span> statements on lines 89 to 96 check if the spot that
was clicked is a tile that is next to the blank spot (otherwise the tile will
have no place to slide).</p>

<p class=MsoNormal>Our <span class=Literal>getBlankPosition()</span> function
will take the board data structure and return the X and Y board coordinates of the
blank spot, which we store in the variables <span class=Literal>blankx</span>
and <span class=Literal>blanky</span>. If the spot the user clicked on was next
to the blank space, we set the <span class=Literal>slideTo</span> variable with
the value that the tile should slide.</p>

<h2><a name="_Toc316488590">Sliding Tiles with the Keyboard</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 98. </span>            elif
event.type == KEYUP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 99. </span>                <span
class=SourceCodeComment># check if the user pressed a key to slide a tile</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>100. </span>                if
event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>101. </span>                    slideTo
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>102. </span>                elif
event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>103. </span>                    slideTo
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>104. </span>                elif
event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>105. </span>                    slideTo
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>106. </span>                elif
event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>107. </span>                    slideTo
= DOWN</p>

</div>

<p class=MsoNormal>We can also let the user slide tiles by pressing keyboard
keys. The <span class=Literal>if</span> and <span class=Literal>elif</span>
statements on lines 100 to 107 let the user set the <span class=Literal>slideTo</span>
variable by either pressing the arrow keys or the WASD keys (explained later).
Each <span class=Literal>if</span> and <span class=Literal>elif</span>
statement also has a call to <span class=Literal>isValidMove()</span> to make
sure that the tile can slide in that direction. (We didn’t have to make this
call with the mouse clicks because the checks for the neighboring blank space
did the same thing.)</p>

<h2><a name="_Toc316488591">“Equal To One Of” Trick with the </a><span
class=Literal>in</span> Operator</h2>

<p class=MsoNormal>The expression <span class=Literal>event.key in (K_LEFT,
K_a)</span> is just a Python trick to make the code simpler. It is a way of
saying “evaluate to <span class=Literal>True</span> if <span class=Literal>event.key</span>
is equal to one of <span class=Literal>K_LEFT</span> or <span class=Literal>K_a</span>”.
The following two expressions will evaluate the exact same way:</p>

<div style='border:solid windowtext 1.0pt;padding:4.0pt 4.0pt 4.0pt 4.0pt'>

<p class=CodeExampleCxSpFirst style='border:none;padding:0in'>event.key in
(K_LEFT, K_a)</p>

<p class=CodeExampleCxSpMiddle style='border:none;padding:0in'>&nbsp;</p>

<p class=CodeExampleCxSpLast style='border:none;padding:0in'>event.key ==
K_LEFT or event.key == K_a</p>

</div>

<p class=MsoNormal>You can really save on some space by using this trick when
you have to check if a value is equal to one of multiple values. The following
two expressions will evaluate the exact same way:</p>

<div style='border:solid windowtext 1.0pt;padding:4.0pt 4.0pt 4.0pt 4.0pt'>

<p class=CodeExampleCxSpFirst style='border:none;padding:0in'>spam == 'dog' or
spam == 'cat' or spam == 'mouse' or spam == 'horse' or spam == 42 or spam ==
'dingo'</p>

<p class=CodeExampleCxSpMiddle style='border:none;padding:0in'>&nbsp;</p>

<p class=CodeExampleCxSpLast style='border:none;padding:0in'>spam in ('dog',
'cat', 'mouse', 'horse', 42, 'dingo')</p>

</div>

<h2><a name="_Toc316488592">WASD and Arrow Keys</a></h2>

<p class=MsoNormal>The W, A, S, and D keys (together called the WASD keys,
pronounced “waz-dee”) are commonly used in computer games to do the same thing
as the arrow keys, except the player can use their left hand instead (since the
WASD keys are on the left side of the keyboard). W is for up, A is for left, S
is for down, and D is for right. You can easily remember this because the WASD
keys have the same layout as the arrow keys:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=265
height=91 id="Picture 21" src="chapter4_files/image003.png"></p>

<h2><a name="_Toc316488593">Actually Performing the Tile Slide</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>109. </span>        if
slideTo:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>110. </span>            slideAnimation(mainBoard,
slideTo, 'Click tile or press arrow keys to slide.', 8) <span
class=SourceCodeComment># show slide on screen</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>111. </span>            makeMove(mainBoard,
slideTo)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>112. </span>            allMoves.append(slideTo)
<span class=SourceCodeComment># record the slide</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>113. </span>        pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>114. </span>        FPSCLOCK.tick(FPS)</p>

</div>

<p class=MsoNormal>Now that the events have all been handled, we should update
the variables of the game state and display the new state on the screen. If <span
class=Literal>slideTo</span> has been set (either by the mouse event or
keyboard event handling code) then we can call <span class=Literal>slideAnimation()</span>
to perform the sliding animation. The parameters are the board data structure,
the direction of the slide, a message to display while sliding the tile, and
the speed of the sliding.</p>

<p class=MsoNormal>After it returns, we need to update the actual board data
structure (which is done by the <span class=Literal>makeMove()</span> function)
and then add the slide to the <span class=Literal>allMoves</span> list of all
the slides made so far. This is done so that if the player clicks on the
“Reset” button, we know how to undo all the player’s slides.</p>

<h2><a name="_Toc316488594">IDLE and Terminating Pygame Programs</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>117. </span>def
terminate():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>118. </span>    pygame.quit()</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>119. </span>    sys.exit()</p>

</div>

<p class=MsoNormal>This is a function that we can call that calls both the <span
class=Literal>pygame.quit()</span> and <span class=Literal>sys.exit()</span>
functions. This is a bit of syntactic sugar, so that instead of remembering to
make both of these calls, there is just a single function we can call instead.</p>

<h2><a name="_Toc316488595">Checking for a Specific Event, and Posting Events
to Pygame’s Event Queue</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>122. </span>def
checkForQuit():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>123. </span>    for
event in pygame.event.get(QUIT): <span class=SourceCodeComment># get all the
QUIT events</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>124. </span>        terminate()
<span class=SourceCodeComment># terminate if any QUIT events are present</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>125. </span>    for
event in pygame.event.get(KEYUP): <span class=SourceCodeComment># get all the
KEYUP events</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>126. </span>        if
event.key == K_ESCAPE:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>127. </span>            terminate()
<span class=SourceCodeComment># terminate if the KEYUP event was for the Esc
key</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>128. </span>        pygame.event.post(event)
<span class=SourceCodeComment># put the other KEYUP event objects back</span></p>

</div>

<p class=MsoNormal>The <span class=Literal>checkForQuit()</span> function will
check for <span class=Literal>QUIT</span> events (or if the user has pressed the
Esc key) and then call the <span class=Literal>terminate()</span> function. But
this is a bit tricky and requires some explanation.</p>

<p class=MsoNormal>Pygame internally has its own list data structure that it
creates and appends Event objects to as they are made. This data structure is
called the <span class=Definition>event queue</span>. When the <span
class=Literal>pygame.event.get()</span> function is called with no parameters,
the entire list is returned. However, you can pass a constant like <span
class=Literal>QUIT</span> to <span class=Literal>pygame.event.get()</span> so
that it will only return the <span class=Literal>QUIT</span> events (if any)
that are in the internal event queue. The rest of the events will stay in the
event queue for the next time <span class=Literal>pygame.event.get()</span> is
called.</p>

<p class=MsoNormal>You should note that Pygame’s event queue only stores up to
127 Event objects. If your program does not call <span class=Literal>pygame.event.get()</span>
frequently enough and the queue fills up, then any new events that happen won’t
be added to the event queue.</p>

<p class=MsoNormal>Line 123 pulls out a list of <span class=Literal>QUIT</span>
events from Pygame’s event queue and returns them. If there are any <span
class=Literal>QUIT</span> events in the event queue, the program terminates.</p>

<p class=MsoNormal>Line 125 pulls out all the <span class=Literal>KEYUP</span>
events from the event queue and checks if any of them are for the Esc key. If
one of the events is, then the program terminates. However, there could be <span
class=Literal>KEYUP</span> events for keys other than the Esc key. In this
case, we need to put the <span class=Literal>KEYUP</span> event back into
Pygame’s event queue. We can do this with the <span class=Literal>pygame.event.post()</span>
function, which adds the Event object passed to it to the end of the Pygame
event queue. This way, when line 70 calls <span class=Literal>pygame.event.get()</span>
the non-Esc key <span class=Literal>KEYUP</span> events will still be there.
Otherwise calls to <span class=Literal>checkForQuit()</span> would “consume”
all of the <span class=Literal>KEYUP</span> events and those events would never
be handled.</p>

<p class=MsoNormal>The <span class=Literal>pygame.event.post()</span> function
is also handy if you ever want your program to add Event objects to the Pygame
event queue.</p>

<h2><a name="_Toc316488596">Creating the Board Data Structure</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>131. </span>def
getStartingBoard():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>132. </span>    <span
class=SourceCodeComment># Return a board data structure with tiles in the
solved state.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>133. </span>    <span
class=SourceCodeComment># For example, if BOARDWIDTH and BOARDHEIGHT are both
3, this function</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>134. </span>    <span
class=SourceCodeComment># returns [[1, 4, 7], [2, 5, 8], [3, 6, None]]</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>135. </span>    counter
= 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>136. </span>    board
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>137. </span>    for
x in range(BOARDWIDTH):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>138. </span>        column
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>139. </span>        for
y in range(BOARDHEIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>140. </span>            column.append(counter)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>141. </span>            counter
+= BOARDWIDTH</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>142. </span>        board.append(column)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>143. </span>        counter
-= BOARDWIDTH * (BOARDHEIGHT - 1) + BOARDWIDTH - 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>144. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>145. </span>    board[BOARDWIDTH-1][BOARDHEIGHT-1]
= None</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>146. </span>    return
board</p>

</div>

<p class=MsoNormal>The <span class=Literal>getStartingBoard()</span> data
structure will create and return a data structure that represents a “solved”
board, where all the numbered tiles are in order and the blank tile is in the
lower right corner. This is done with nested <span class=Literal>for</span>
loops, just like the board data structure in the Memory Puzzle game was made.</p>

<p class=MsoNormal>However, notice that the first column isn’t going to be <span
class=Literal>[1, 2, 3]</span> but instead <span class=Literal>[1, 4, 7]</span>.
This is because the numbers on the tiles increase by 1 going across the row,
not down the column. Going down the column, the numbers increase by the size of
the board’s width (which is stored in the <span class=Literal>BOARDWIDTH</span>
constant). We will use the <span class=Literal>counter</span> variable to keep
track of the number that should go on the next tile. When the numbering of the
tiles in the column is finished, then we need to set <span class=Literal>counter</span>
to the number at the start of the next column. </p>

<h2><a name="_Toc316488597">Not Tracking the Blank Position</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>149. </span>def
getBlankPosition(board):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>150. </span>    <span
class=SourceCodeComment># Return the x and y of board coordinates of the blank
space.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>151. </span>    for
x in range(BOARDWIDTH):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>152. </span>        for
y in range(BOARDHEIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>153. </span>            if
board[x][y] == None:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>154. </span>                return
(x, y)</p>

</div>

<p class=MsoNormal>Whenever our code needs to find the XY coordinates of the
blank space, instead of keeping track of where the blank space is after each
slide, we can just create a function that goes through the entire board and
finds the blank space coordinates. The <span class=Literal>None</span> value is
used in the board data structure to represent the blank space. The code in <span
class=Literal>getBlankPosition()</span> simply uses nested <span class=Literal>for</span>
loops to find which space on the board is the blank space.</p>

<h2><a name="_Toc316488598">Making a Move by Updating the Board Data Structure</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>157. </span>def
makeMove(board, move):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>158. </span>    <span
class=SourceCodeComment># This function does not check if the move is valid.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>159. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>160. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>161. </span>    if
move == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>162. </span>        board[blankx][blanky],
board[blankx][blanky + 1] = board[blankx][blanky + 1], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>163. </span>    elif
move == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>164. </span>        board[blankx][blanky],
board[blankx][blanky - 1] = board[blankx][blanky - 1], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>165. </span>    elif
move == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>166. </span>        board[blankx][blanky],
board[blankx + 1][blanky] = board[blankx + 1][blanky], board[blankx][blanky]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>167. </span>    elif
move == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>168. </span>        board[blankx][blanky],
board[blankx - 1][blanky] = board[blankx - 1][blanky], board[blankx][blanky]</p>

</div>

<p class=MsoNormal>The data structure in the board parameter is a 2D list that
represents where all the tiles are. Whenever the player makes a move, the
program needs to update this data structure. What happens is that the value for
the tile is swapped with the value for the blank space.</p>

<p class=MsoNormal>The <span class=Literal>makeMove()</span> function doesn’t
have to return any values, because the <span class=Literal>board</span>
parameter has a list reference passed for its argument. This means that any
changes we make to <span class=Literal>board</span> in this function will be
made to the list value that was passed to <span class=Literal>makeMove()</span>.
(You can review the concept of references at <span class=URL><a href="http://invpy.com/references">http://invpy.com/references</a></span>.)</p>

<h2><a name="_Toc316488599">When NOT to Use an Assertion</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>171. </span>def
isValidMove(board, move):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>172. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>173. </span>    return
(move == UP and blanky != len(board[0]) - 1) or \</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>174. </span>           (move
== DOWN and blanky != 0) or \</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>175. </span>           (move
== LEFT and blankx != len(board) - 1) or \</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>176. </span>           (move
== RIGHT and blankx != 0)</p>

</div>

<p class=MsoNormal>The <span class=Literal>isValidMove()</span> function is
passed a board data structure and a move the player would want to make. The
return value is <span class=Literal>True</span> if this move is possible and <span
class=Literal>False</span> if it is not. For example, you cannot slide a tile
to the left one hundred times in a row, because eventually the blank space will
be at the edge and there are no more tiles to slide to the left.</p>

<p class=MsoNormal>Whether a move is valid or not depends on where the blank
space is. This function makes a call to <span class=Literal>getBlankPosition()</span>
to find the X and Y coordinates of the blank spot. Lines 173 to 176 are a <span
class=Literal>return</span> statement with a single expression. The <span
class=Literal>\</span> slashes at the end of the first three lines tells the
Python interpreter that that is not the end of the line of code (even though it
is at the end of the line). This will let us split up a “line of code” across
multiple lines to look pretty, rather than just have one very long unreadable
line.</p>

<p class=MsoNormal>Because the parts of this expression in parentheses are
joined by or operators, only one of them needs to be <span class=Literal>True</span>
for the entire expression to be <span class=Literal>True</span>. Each of these
parts checks what the intended move is and then sees if the coordinate of the
blank space allows that move.</p>

<h2><a name="_Toc316488600">Getting a Not-So-Random Move</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>179. </span>def
getRandomMove(board, lastMove=None):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>180. </span>    <span
class=SourceCodeComment># start with a full list of all four moves</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>181. </span>    validMoves
= [UP, DOWN, LEFT, RIGHT]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>182. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>183. </span>    <span
class=SourceCodeComment># remove moves from the list as they are disqualified</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>184. </span>    if
lastMove == UP or not isValidMove(board, DOWN):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>185. </span>        validMoves.remove(DOWN)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>186. </span>    if
lastMove == DOWN or not isValidMove(board, UP):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>187. </span>        validMoves.remove(UP)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>188. </span>    if
lastMove == LEFT or not isValidMove(board, RIGHT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>189. </span>        validMoves.remove(RIGHT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>190. </span>    if
lastMove == RIGHT or not isValidMove(board, LEFT):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>191. </span>        validMoves.remove(LEFT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>192. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>193. </span>    <span
class=SourceCodeComment># return a random move from the list of remaining moves</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>194. </span>    return
random.choice(validMoves)</p>

</div>

<p class=MsoNormal>At the beginning of the game, we start with the board data
structure in the solved, ordered state and create the puzzle by randomly
sliding around tiles. To decide which of the four directions we should slide,
we’ll call our <span class=Literal>getRandomMove()</span> function. Normally we
could just use the <span class=Literal>random.choice()</span> function and pass
it a tuple <span class=Literal>(UP, DOWN, LEFT, RIGHT)</span> to have Python
simply randomly choose a direction value for us. But the Sliding Puzzle game
has a small restriction that prevents us from choosing a purely random number.</p>

<p class=MsoNormal>If you had a slide puzzle and slid a tile to left, and then
slid a tile to the right, you would end up with the exact same board you had at
the start. It’s pointless to make a slide followed by the opposite slide. Also,
if the blank space is in the lower right corner than it is impossible to slide
a tile up or to the left.</p>

<p class=MsoNormal>The code in <span class=Literal>getRandomMove()</span> will
take these factors into account. To prevent the function from selecting the
last move that was made, the caller of the function can pass a directional
value for the <span class=Literal>lastMove</span> parameter. Line 181 starts
with a list of all four directional values stored in the <span class=Literal>validMoves</span>
variable. The <span class=Literal>lastMove</span> value (if not set to <span
class=Literal>None</span>) is removed from <span class=Literal>validMoves</span>.
Depending on if the blank space is at the edge of the board, lines 184 to 191
will remove other directional values from the <span class=Literal>lastMove</span>
list.</p>

<p class=MsoNormal>Of the values that are left in <span class=Literal>lastMove</span>,
one of them is randomly selected with a call to <span class=Literal>random.choice()</span>
and returned.</p>

<h2><a name="_Toc316488601">Converting Tile Coordinates to Pixel Coordinates</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>197. </span>def
getLeftTopOfTile(tileX, tileY):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>198. </span>    left
= XMARGIN + (tileX * TILESIZE) + (tileX - 1)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>199. </span>    top
= YMARGIN + (tileY * TILESIZE) + (tileY - 1)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>200. </span>    return
(left, top)</p>

</div>

<p class=MsoNormal>The <span class=Literal>getLeftTopOfTile()</span> function
converts board coordinates to pixel coordinates. For the board XY coordinates
that are passed in, the function calculates and returns the pixel XY
coordinates of the pixel at the top left of that board space.</p>

<h2><a name="_Toc316488602">Converting from Pixel Coordinates to Board
Coordinates</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>203. </span>def
getSpotClicked(board, x, y):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>204. </span>    <span
class=SourceCodeComment># from the x &amp; y pixel coordinates, get the x &amp;
y board coordinates</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>205. </span>    for
tileX in range(len(board)):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>206. </span>        for
tileY in range(len(board[0])):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>207. </span>            left,
top = getLeftTopOfTile(tileX, tileY)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>208. </span>            tileRect
= pygame.Rect(left, top, TILESIZE, TILESIZE)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>209. </span>            if
tileRect.collidepoint(x, y):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>210. </span>                return
(tileX, tileY)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>211. </span>    return
(None, None)</p>

</div>

<p class=MsoNormal>The <span class=Literal>getSpotClicked()</span> function does
the opposite of <span class=Literal>getLeftTopOfTile()</span> and converts from
pixel coordinates to board coordinates. The nested loops on lines 205 and 206 go
through every possible XY board coordinate, and if the pixel coordinates that
were passed in are within that space on the board, it returns those board
coordinates. Since all of the tiles have a width and height that is set in the <span
class=Literal>TILESIZE</span> constant, we can create a Rect object that
represents the space on the board by getting the pixel coordinates of the top
left corner of the board space, and then use the <span class=Literal>collidepoint()</span>
Rect method to see if the pixel coordinates are inside that Rect object’s area.</p>

<p class=MsoNormal>If the pixel coordinates that were passed in were not over
any board space, then the value <span class=Literal>(None, None)</span> is
returned.</p>

<h2><a name="_Toc316488603">Drawing a Tile</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>214. </span>def
drawTile(tilex, tiley, number, adjx=0, adjy=0):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>215. </span>    <span
class=SourceCodeComment># draw a tile at board coordinates tilex and tiley,
optionally a few</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>216. </span>    <span
class=SourceCodeComment># pixels over (determined by adjx and adjy)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>217. </span>    left,
top = getLeftTopOfTile(tilex, tiley)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>218. </span>    pygame.draw.rect(DISPLAYSURF,
TILECOLOR, (left + adjx, top + adjy, TILESIZE, TILESIZE))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>219. </span>    textSurf
= BASICFONT.render(str(number), True, TEXTCOLOR)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>220. </span>    textRect
= textSurf.get_rect()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>221. </span>    textRect.center
= left + int(TILESIZE / 2) + adjx, top + int(TILESIZE / 2) + adjy</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>222. </span>    DISPLAYSURF.blit(textSurf,
textRect)</p>

</div>

<p class=MsoNormal>The <span class=Literal>drawTile()</span> function will draw
a single numbered tile on the board. The <span class=Literal>tilex</span> and <span
class=Literal>tiley</span> parameters are the board coordinates of the tile.
The number parameter is a string of the tile’s number (like <span
class=Literal>'3'</span> or <span class=Literal>'12'</span>). The <span
class=Literal>adjx</span> and <span class=Literal>adjy</span> keyword
parameters are for making minor adjustments to the position of the tile. For
example, passing <span class=Literal>5</span> for <span class=Literal>adjx</span>
would make the tile appear 5 pixels to the right of the <span class=Literal>tilex</span>
and <span class=Literal>tiley</span> space on the board. Passing <span
class=Literal>-10</span> for <span class=Literal>adjx</span> would make the
tile appear 10 pixels to the left of the space. </p>

<p class=MsoNormal>These adjustment values will be handy when we need to draw
the tile in the middle of sliding. If no values are passed for these arguments
when <span class=Literal>drawTile()</span> is called, then by default they are
set to <span class=Literal>0</span>. This means they will be exactly on the
board space given by <span class=Literal>tilex</span> and <span class=Literal>tiley</span>.
</p>

<p class=MsoNormal>The Pygame drawing functions only use pixel coordinates, so
first line 217 converts the board coordinates in <span class=Literal>tilex</span>
and <span class=Literal>tiley</span> to pixel coordinates, which we will store
in variables <span class=Literal>left</span> and <span class=Literal>top</span>
(since <span class=Literal>getLeftTopOfTile()</span> returns the top left
corner’s coordinates). We draw the background square of the tile with a call to
<span class=Literal>pygame.draw.rect()</span> while adding the <span
class=Literal>adjx</span> and <span class=Literal>adjy</span> values to <span
class=Literal>left</span> and <span class=Literal>top</span> in case the code
needs to adjust the position of the tile.</p>

<p class=MsoNormal>Lines 219 to 222 then create the Surface object that has the
number text drawn on it. A Rect object for the Surface object is positioned,
and then used to blit the Surface object to the display Surface. The <span
class=Literal>drawTile()</span> function doesn’t call <span class=Literal>pygame.display.update()</span>
function, since the caller of <span class=Literal>drawTile()</span> probably
will want to draw more tiles for the rest of the board before making them
appear on the screen.</p>

<h2><a name="_Toc316488604">The Making Text Appear on the Screen</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>225. </span>def
makeText(text, color, bgcolor, top, left):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>226. </span>    <span
class=SourceCodeComment># create the Surface and Rect objects for some text.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>227. </span>    textSurf
= BASICFONT.render(text, True, color, bgcolor)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>228. </span>    textRect
= textSurf.get_rect()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>229. </span>    textRect.topleft
= (top, left)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>230. </span>    return
(textSurf, textRect)</p>

</div>

<p class=MsoNormal>The <span class=Literal>makeText()</span> function handles
creating the Surface and Rect objects for positioning text on the screen.
Instead of doing all these calls each time we want to make text on the screen,
we can just call <span class=Literal>makeText()</span> instead. This saves us
on the amount of typing we have to do for our program. (Though <span
class=Literal>drawTile()</span> makes the calls to <span class=Literal>render()</span>
and <span class=Literal>get_rect()</span> itself because it positions the text
Surface object by the center point rather than the topleft point and uses a
transparent background color.)</p>

<h2><a name="_Toc316488605">Drawing the Board</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>233. </span>def
drawBoard(board, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>234. </span>    DISPLAYSURF.fill(BGCOLOR)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>235. </span>    if
message:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>236. </span>        textSurf,
textRect = makeText(message, MESSAGECOLOR, BGCOLOR, 5, 5)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>237. </span>        DISPLAYSURF.blit(textSurf,
textRect)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>238. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>239. </span>    for
tilex in range(len(board)):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>240. </span>        for
tiley in range(len(board[0])):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>241. </span>            if
board[tilex][tiley]:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>242. </span>                drawTile(tilex,
tiley, board[tilex][tiley])</p>

</div>

<p class=MsoNormal>This function handles drawing the entire board and all of
its tiles to the <span class=Literal>DISPLAYSURF</span> display Surface object.
The <span class=Literal>fill()</span> method on line 234 completely paints over
anything that used to be drawn on the display Surface object before so that we
start from scratch.</p>

<p class=MsoNormal>Line 235 to 237 handles drawing the message at the top of
the window. We use this for the “Generating new puzzle…” and other text we want
to display at the top of the window. Remember that <span class=Literal>if</span>
statement conditions consider the blank string to be a <span class=Literal>False</span>
value, so if message is set to <span class=Literal>''</span> then the condition
is <span class=Literal>False</span> and lines 236 and 237 are skipped.</p>

<p class=MsoNormal>Next, nested <span class=Literal>for</span> loops are used
to draw each tile to the display Surface object by calling the <span
class=Literal>drawTile()</span> function.</p>

<h2><a name="_Toc316488606">Drawing the Border of the Board</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>244. </span>    left,
top = getLeftTopOfTile(0, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>245. </span>    width
= BOARDWIDTH * TILESIZE</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>246. </span>    height
= BOARDHEIGHT * TILESIZE</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>247. </span>    pygame.draw.rect(DISPLAYSURF,
BORDERCOLOR, (left - 5, top - 5, width + 11, height + 11), 4)</p>

</div>

<p class=MsoNormal>Lines 244 to 247 draw a border around the tiles. The top
left corner of the boarder will be 5 pixels to the left and 5 pixels above the
top left corner of the tile at board coordinates (0, 0). The width and height
of the border are calculated from the number of tiles wide and high the board
is (stored in the <span class=Literal>BOARDWIDTH</span> and <span
class=Literal>BOARDHEIGHT</span> constants) multiplied by the size of the tiles
(stored in the <span class=Literal>TILESIZE</span> constant).</p>

<p class=MsoNormal>The rectangle we draw on line 247 will have a thickness of 4
pixels, so we will move the boarder 5 pixels to the left and above where the <span
class=Literal>top</span> and <span class=Literal>left</span> variables point so
the thickness of the line won’t overlap the tiles. We will also add <span
class=Literal>11</span> to the width and length (5 of those 11 pixels are to
compensate for moving the rectangle to the left and up).</p>

<h2><a name="_Toc316488607">Drawing the Buttons</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>249. </span>    DISPLAYSURF.blit(RESET_SURF,
RESET_RECT)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>250. </span>    DISPLAYSURF.blit(NEW_SURF,
NEW_RECT)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>251. </span>    DISPLAYSURF.blit(SOLVE_SURF,
SOLVE_RECT)</p>

</div>

<p class=MsoNormal>Finally, we draw the buttons off to the slide of the screen.
The text and position of these buttons never changes, which is why they were
stored in constant variables at the beginning of the <span class=Literal>main()</span>
function.</p>

<h2><a name="_Toc316488608">Animating the Tile Slides</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>254. </span>def
slideAnimation(board, direction, message, animationSpeed):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>255. </span>    <span
class=SourceCodeComment># Note: This function does not check if the move is
valid.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>256. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>257. </span>    blankx,
blanky = getBlankPosition(board)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>258. </span>    if
direction == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>259. </span>        movex
= blankx</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>260. </span>        movey
= blanky + 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>261. </span>    elif
direction == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>262. </span>        movex
= blankx</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>263. </span>        movey
= blanky - 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>264. </span>    elif
direction == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>265. </span>        movex
= blankx + 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>266. </span>        movey
= blanky</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>267. </span>    elif
direction == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>268. </span>        movex
= blankx - 1</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>269. </span>        movey
= blanky</p>

</div>

<p class=MsoNormal>The first thing our tile sliding animation code needs to
calculate is where the blank space is and where the moving tile is. The comment
on line 255 reminds us that the code that calls <span class=Literal>slideAnimation()</span>
should make sure that the slide it passes for the direction parameter is a
valid move to make.</p>

<p class=MsoNormal>The blank space’s coordinates come from a call to <span
class=Literal>getBlankPosition()</span>. From these coordinates and the
direction of the slide, we can figure out the XY board coordinates of the tile
that will slide. These coordinates will be stored in the <span class=Literal>movex</span>
and <span class=Literal>movey</span> variables.</p>

<h2><a name="_Toc316488609">The </a><span class=Literal>copy()</span> Surface
Method</h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>271. </span>    <span
class=SourceCodeComment># prepare the base surface</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>272. </span>    drawBoard(board,
message)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>273. </span>    baseSurf
= DISPLAYSURF.copy()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>274. </span>    <span
class=SourceCodeComment># draw a blank space over the moving tile on the
baseSurf Surface.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>275. </span>    moveLeft,
moveTop = getLeftTopOfTile(movex, movey)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>276. </span>    pygame.draw.rect(baseSurf,
BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))</p>

</div>

<p class=MsoNormal>The <span class=Literal>copy()</span> method of Surface
objects will return a new Surface object that has the same image drawn to it.
But they are two separate Surface objects. After calling the <span
class=Literal>copy()</span> method, if we draw on one Surface object using <span
class=Literal>blit()</span> or the Pygame drawing functions, it will not change
the image on the other Surface object. We store this copy in the <span
class=Literal>baseSurf</span> variable on line 273.</p>

<p class=MsoNormal>Next, we paint another blank space over the tile that will
slide. This is because when we draw each frame of the sliding animation, we
will draw the sliding tile over different parts of the <span class=Literal>baseSurf</span>
Surface object. If we didn’t blank out the moving tile on the <span
class=Literal>baseSurf</span> Surface, then it would still be there as we draw
the sliding tile. In that case, here is what the <span class=Literal>baseSurf</span>
Surface would look like:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=310
height=242 id="Picture 6" src="chapter4_files/image004.jpg"></p>

<p class=MsoNormal>And then what it would look like when we draw the “9” tile sliding
upwards on top of it:</p>

<p class=MsoNormal align=center style='text-align:center'><img width=310
height=242 id="Picture 18" src="chapter4_files/image005.jpg"></p>

<p class=MsoNormal>You can see this for yourself by commenting out line 276 and
running the program.</p>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>278. </span>    for
i in range(0, TILESIZE, animationSpeed):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>279. </span>        <span
class=SourceCodeComment># animate the tile sliding over</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>280. </span>        checkForQuit()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>281. </span>        DISPLAYSURF.blit(baseSurf,
(0, 0))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>282. </span>        if
direction == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>283. </span>            drawTile(movex,
movey, board[movex][movey], 0, -i)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>284. </span>        if
direction == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>285. </span>            drawTile(movex,
movey, board[movex][movey], 0, i)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>286. </span>        if
direction == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>287. </span>            drawTile(movex,
movey, board[movex][movey], -i, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>288. </span>        if
direction == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>289. </span>            drawTile(movex,
movey, board[movex][movey], i, 0)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>290. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>291. </span>        pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>292. </span>        FPSCLOCK.tick(FPS)</p>

</div>

<p class=MsoNormal>In order to draw the frames of the sliding animation, we
must draw the <span class=Literal>baseSurf</span> surface on the display
Surface, then on each frame of the animation draw the sliding tile closer and
closer to its final position where the original blank space was. The space
between two adjacent tiles is the same size as a single tile, which we have
stored in <span class=Literal>TILESIZE</span>. The code uses a <span
class=Literal>for</span> loop to go from <span class=Literal>0</span> to <span
class=Literal>TILESIZE</span>. </p>

<p class=MsoNormal>Normally this would mean that we would draw the tile 0
pixels over, then on the next frame draw the tile 1 pixel over, then 2 pixels,
then 3, and so on. Each of these frames would take 1/30<sup>th</sup> of a
second. If you have <span class=Literal>TILESIZE</span> set to <span
class=Literal>80</span> (as the program in this book does on line 12) then
sliding a tile would take over two and a half seconds, which is actually kind
of slow.</p>

<p class=MsoNormal>So instead we will have the <span class=Literal>for</span>
loop iterate from <span class=Literal>0</span> to <span class=Literal>TILESIZE</span>
by several pixels each frame. The number of pixels it jumps over is stored in <span
class=Literal>animationSpeed</span>, which is passed in when <span
class=Literal>slideAnimation()</span> is called. For example, if <span
class=Literal>animationSpeed</span> was set to <span class=Literal>8</span> and
the constant <span class=Literal>TILESIZE</span> was set to <span
class=Literal>80</span>, then the <span class=Literal>for</span> loop and <span
class=Literal>range(0, TILESIZE, animationSpeed)</span> would set the <span
class=Literal>i</span> variable to the values <span class=Literal>0</span>, <span
class=Literal>8</span>, <span class=Literal>16</span>, <span class=Literal>24</span>,
<span class=Literal>32</span>, <span class=Literal>40</span>, <span
class=Literal>48</span>, <span class=Literal>56</span>, <span class=Literal>64</span>,
<span class=Literal>72</span>. (It does not include <span class=Literal>80</span>
because the <span class=Literal>range()</span> function goes up to, but not
including, the second argument.) This means the entire sliding animation would
be done in 10 frames, which would mean it is done in 10/30<sup>th</sup> of a
second (a third of a second) since the game runs at 30 FPS.</p>

<p class=MsoNormal>Lines 282 to 289 makes sure that we draw the tile sliding in
the correct direction (based on what value the <span class=Literal>direction</span>
variable has). After the animation is done, then the function returns. Notice
that while the animation is happening, any events being created by the user are
not being handled. Those events will be handled the next time execution reaches
line 70 in the <span class=Literal>main()</span> function or the code in the <span
class=Literal>checkForQuit()</span> function.</p>

<h2><a name="_Toc316488610">Creating a New Puzzle</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>295. </span>def
generateNewPuzzle(numSlides):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>296. </span>    <span
class=SourceCodeComment># From a starting configuration, make numSlides number
of moves (and</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>297. </span>    <span
class=SourceCodeComment># animate these moves).</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>298. </span>    sequence
= []</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>299. </span>    board
= getStartingBoard()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>300. </span>    drawBoard(board,
'')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>301. </span>    pygame.display.update()</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>302. </span>    pygame.time.wait(500)
<span class=SourceCodeComment># pause 500 milliseconds for effect</span></p>

</div>

<p class=MsoNormal>The <span class=Literal>generateNewPuzzle()</span> function
will be called at the start of each new game. It will create a new board data
structure by calling <span class=Literal>getStartingBoard()</span> and then
randomly scramble it. The first few lines of <span class=Literal>generateNewPuzzle()</span>
get the board and then draw it to the screen (freezing for half a second to let
the player see the fresh board for a moment).</p>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>303. </span>    lastMove
= None</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>304. </span>    for
i in range(numSlides):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>305. </span>        move
= getRandomMove(board, lastMove)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>306. </span>        slideAnimation(board,
move, 'Generating new puzzle...', int(TILESIZE / 3))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>307. </span>        makeMove(board,
move)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>308. </span>        sequence.append(move)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>309. </span>        lastMove
= move</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>310. </span>    return
(board, sequence)</p>

</div>

<p class=MsoNormal>The <span class=Literal>numSlides</span> parameter will show
tell the function how many of these random moves to make. The code for doing a
random move is the <span class=Literal>getRandomMove()</span> call on line 305 to
get the move itself, then call <span class=Literal>slideAnimation()</span> to
perform the animation on the screen. Because doing the slide animation does not
actually update the board data structure, we update the board by calling <span
class=Literal>makeMove()</span> on line 307.</p>

<p class=MsoNormal>We need to keep track of each of the random moves that was
made so that the player can click the “Solve” button later and have the program
undo all these random moves. (The “Being Smart By Using Stupid Code” section
talks about why and how we do this.) So the move is appended to the list of
moves in <span class=Literal>sequence</span> on line 308.</p>

<p class=MsoNormal>Then we store the random move in a variable called <span
class=Literal>lastMove</span> which will be passed to <span class=Literal>getRandomMove()</span>
on the next iteration. This prevents the next random move from undoing the
random move we just performed.</p>

<p class=MsoNormal>All of this needs to happen <span class=Literal>numSlides</span>
number of times, so we put lines 305 to 309 inside a <span class=Literal>for</span>
loop. When the board is done being scrambled, then we return the board data
structure and also the list of the random moves made on it.</p>

<h2><a name="_Toc316488611">Animating the Board Reset</a></h2>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>313. </span>def
resetAnimation(board, allMoves):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>314. </span>    <span
class=SourceCodeComment># make all of the moves in allMoves in reverse.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>315. </span>    revAllMoves
= allMoves[:] <span class=SourceCodeComment># gets a copy of the list</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>316. </span>    revAllMoves.reverse()</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>317. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>318. </span>    for
move in revAllMoves:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>319. </span>        if
move == UP:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>320. </span>            oppositeMove
= DOWN</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>321. </span>        elif
move == DOWN:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>322. </span>            oppositeMove
= UP</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>323. </span>        elif
move == RIGHT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>324. </span>            oppositeMove
= LEFT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>325. </span>        elif
move == LEFT:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>326. </span>            oppositeMove
= RIGHT</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>327. </span>        slideAnimation(board,
oppositeMove, '', int(TILESIZE / 2))</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>328. </span>        makeMove(board,
oppositeMove)</p>

</div>

<p class=MsoNormal>When the player clicks on “Reset” or “Solve”, the Slide
Puzzle game program needs to undo all of the moves that were made to the board.
The list of directional values for the slides will be passed as the argument
for the <span class=Literal>allMoves</span> parameter.</p>

<p class=MsoNormal>Line 315 uses list slicing to create a duplicate of the <span
class=Literal>allMoves</span> list. Remember that if you don’t specify a number
before the <span class=Literal>:</span>, then Python assumes the slice should
start from the very beginning of the list. And if you don’t specify a number
after the <span class=Literal>:</span>, then Python assumes the slice should
keep going to the very end of the list. So <span class=Literal>allMoves[:]</span>
creates a list slice of the entire <span class=Literal>allMoves</span> list.
This makes a copy of the actual list to store in <span class=Literal>revAllMoves</span>,
rather than just a copy of the list reference. (See <span class=URL><a href="http://invpy.com/references">http://invpy.com/references</a></span>
for details.)</p>

<p class=MsoNormal>To undo all the moves in <span class=Literal>allMoves</span>,
we need to perform the opposite move of the moves in <span class=Literal>allMoves</span>,
and in reverse order. There is a list method called <span class=Literal>reverse()</span>
which will reverse the order of the items in a list. We call this on the <span
class=Literal>revAllMoves</span> list on line 316.</p>

<p class=MsoNormal>The <span class=Literal>for</span> loop on line 318 iterates
over the list of directional values. Remember, we want the opposite move, so
the <span class=Literal>if</span> and <span class=Literal>elif</span> statements
from line 319 to 326 set the correct directional value in the <span
class=Literal>oppositeMove</span> variable. Then we call <span class=Literal>slideAnimation()</span>
to perform the animation, and <span class=Literal>makeMove()</span> to update
the board data structure.</p>

<div style='border:double windowtext 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>331. </span>if
__name__ == '__main__':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>332. </span>    main()</p>

</div>

<p class=MsoNormal>Just like in the Memory Puzzle game, after all the <span
class=Literal>def</span> statements have been executed to create all the
functions, we call the <span class=Literal>main()</span> function to begin the
meat of the program.</p>

<p class=MsoNormal>That’s all there is to the Slide Puzzle program! But let’s
talk about some general programming concepts that came up in this game.</p>

<h2><a name="_Toc316488612">Time vs. Memory Tradeoffs</a></h2>

<p class=MsoNormal>Of course, there are a few different ways to write the Slide
Puzzle game so that it looks and acts the exact same way even though the code
is different. There are many different ways the a program that does a task
could be written. The most common differences are making tradeoffs between
execution time and memory usage.</p>

<p class=MsoNormal>Usually, the faster a program can run, the better it is.
This is especially true with programs that need to do a lot of calculations,
whether they are scientific weather simulators or games with a large amount of
detailed 3D graphics to draw. It’s also good to use the least amount of memory
possible. The more variables and the larger the lists your program uses, the
more memory it takes up. (You can find out how to measure your program’s memory
usage and execution time at <span class=URL><a href="http://invpy.com/profiling">http://invpy.com/profiling</a></span>.)</p>

<p class=MsoNormal>Right now, the programs in this book aren’t big and complicated
enough where you have to worry about conserving memory or optimizing the
execution time. But it can be something to consider as you become a more
skilled programmer.</p>

<p class=MsoNormal>For example, consider the <span class=Literal>getBlankPosition()</span>
function. This function takes time to run, since it goes through all the
possible board coordinates to find where the blank space is. Instead, we could
just have a <span class=Literal>blankspacex</span> and <span class=Literal>blankspacey</span>
variable which would have these XY coordinates so we would not have to look
through the entire board each time we want to know where it was. (We would also
need code that updates the <span class=Literal>blankspacex</span> and <span
class=Literal>blankspacey</span> variables whenever a move is done. This code
could go in <span class=Literal>makeMove()</span>.) Using these variables would
take up more memory, but they would save you on execution time so your program
would run faster.</p>

<p class=MsoNormal>Another example is that we keep a board data structure in
the solved state in the <span class=Literal>SOLVEDBOARD</span> variable, so
that we can compare the current board to <span class=Literal>SOLVEDBOARD</span>
to see if the player has solved the puzzle. Each time we wanted to do this
check, we could just call the <span class=Literal>getStartingBoard()</span>
function and compare the returned value to the current board. Then we would not
need the <span class=Literal>SOLVEDBOARD</span> variable. This would save us a
little bit of memory, but then our program would take longer to run because it
is re-creating the solved-state board data structure each time we do this
check.</p>

<p class=MsoNormal>There is one thing you must remember though. Writing code
that is readable is a very important skill. Code that is “readable” is code
that is easy to understand, especially by programmers who did not write the
code. If another programmer can look at your program’s source code and figure
out what it does without much trouble, then that program is very readable.
Readability is important because when you want to fix bugs or add new features
to your program (and bugs and ideas for new features <strong>always</strong>
come up), then having a readable program makes those tasks much easier.</p>

<h2><a name="_Toc316488613">Nobody Cares About a Few Bytes</a></h2>

<p class=MsoNormal>Also, there is one thing that might seem kind of silly to
say in this book because it seem obvious, but many people wonder about it. You
should know that using short variable names like <span class=Literal>x</span>
or <span class=Literal>num</span> instead of longer, more descriptive variable
names like <span class=Literal>blankx</span> or <span class=Literal>numSlides</span>
does not save you any memory when your program actually runs. Using these
longer variable names is better because they’ll make your program more
readable.</p>

<p class=MsoNormal>You might also come up with some clever tricks that do save
a few bytes of memory here and there. One trick is that when you no longer need
a variable, you can reuse that variable name for a different purpose instead of
just using two differently named variables. </p>

<p class=MsoNormal>Try to avoid the temptation to do this. Usually, these
tricks reduce code readability and make it harder to debug your programs.
Modern computers have billions of bytes of memory, and saving a few bytes here
and there really isn’t worth making the code more confusing for human
programmers.</p>

<h2><a name="_Toc316488614">Nobody Cares About a Few Million Nanoseconds</a></h2>

<p class=MsoNormal>Similarly, there are times when you can rearrange your code
in some way to make it slightly faster by a few nanoseconds. These tricks also
usually make the code harder to read. When you consider that several billion
nanoseconds have passed in the time it takes you to read this sentence, saving
a few nanoseconds of execution time in your program won’t be noticed by the
player.</p>

<h2><a name="_Toc316488615">Summary</a></h2>

<p class=MsoNormal>This chapter hasn’t introduced any new Pygame programming
concepts that the Memory Puzzle game didn’t use, aside from using the <span
class=Literal>copy()</span> method of Surface objects. Just knowing a few
different concepts will let you create completely different games.</p>

<p class=MsoNormal>For practice, you can download buggy versions of the Sliding
Puzzle program from <span class=URL><a href="http://invpy.com/buggy/slidepuzzle">http://invpy.com/buggy/slidepuzzle</a></span>.</p>

</div>

</body>

</html>
