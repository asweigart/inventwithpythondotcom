<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 14 (filtered)">
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;}
@font-face
	{font-family:"Franklin Gothic Demi";
	panose-1:2 11 7 3 2 1 2 2 2 4;}
@font-face
	{font-family:"Lucida Sans Typewriter";
	panose-1:2 11 5 9 3 5 4 3 2 4;}
@font-face
	{font-family:"Lucida Console";
	panose-1:2 11 6 9 4 5 4 2 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
h1
	{mso-style-link:"Heading 1 Char";
	margin-top:24.0pt;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	page-break-after:avoid;
	border:none;
	padding:0in;
	font-size:36.0pt;
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;
	font-weight:normal;}
h2
	{mso-style-link:"Heading 2 Char";
	margin-top:10.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	page-break-after:avoid;
	font-size:16.0pt;
	font-family:"Calibri","sans-serif";}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	line-height:115%;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
span.Heading1Char
	{mso-style-name:"Heading 1 Char";
	mso-style-link:"Heading 1";
	font-family:"Franklin Gothic Demi","sans-serif";
	font-variant:small-caps;
	color:black;}
span.Heading2Char
	{mso-style-name:"Heading 2 Char";
	mso-style-link:"Heading 2";
	font-family:"Times New Roman","serif";
	font-weight:bold;}
span.Definition
	{mso-style-name:Definition;
	font-family:"Calibri","sans-serif";
	font-weight:bold;}
span.URL
	{mso-style-name:URL;
	color:windowtext;
	text-decoration:underline;}
p.SourceCodeFeatured, li.SourceCodeFeatured, div.SourceCodeFeatured
	{mso-style-name:"Source Code \(Featured\)";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpFirst, li.SourceCodeFeaturedCxSpFirst, div.SourceCodeFeaturedCxSpFirst
	{mso-style-name:"Source Code \(Featured\)CxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpMiddle, li.SourceCodeFeaturedCxSpMiddle, div.SourceCodeFeaturedCxSpMiddle
	{mso-style-name:"Source Code \(Featured\)CxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeFeaturedCxSpLast, li.SourceCodeFeaturedCxSpLast, div.SourceCodeFeaturedCxSpLast
	{mso-style-name:"Source Code \(Featured\)CxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
span.SourceCode
	{mso-style-name:"Source Code";
	font-family:"Lucida Console";}
p.SampleRun, li.SampleRun, div.SampleRun
	{mso-style-name:"Sample Run";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpFirst, li.SampleRunCxSpFirst, div.SampleRunCxSpFirst
	{mso-style-name:"Sample RunCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpMiddle, li.SampleRunCxSpMiddle, div.SampleRunCxSpMiddle
	{mso-style-name:"Sample RunCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
p.SampleRunCxSpLast, li.SampleRunCxSpLast, div.SampleRunCxSpLast
	{mso-style-name:"Sample RunCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:6.0pt;
	margin-left:0in;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:9.0pt;
	font-family:"Lucida Sans Typewriter";}
span.SourceLineNumber
	{mso-style-name:"Source Line Number";
	color:gray;}
p.TopicsCoveredbox, li.TopicsCoveredbox, div.TopicsCoveredbox
	{mso-style-name:"Topics Covered box";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpFirst, li.TopicsCoveredboxCxSpFirst, div.TopicsCoveredboxCxSpFirst
	{mso-style-name:"Topics Covered boxCxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpMiddle, li.TopicsCoveredboxCxSpMiddle, div.TopicsCoveredboxCxSpMiddle
	{mso-style-name:"Topics Covered boxCxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
p.TopicsCoveredboxCxSpLast, li.TopicsCoveredboxCxSpLast, div.TopicsCoveredboxCxSpLast
	{mso-style-name:"Topics Covered boxCxSpLast";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	background:#DBE5F1;
	border:none;
	padding:0in;
	font-size:11.0pt;
	font-family:"Times New Roman","serif";}
span.Literal
	{mso-style-name:Literal;
	font-family:Courier;}
span.SourceCodeComment
	{mso-style-name:"Source Code Comment";
	color:#7F7F7F;}
span.SourceCodeFilename
	{mso-style-name:"Source Code Filename";
	font-family:"Lucida Sans Typewriter";}
span.Filename
	{mso-style-name:Filename;
	font-style:italic;}
p.ChapterQuotes, li.ChapterQuotes, div.ChapterQuotes
	{mso-style-name:"Chapter Quotes";
	margin-top:30.0pt;
	margin-right:1.0in;
	margin-bottom:30.0pt;
	margin-left:1.0in;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpFirst, li.ChapterQuotesCxSpFirst, div.ChapterQuotesCxSpFirst
	{mso-style-name:"Chapter QuotesCxSpFirst";
	margin-top:30.0pt;
	margin-right:1.0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpMiddle, li.ChapterQuotesCxSpMiddle, div.ChapterQuotesCxSpMiddle
	{mso-style-name:"Chapter QuotesCxSpMiddle";
	margin-top:0in;
	margin-right:1.0in;
	margin-bottom:0in;
	margin-left:1.0in;
	margin-bottom:.0001pt;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.ChapterQuotesCxSpLast, li.ChapterQuotesCxSpLast, div.ChapterQuotesCxSpLast
	{mso-style-name:"Chapter QuotesCxSpLast";
	margin-top:0in;
	margin-right:1.0in;
	margin-bottom:30.0pt;
	margin-left:1.0in;
	text-align:justify;
	line-height:115%;
	font-size:14.0pt;
	font-family:"Times New Roman","serif";}
p.SourceCodeHeadline, li.SourceCodeHeadline, div.SourceCodeHeadline
	{mso-style-name:"Source Code \(Headline\)";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpFirst, li.SourceCodeHeadlineCxSpFirst, div.SourceCodeHeadlineCxSpFirst
	{mso-style-name:"Source Code \(Headline\)CxSpFirst";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpMiddle, li.SourceCodeHeadlineCxSpMiddle, div.SourceCodeHeadlineCxSpMiddle
	{mso-style-name:"Source Code \(Headline\)CxSpMiddle";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
p.SourceCodeHeadlineCxSpLast, li.SourceCodeHeadlineCxSpLast, div.SourceCodeHeadlineCxSpLast
	{mso-style-name:"Source Code \(Headline\)CxSpLast";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	line-height:115%;
	border:none;
	padding:0in;
	font-size:7.0pt;
	font-family:"Lucida Sans Typewriter";
	color:black;}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-link:"Balloon Text";
	font-family:"Tahoma","sans-serif";}
.MsoChpDefault
	{font-family:"Calibri","sans-serif";}
.MsoPapDefault
	{margin-bottom:10.0pt;
	line-height:115%;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US>
<div style='float: right; height: 310px; font-family: sans-serif;'>Ad: Programming books by Al Sweigart<br />
    <a href='http://www.nostarch.com/automatestuff' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src='/images/cover_automate_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
    <a href='http://www.amazon.com/gp/product/0982106017?ie=UTF8&tag=playwithpyth-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0982106017' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src='/images/cover_inventwithpython_thumb.jpg' style="height: 200px; border: solid black 1px;" /></a>
    <a href='http://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&tag=playwithpyth-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0982106017' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src='/images/cover_makinggames_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
    <a href='http://www.amazon.com/gp/product/1482614375/ref=as_li_qf_sp_asin_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1482614375&linkCode=as2&tag=playwithpyth-20' onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src='/images/cover_hackingciphers_thumb.png' style="height: 200px; border: solid black 1px;" /></a>
</div>

<div class=WordSection1>

<p class=MsoNormal align=center style='text-align:center'><img width=327
height=180 id="Picture 35" src="chapter15_files/image001.jpg">  </p>

<div style='border:none;border-bottom:solid #4F81BD 1.0pt;padding:0in 0in 1.0pt 0in'>

<h1><a name="_Toc353630813"><span style='font-variant:normal !important;
text-transform:uppercase'>The Affine Cipher</span></a></h1>

</div>

<div style='border:solid windowtext 1.0pt;padding:4.0pt 4.0pt 4.0pt 4.0pt;
background:#DBE5F1'>

<p class=TopicsCoveredboxCxSpFirst style='background:#DBE5F1;border:none;
padding:0in'>Topics Covered In This Chapter:</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The Affine Cipher</p>

<p class=TopicsCoveredboxCxSpMiddle style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>Generating random keys</p>

<p class=TopicsCoveredboxCxSpLast style='margin-left:.25in;text-indent:-.25in;
background:#DBE5F1;border:none;padding:0in'><span style='font-family:Symbol'>·<span
style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>How many different keys can the affine cipher have?</p>

</div>

<p class=ChapterQuotesCxSpFirst>“I should be able to whisper something in your
ear, even if your ear is 1000 miles away, and the government disagrees with
that.”</p>

<p class=ChapterQuotesCxSpMiddle>&nbsp;</p>

<p class=ChapterQuotesCxSpLast align=right style='text-align:right'><span
style='font-size:11.0pt;line-height:115%'>Philip Zimmermann, creator of Pretty
Good Privacy (PGP), the most widely used email encryption software in the world.</span></p>

<p class=MsoNormal>This chapter’s programs implement the multiplicative and
affine ciphers. The multiplicative cipher is like the Caesar cipher from
Chapter 6, except it uses multiplication instead of addition. The affine cipher
is the multiplicative cipher, which is then encrypted by the Caesar cipher on
top of that. The affine cipher needs two keys: one for the multiplicative
cipher multiplication and the other for the Caesar cipher addition.</p>

<p class=MsoNormal>For the affine cipher program, we will use a single integer
for the key. We will use some simple math to split this key into the two keys,
which we will call Key A and Key B.</p>

<h2><a name="_Toc353630814">Source Code of the Affine Cipher Program</a></h2>

<p class=MsoNormal>How the affine cipher works was covered in the last chapter.
Here is the source code for a Python program that implements the affine cipher.
Open a new file editor window by clicking on <strong>File</strong> &#9658; <strong>New
Window</strong>. Type in the following code into the file editor, and then save
it as <span class=Filename>affineCipher.py</span>. Press <strong>F5</strong> to
run the program. Note that first you will need to download the <span
class=Filename>pyperclip.py</span> module and place this file in the same
directory as the <span class=Filename>affineCipher.py</span> file. You can
download this file from <span class=URL><u>http://invpy.com/pyperclip.py</u></span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst align=right style='text-align:right'><span
class=SourceCodeFilename><span style='font-size:13.0pt;line-height:115%'>Source
code for affineCipher.py</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 1.</span> <span
class=SourceCodeComment># Affine Cipher</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 4.</span>
import sys, pyperclip, cryptomath, random</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 5.</span>
SYMBOLS = &quot;&quot;&quot; !&quot;#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]
^_`abcdefghijklmnopqrstuvwxyz{|}~&quot;&quot;&quot; <span
class=SourceCodeComment># note the space at the front</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 6. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 7. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 8.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 9.</span>
myMessage = &quot;&quot;&quot;&quot;A computer would deserve to be called
intelligent if it could deceive a human into believing that it was human.&quot;
-Alan Turing&quot;&quot;&quot;</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>10.</span>
myKey = 2023</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>11.</span>
myMode = 'encrypt' <span class=SourceCodeComment># set to 'encrypt' or
'decrypt'</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>12. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>13.</span>
if myMode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>14.</span>
translated = encryptMessage(myKey, myMessage)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>15.</span>
elif myMode == 'decrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>16.</span>
translated = decryptMessage(myKey, myMessage)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>17.     </span><span
class=SourceCode><span style='font-size:10.0pt;line-height:115%'>print('Key:
%s' % (myKey))</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>18.</span>
print('%sed text:' % (myMode.title()))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>19.</span>
print(translated)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>20.</span>
pyperclip.copy(translated)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>21.</span>
print('Full %sed text copied to clipboard.' % (myMode))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>22. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>23. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>24.</span>
def getKeyParts(key):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>25.</span>
keyA = key // len(SYMBOLS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>26.</span>
keyB = key % len(SYMBOLS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>27.</span>
return (keyA, keyB)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>28. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>29. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>30.</span>
def checkKeys(keyA, keyB, mode):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>31.</span>
if keyA == 1 and mode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>32.</span>
sys.exit('The affine cipher becomes incredibly weak when key A is set to 1.
Choose a different key.')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>33.</span>
if keyB == 0 and mode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>34.</span>
sys.exit('The affine cipher becomes incredibly weak when key B is set to 0.
Choose a different key.')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>35.</span>
if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; len(SYMBOLS) - 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>36.</span>
sys.exit('Key A must be greater than 0 and Key B must be between 0 and %s.' %
(len(SYMBOLS) - 1))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>37.</span>
if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>38.</span>
sys.exit('Key A (%s) and the symbol set size (%s) are not relatively prime. Choose
a different key.' % (keyA, len(SYMBOLS)))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>39. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>40. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>41.</span>
def encryptMessage(key, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>42.</span>
keyA, keyB = getKeyParts(key)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>43.</span>
checkKeys(keyA, keyB, 'encrypt')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>44.</span>
ciphertext = ''</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>45.</span>
for symbol in message:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>46.</span>
if symbol in SYMBOLS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>47.</span>
<span class=SourceCodeComment># encrypt this symbol</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>48.</span>
symIndex = SYMBOLS.find(symbol)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>49.</span>
ciphertext += SYMBOLS[(symIndex * keyA + keyB) % len(SYMBOLS)]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>50.</span>
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>51.</span>
ciphertext += symbol <span class=SourceCodeComment># just append this symbol
unencrypted</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>52.</span>
return ciphertext</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>53. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>54. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>55.</span>
def decryptMessage(key, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>56.</span>
keyA, keyB = getKeyParts(key)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>57.</span>
checkKeys(keyA, keyB, 'decrypt')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>58.</span>
plaintext = ''</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>59.</span>
modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>60.</span>
</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>61.</span>
for symbol in message:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>62.</span>
if symbol in SYMBOLS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>63.</span>
<span class=SourceCodeComment># decrypt this symbol</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>64.</span>
symIndex = SYMBOLS.find(symbol)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>65.</span>
plaintext += SYMBOLS[(symIndex - keyB) * modInverseOfKeyA % len(SYMBOLS)]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>66.</span>
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>67.</span>
plaintext += symbol <span class=SourceCodeComment># just append this symbol
undecrypted</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>68.</span>
return plaintext</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>69. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>70. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>71.</span> <span
class=SourceCodeComment><span style='color:windowtext'>def getRandomKey():</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>72.</span><span
class=SourceCodeComment><span style='color:windowtext'>     while True:</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>73.</span><span
class=SourceCodeComment><span style='color:windowtext'>         keyA =
random.randint(2, len(SYMBOLS))</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>74.</span><span
class=SourceCodeComment><span style='color:windowtext'>         keyB =
random.randint(2, len(SYMBOLS))</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>75.</span><span
class=SourceCodeComment><span style='color:windowtext'>         if
cryptomath.gcd(keyA, len(SYMBOLS)) == 1:</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>76.</span><span
class=SourceCodeComment><span style='color:windowtext'>             return keyA
* len(SYMBOLS) + keyB</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>77. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>78.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>79.</span><span
class=SourceCodeComment><span style='color:windowtext'> </span># If
affineCipher.py is run (instead of imported as a module) call</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>80.</span><span
class=SourceCodeComment><span style='color:windowtext'> </span># the main()
function.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>81.</span><span
class=SourceCodeComment><span style='color:windowtext'> if __name__ ==
'__main__':</span></span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>82.</span><span
class=SourceCodeComment><span style='color:windowtext'>     main()</span></span></p>

</div>

<h2><a name="_Toc353630815">Sample Run of the Affine Cipher Program</a></h2>

<p class=MsoNormal>When you press <strong>F5</strong> from the file editor to run
this program, the output will look like this:</p>

<div style='border:solid windowtext 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SampleRunCxSpFirst>Key: 2023</p>

<p class=SampleRunCxSpMiddle>Encrypted text:</p>

<p class=SampleRunCxSpMiddle>fX&lt;*h&gt;}(rTH&lt;Rh()?&lt;?T]TH=T&lt;rh&lt;tT&lt;*_))T?&lt;ISrT))I~TSr&lt;Ii&lt;Ir&lt;*h()?&lt;?T*TI=T&lt;_&lt;4(&gt;_S&lt;ISrh&lt;tT)IT=IS~&lt;r4_r&lt;Ir&lt;R_]&lt;4(&gt;_SEf&lt;0X)_S&lt;</p>

<p class=SampleRunCxSpMiddle>k(HIS~</p>

<p class=SampleRunCxSpLast>Full encrypted text copied to clipboard.</p>

</div>

<p class=MsoNormal>The message “&quot;A computer would deserve to be called
intelligent if it could deceive a human into believing that it was human.&quot;
-Alan Turing” gets encrypted with the key 2023 into the above ciphertext.</p>

<p class=MsoNormal>To decrypt, paste this text as the new value to be stored in
<span class=Literal>myMessage</span> and change <span class=Literal>myMode</span>
to the string <span class=Literal>'decrypt'</span>.</p>

<h2><a name="_Toc353630816">Practice Exercises, Chapter 15, Set A</a></h2>

<p class=MsoNormal>Practice exercises can be found at <span class=URL><u>http://invpy.com/hackingpractice15A</u></span>.</p>

<h2><a name="_Toc353630817">How the Program Works</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 1.</span> <span
class=SourceCodeComment># Affine Cipher</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 2.</span> <span
class=SourceCodeComment># http://inventwithpython.com/hacking (BSD Licensed)</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 4.</span>
import sys, pyperclip, cryptomath, random</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber> 5.</span>
SYMBOLS = &quot;&quot;&quot; !&quot;#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]
^_`abcdefghijklmnopqrstuvwxyz{|}~&quot;&quot;&quot; <span
class=SourceCodeComment># note the space at the front</span></p>

</div>

<p class=MsoNormal>Lines 1 and 2 are the usual comments describing what the
program is. There is also an <span class=Literal>import</span> statement for
the modules used in this program. </p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <span class=Literal>sys</span> module is imported for the <span
class=Literal>exit()</span> function.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <span class=Literal>pyperclip</span> module is imported for
the <span class=Literal>copy()</span> clipboard function. </p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in'><span
style='font-family:Symbol'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span>The <span class=Literal>cryptomath</span> module that we created
in the last chapter is imported for the <span class=Literal>gcd()</span> and <span
class=Literal>findModInverse()</span> function.</p>

<p class=MsoNormal>In our program, the string stored in the <span
class=Literal>SYMBOLS</span> variable is the symbol set. The symbol set is the
list of all characters that can be encrypted. Any characters in the message to
be encrypted that don’t appear in <span class=Literal>SYMBOLS</span> will be
added to the ciphertext unencrypted.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber> 8.</span>
def main():</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 9.</span>
myMessage = &quot;&quot;&quot;&quot;A computer would deserve to be called
intelligent if it could deceive a human into believing that it was human.&quot;
-Alan Turing&quot;&quot;&quot;</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>10.</span>
myKey = 2023</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>11.</span>
myMode = 'encrypt' <span class=SourceCodeComment># set to 'encrypt' or
'decrypt'</span></p>

</div>

<p class=MsoNormal>The <span class=Literal>main()</span> function is almost
exactly the same as the one from the transposition cipher programs. The
message, key, and mode are stored in variables on lines 9, 10, and 11. </p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>13.</span>
if myMode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>14.</span>
translated = encryptMessage(myKey, myMessage)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>15.</span>
elif myMode == 'decrypt':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>16.</span>
translated = decryptMessage(myKey, myMessage)</p>

</div>

<p class=MsoNormal>If <span class=Literal>myMode</span> is set to <span
class=Literal>'encrypt'</span>, then line 14 will be executed and the return
value of <span class=Literal>encryptMessage()</span> is stored in <span
class=Literal>translated</span>. Or else, if <span class=Literal>myMode</span>
is set to <span class=Literal>'decrypt'</span>, then <span class=Literal>decryptMessage()</span>
is called on line 16 and the return value is stored in <span class=Literal>translated</span>.</p>

<p class=MsoNormal>Either way, after the execution has passed line 16, the <span
class=Literal>translated</span> variable will have the encrypted or decrypted
version of the message in <span class=Literal>myMessage</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>17.     </span>print('Key:
%s' % (myKey))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>18.</span>
print('%sed text:' % (myMode.title()))</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>19.</span>
print(translated)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>20.</span>
pyperclip.copy(translated)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>21.</span>
print('Full %sed text copied to clipboard.' % (myMode))</p>

</div>

<p class=MsoNormal>The string in <span class=Literal>translated</span> (which
is the encrypted or decrypted version of the string in <span class=Literal>myMessage</span>)
is displayed on the screen on line 19 and copied to the clipboard on line 20.</p>

<h2><a name="_Toc353630818">Splitting One Key into Two Keys</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>24.</span>
def getKeyParts(key):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>25.</span>
keyA = key // len(SYMBOLS)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>26.</span>
keyB = key % len(SYMBOLS)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>27.</span>
return (keyA, keyB)</p>

</div>

<p class=MsoNormal>The affine cipher is like the Caesar cipher, except that it
uses multiplication and addition (with two integer keys, which we called Key A
and Key B) instead of just addition (with one key). It’s easier to remember
just one number, so we will use a mathematical trick to convert between two
keys and one key.</p>

<p class=MsoNormal>The <span class=Literal>getKeyParts()</span> function splits
a single integer key into two integers for Key A and Key B. The single key (which
is in the parameter key) is divided by the size of the symbol set, and Key A is
the quotient and Key B is the remainder. The quotient part (without any
remainder) can be calculated using the <span class=Literal>//</span> integer
division operator, which is what line 25 does. The remainder part (without the
quotient) can be calculated using the <span class=Literal>%</span> mod operator,
which is what line 26 does.</p>

<p class=MsoNormal>It is assumed that the symbol set, as well as the size of
the symbol set, is publicly known along with the rest of the source code.</p>

<p class=MsoNormal>For example, with <span class=Literal>2023</span> as the <span
class=Literal>key</span> parameter and a <span class=Literal>SYMBOLS</span>
string of 95 characters, Key A would be <span class=Literal>2023 // 95</span>
or <span class=Literal>21</span> and Key B would be <span class=Literal>2023 %
95</span> or <span class=Literal>28</span>.</p>

<p class=MsoNormal>To combine Key A and Key B back into the single key,
multiply Key A by the size of the symbol set and add Key B: <span
class=Literal>(21 * 95) + 28</span> evaluates to <span class=Literal>2023</span>.</p>

<h2><a name="_Toc353630819">The Tuple Data Type</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>27.</span>     return
(keyA, keyB)</p>

</div>

<p class=MsoNormal>A tuple value is similar to a list: it is a value that can
store other values, which can be accessed with indexes or slices. However, the
values in a tuple cannot be modified. There is no <span class=Literal>append()</span>
method for tuple values. A tuple is written using parentheses instead of square
brackets. The value returned on line 27 is a tuple.</p>

<p class=MsoNormal>For technical reasons beyond the scope of this book, the
Python interpreter can execute code faster if it uses tuples compared to code
that uses lists.</p>

<h2><a name="_Toc353630820">Input Validation on the Keys</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>30.</span>
def checkKeys(keyA, keyB, mode):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>31.</span>
if keyA == 1 and mode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>32.</span>
sys.exit('The affine cipher becomes incredibly weak when key A is set to 1.
Choose a different key.')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>33.</span>
if keyB == 0 and mode == 'encrypt':</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>34.</span>
sys.exit('The affine cipher becomes incredibly weak when key B is set to 0.
Choose a different key.')</p>

</div>

<p class=MsoNormal>Encrypting with the affine cipher involves a character’s
index in <span class=Literal>SYMBOLS</span> being multiplied by Key A and added
to Key B. But if <span class=Literal>keyA</span> is <span class=Literal>1</span>,
the encrypted text will be very weak because multiplying the index by <span
class=Literal>1</span> does not change it. Similarly, if <span class=Literal>keyB</span>
is <span class=Literal>0</span>, the encrypted text will be weak because adding
the index to <span class=Literal>0</span> does not change it. And if both <span
class=Literal>keyA</span> was <span class=Literal>1</span> and <span
class=Literal>keyB</span> was <span class=Literal>0</span>, the “encrypted”
message would be the exact same as the original message. It wouldn’t be
encrypted at all!</p>

<p class=MsoNormal>The <span class=Literal>if</span> statements on line 31 and
33 check for these “weak key” conditions, and exit the program with a message
telling the user what was wrong. Notice on lines 32 and 34, a string is being
passed to the <span class=Literal>sys.exit()</span> call. The <span
class=Literal>sys.exit()</span> function has an optional parameter of a string
that will be printed to the screen before terminating the program. This can be
used to display an error message on the screen before the program quits.</p>

<p class=MsoNormal>Of course, these checks only apply to prevent you from
encrypting with weak keys. If <span class=Literal>mode</span> is set to <span
class=Literal>'decrypt'</span>, then the checks on lines 31 and 33 don’t apply.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>35.</span>
if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; len(SYMBOLS) - 1:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>36.</span>
sys.exit('Key A must be greater than 0 and Key B must be between 0 and %s.' %
(len(SYMBOLS) - 1))</p>

</div>

<p class=MsoNormal>The condition on line 35 checks if <span class=Literal>keyA</span>
is a negative number (that is, it is greater than <span class=Literal>0</span>)
<em>or</em> if <span class=Literal>keyB</span> is greater than <span
class=Literal>0</span> <em>or</em> less than the size of the symbol set minus one.
(The reason the Key B check has this range is described later in the “How Many
Keys Does the Affine Cipher Have?” section.) If any of these things are <span
class=Literal>True</span>, the keys are invalid and the program exits.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>37.</span>
if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>38.</span>
sys.exit('Key A (%s) and the symbol set size (%s) are not relatively prime.
Choose a different key.' % (keyA, len(SYMBOLS)))</p>

</div>

<p class=MsoNormal>Finally, Key A must be relatively prime with the symbol set
size. This means that the greatest common divisor of <span class=Literal>keyA</span>
and <span class=Literal>len(SYMBOLS)</span> must be equal to <span
class=Literal>1</span>. Line 37’s <span class=Literal>if</span> statement
checks for this and exits the program if they are not relatively prime.</p>

<p class=MsoNormal>If all of the conditions in the <span class=Literal>checkKeys()</span>
function were <span class=Literal>False</span>, there is nothing wrong with the
key and the program will not exit. Line 38 is the last line in the function, so
the program execution next returns to the line that originally called <span
class=Literal>checkKeys()</span>.</p>

<h2><a name="_Toc353630821">The Affine Cipher Encryption Function</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>41.</span> def
encryptMessage(key, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>42.</span>
keyA, keyB = getKeyParts(key)</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>43.</span>
checkKeys(keyA, keyB, 'encrypt')</p>

</div>

<p class=MsoNormal>First we get the integer values for Key A and Key B from the
<span class=Literal>getKeyParts()</span> function. These values are checked if they
are valid keys or not by passing them to the <span class=Literal>checkKeys()</span>
function. If the <span class=Literal>checkKeys()</span> function does not cause
the program to exit, then the rest of the code in the <span class=Literal>encryptMessage()</span>
function after line 43 can assume that the keys are valid.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>44.</span>
ciphertext = ''</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>45.</span>
for symbol in message:</p>

</div>

<p class=MsoNormal>The <span class=Literal>ciphertext</span> variable will eventually
hold the encrypted string, but starts off as a blank string. The <span
class=Literal>for</span> loop that begins on line 45 will iterate through each
of the characters in <span class=Literal>message</span>, and then add the
encrypted character to <span class=Literal>ciphertext</span>. By the time the <span
class=Literal>for</span> loop is done looping, the <span class=Literal>ciphertext</span>
variable will have the complete string of the encrypted message.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>46.</span>
if symbol in SYMBOLS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>47.</span>
<span class=SourceCodeComment># encrypt this symbol</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>48.</span>
symIndex = SYMBOLS.find(symbol)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>49.</span>
ciphertext += SYMBOLS[(symIndex * keyA + keyB) % len(SYMBOLS)]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>50.</span>
else:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>51.</span>
ciphertext += symbol <span class=SourceCodeComment># just append this symbol
unencrypted</span></p>

</div>

<p class=MsoNormal>On each iteration of the loop, the <span class=Literal>symbol</span>
variable is assigned the single character from <span class=Literal>message</span>.
If this character exists in <span class=Literal>SYMBOLS</span> (that is, our
symbol set), then the index in <span class=Literal>SYMBOLS</span> is found and
assigned to <span class=Literal>symIndex</span>. The value in <span
class=Literal>symIndex</span> is the “number” version of the character.</p>

<p class=MsoNormal>To encrypt it, we need to calculate the index of the
encrypted letter. We multiply this <span class=Literal>symIndex</span> by <span
class=Literal>keyA</span> and add <span class=Literal>keyB</span>, and mod the
number by the size of the symbol set (that is, the expression <span
class=Literal>len(SYMBOLS)</span>). We mod by <span class=Literal>len(SYMBOLS)</span>
because the affine cipher has a similar “wrap-around” issue that the Caesar
cipher had. Modding by <span class=Literal>len(SYMBOLS)</span> handles the
“wrap-around” by ensuring the calculated index is always between <span
class=Literal>0</span> up to (but not including) <span class=Literal>len(SYMBOLS)</span>.
The number that we calculate will be the index in <span class=Literal>SYMBOLS</span>
of the encrypted character, which is concatenated to the end of the string in <span
class=Literal>ciphertext</span>.</p>

<p class=MsoNormal>Everything that happens in the above paragraph was done on
line 49.</p>

<p class=MsoNormal>If <span class=Literal>symbol</span> was not in our symbol
set, then <span class=Literal>symbol</span> is concatenated to the end of the <span
class=Literal>ciphertext</span> string on line 51.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>52.</span>     return
ciphertext</p>

</div>

<p class=MsoNormal>Once we have iterated through each character in the message
string, the <span class=Literal>ciphertext</span> variable should contain the
full encrypted string. This string is returned from <span class=Literal>encryptMessage()</span>.</p>

<h2><a name="_Toc353630822">The Affine Cipher Decryption Function</a></h2>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>55.</span>
def decryptMessage(key, message):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>56.</span>
keyA, keyB = getKeyParts(key)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>57.</span>
checkKeys(keyA, keyB, 'decrypt')</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>58.</span>
plaintext = ''</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>59.</span>
modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))</p>

</div>

<p class=MsoNormal>The <span class=Literal>decryptMessage()</span> function is
almost the same as the <span class=Literal>encryptMessage()</span>. Lines 56 to
58 are equivalent to lines 44 to 46.</p>

<p class=MsoNormal>However, instead of multiplying by Key A, the decryption
process needs to multiply by the modular inverse of Key A. The mod inverse can
be calculated by calling <span class=Literal>cryptomath.findModInverse()</span>.
This function was explained in the previous chapter.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>61.</span>
for symbol in message:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>62.</span>
if symbol in SYMBOLS:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>63.</span>
<span class=SourceCodeComment># decrypt this symbol</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>64.</span>
symIndex = SYMBOLS.find(symbol)</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>65.</span>
plaintext += SYMBOLS[(symIndex - keyB) * modInverseOfKeyA % len(SYMBOLS)]</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>66.</span>
else:</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>67.</span>
plaintext += symbol <span class=SourceCodeComment># just append this symbol
undecrypted</span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>68.</span>
return plaintext</p>

</div>

<p class=MsoNormal>Lines 61 to 68 are almost identical to the <span
class=Literal>encryptMessage()</span> function’s lines 45 to 52. The only
difference is on line 65. In the <span class=Literal>encryptMessage()</span>
function, the symbol index was multiplied by Key A and then had Key B added to
it. In <span class=Literal>decryptMessage()</span>’s line 65, the symbol index
first has Key B subtracted from it, and then is multiplied by the modular
inverse. Then this number is modded by the size of the symbol set, <span
class=Literal>len(SYMBOLS)</span>. This is how the decryption process undoes
the encryption.</p>

<h2><a name="_Toc353630823">Generating Random Keys</a></h2>

<p class=MsoNormal>It can be difficult to come up with a valid key for the
affine cipher, so we will create a <span class=Literal>getRandomKey()</span>
function that generates a random (but valid) key for the user to use. To use
this, the user simply has to change line 10 to store the return value of <span
class=Literal>getRandomKey()</span> in the <span class=Literal>myKey</span>
variable:</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeatured><span class=SourceLineNumber>10.</span>     myKey =
<strong><span style='font-family:"Lucida Sans Typewriter"'>getRandomKey()</span></strong></p>

</div>

<p class=MsoNormal>Now the key that is used to encrypt is randomly selected for
us. It will be printed to the screen when line 17 is executed.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>71.</span> <span
class=SourceCodeComment><span style='color:windowtext'>def getRandomKey():</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>72.</span><span
class=SourceCodeComment><span style='color:windowtext'>     while True:</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>73.</span><span
class=SourceCodeComment><span style='color:windowtext'>         keyA =
random.randint(2, len(SYMBOLS))</span></span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>74.</span><span
class=SourceCodeComment><span style='color:windowtext'>         keyB =
random.randint(2, len(SYMBOLS))</span></span></p>

</div>

<p class=MsoNormal style='line-height:105%'>The code in <span class=Literal>getRandomKey()</span>enters
a <span class=Literal>while</span> loop on line 72 where the condition is <span
class=Literal>True</span>. This is called an <span class=Definition><span
style='font-size:12.0pt;line-height:105%'>infinite loop</span></span>, because
the loop’s condition is never <span class=Literal>False</span>. If your program
gets stuck in an infinite loop, you can terminate it by pressing Ctrl-C or
Ctrl-D.</p>

<p class=MsoNormal>The code on lines 73 and 74 determine random numbers between
2 and the size of the symbol set for <span class=Literal>keyA</span> and for <span
class=Literal>keyB</span>. This way there is no chance that Key A or Key B are
equal to the invalid values <span class=Literal>0</span> or <span
class=Literal>1</span>.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>75.</span><span
class=SourceCodeComment><span style='color:windowtext'>         if
cryptomath.gcd(keyA, len(SYMBOLS)) == 1:</span></span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>76.</span><span
class=SourceCodeComment><span style='color:windowtext'>             return keyA
* len(SYMBOLS) + keyB</span></span></p>

</div>

<p class=MsoNormal>The <span class=Literal>if</span> statement on line 75
checks to make sure that <span class=Literal>keyA</span> is relatively prime
with the size of the symbol set by calling the <span class=Literal>gcd()</span>
function in the <span class=Literal>cryptomath</span> module. If it is, then
these two keys are combined into a single key by multiplying <span
class=Literal>keyA</span> by the symbol set size and adding <span
class=Literal>keyB</span>. (This is the opposite of what the <span
class=Literal>getKeyParts()</span> function does.) This value is returned from
the <span class=Literal>getRandomKey()</span> function.</p>

<p class=MsoNormal>If the condition on line 75 was <span class=Literal>False</span>,
then the code loops back to the start of the <span class=Literal>while</span>
loop on line 73 and picks random numbers for <span class=Literal>keyA</span>
and <span class=Literal>keyB</span> again. The infinite loop ensures that the
program keeps looping again and again until it finds random numbers that are
valid keys.</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeHeadline>affineCipher.py </p>

<p class=SourceCodeFeaturedCxSpFirst><span class=SourceLineNumber>79.</span><span
class=SourceCodeComment><span style='color:windowtext'> </span># If
affineCipher.py is run (instead of imported as a module) call</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>80.</span><span
class=SourceCodeComment><span style='color:windowtext'> </span># the main()
function.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>81.</span><span
class=SourceCodeComment><span style='color:windowtext'> if __name__ == '__main__':</span></span></p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>82.</span><span
class=SourceCodeComment><span style='color:windowtext'>     main()</span></span></p>

</div>

<p class=MsoNormal>Lines 81 and 82 call the <span class=Literal>main()</span>
function if this program was run by itself, rather than imported by another
program.</p>

<h2><a name="_Toc353630824">The Second Affine Key Problem: How Many Keys Can
the Affine Cipher Have?</a></h2>

<p class=MsoNormal>Key B of the affine cipher is limited to the size of the
symbol set (in the case of <span class=Filename>affineCipher.py</span>, <span
class=Literal>len(SYMBOLS)</span> is <span class=Literal>95</span>). But it
seems like Key A could be as large as we want it to be (as long as it is
relatively prime to the symbol set size). Therefore the affine cipher should
have an infinite number of keys and therefore cannot be brute-forced.</p>

<p class=MsoNormal>As it turns out, no. Remember how large keys in the Caesar
cipher ended up being the same as smaller keys due to the “wrap-around” effect.
With a symbol set size of 26, the key <span class=Literal>27</span> in the
Caesar cipher would produce the same encrypted text as the key <span
class=Literal>1</span>. The affine cipher also “wraps around”. </p>

<p class=MsoNormal>Since the Key B part of the affine cipher is the same as the
Caesar cipher, we know it is limited from 1 to the size of the symbol set. But
to find out if the affine cipher’s Key A is also limited, we can write a small
program to encrypt a message with several different integers for Key A and see
what the ciphertext looks like.</p>

<p class=MsoNormal>Open a new file editor window and type the following source
code. Save this file as <span class=Filename>affineKeyTest.py</span>, and then
press <strong>F5</strong> to run it.</p>

<p class=MsoNormal>&nbsp;</p>

<div style='border:double #404040 1.5pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SourceCodeFeaturedCxSpFirst align=right style='text-align:right'><span
class=SourceCodeFilename><span style='font-size:13.0pt;line-height:115%'>Source
code for affineKeyTest.py</span></span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 1.</span> <span
class=SourceCodeComment># This program proves that the keyspace of the affine
cipher is limited</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 2.</span> <span
class=SourceCodeComment># to len(SYMBOLS) ^ 2.</span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 3. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 4.</span>
import affineCipher, cryptomath</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 5. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 6.</span>
message = 'Make things as simple as possible, but not simpler.'</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 7.</span>
for keyA in range(2, 100):</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 8.</span>
key = keyA * len(affineCipher.SYMBOLS) + 1</p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber> 9. </span></p>

<p class=SourceCodeFeaturedCxSpMiddle><span class=SourceLineNumber>10.</span>
if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) == 1:</p>

<p class=SourceCodeFeaturedCxSpLast><span class=SourceLineNumber>11.</span>
print(keyA, affineCipher.encryptMessage(key, message)) </p>

</div>

<p class=MsoNormal>This is a fairly simple program. It imports the <span
class=Literal>affineCipher</span> module for its <span class=Literal>encryptMessage()</span>
function and the <span class=Literal>cryptomath</span> module for its <span
class=Literal>gcd()</span> function. We will always encrypt the string stored
in the <span class=Literal>message</span> variable. The <span class=Literal>for</span>
loop will range between <span class=Literal>2</span> (since <span
class=Literal>0</span> and <span class=Literal>1</span> are not allowed as
valid Key A integers) and <span class=Literal>100</span>.</p>

<p class=MsoNormal>On each iteration of the loop, we calculate the key from the
current <span class=Literal>keyA</span> value and always use <span
class=Literal>1</span> for Key B (this is why 1 is added on line 8). Remember
that it is not valid to use a Key A that is not relatively prime with the
symbol set size. So if the greatest common divisor of the key and the symbol
set size is not equal to <span class=Literal>1</span>, the <span class=Literal>if</span>
statement on line 10 will skip the call to <span class=Literal>encryptMessage()</span>
on line 11.</p>

<p class=MsoNormal>Basically, this program will print out the same message
encrypted with several different integers for Key A. The output of this program
will look like this:</p>

<div style='border:solid windowtext 1.0pt;padding:6.0pt 4.0pt 6.0pt 4.0pt'>

<p class=SampleRunCxSpFirst>2
{DXL!jRT^Ph!Dh!hT\bZL!Dh!b`hhTFZL9!Flj!^`j!hT\bZLf=</p>

<p class=SampleRunCxSpMiddle>3
I&amp;D2!_;&gt;M8\!&amp;\!\&gt;JSG2!&amp;\!SP\\&gt;)G2E!)b_!MP_!\&gt;JSG2YK</p>

<p class=SampleRunCxSpMiddle>4 vg0w!T$(&lt;
P!gP!P(8D4w!gP!D@PP(k4wQ!kXT!&lt;@T!P(8D4wLY</p>

<p class=SampleRunCxSpMiddle>6 q+gC!&gt;U[yO8!+8!8[s&amp;mC!+8!&amp;
88[1mCi!1D&gt;!y &gt;!8[s&amp;mC2u</p>

<p class=SampleRunCxSpMiddle>&nbsp;</p>

<p class=SampleRunCxSpMiddle><i>...skipped for brevity...</i></p>

<p class=SampleRunCxSpMiddle>&nbsp;</p>

<p class=SampleRunCxSpMiddle>92
X{]o!BfcTiE!{E!EcWNZo!{E!NQEEcxZo\!x?B!TQB!EcWNZoHV</p>

<p class=SampleRunCxSpMiddle>93
&amp;]IU!7OMCQ9!]9!9ME?GU!]9!?A99M[GUh![57!CA7!9ME?GU;d</p>

<p class=SampleRunCxSpMiddle>94 S?5;!,8729-!?-!-7304;!?-!01--7&gt;4;t!&gt;+,!21,!-7304;.r</p>

<p class=SampleRunCxSpMiddle>96
Nblf!uijoht!bt!tjnqmf!bt!qpttjcmf-!cvu!opu!tjnqmfs/</p>

<p class=SampleRunCxSpMiddle>97
{DXL!jRT^Ph!Dh!hT\bZL!Dh!b`hhTFZL9!Flj!^`j!hT\bZLf=</p>

<p class=SampleRunCxSpMiddle>98
I&amp;D2!_;&gt;M8\!&amp;\!\&gt;JSG2!&amp;\!SP\\&gt;)G2E!)b_!MP_!\&gt;JSG2YK</p>

<p class=SampleRunCxSpLast>99 vg0w!T$(&lt; P!gP!P(8D4w!gP!D@PP(k4wQ!kXT!&lt;@T!P(8D4wLY</p>

</div>

<p class=MsoNormal>Look carefully at the output. You’ll notice that the
ciphertext for Key A of <span class=Literal>2</span> is the exact same as the
ciphertext for Key A of <span class=Literal>97</span>! In fact, the ciphertext
from keys <span class=Literal>3</span> and <span class=Literal>98</span> are
the same, as are the ciphertext from keys <span class=Literal>4</span> and <span
class=Literal>99</span>!</p>

<p class=MsoNormal>Notice that 97 - 95 is 2. This is why a Key A of <span
class=Literal>97</span> does the same thing as a Key A of <span class=Literal>2</span>:
the encrypted output repeats itself (that is, “wraps around”) every 95 keys. The
affine cipher has the same “wrap-around” for the Key A as it does for Key B! It
seems like it is limited to the symbol set size.</p>

<p class=MsoNormal>95 possible Key A keys multiplied by 95 possible Key B keys
means there are 9,025 possible combinations. If you subtract the integers that
can’t be used for Key A (because they are not relatively prime with 95), this
number drops to 7,125 possible keys. </p>

<h2><a name="_Toc353630825">Summary</a></h2>

<p class=MsoNormal>7,125 is about the same number of keys that’s possible with
most transposition cipher messages, and we’ve already learned how to program a
computer to hack that number of keys with brute-force. This means that we’ll
have to toss the affine cipher onto the heap of weak ciphers that are easily
hacked.</p>

<p class=MsoNormal>The affine cipher isn’t any more secure than the previous
ciphers we’ve looked at. The transposition cipher can have more possible keys,
but the number of possible keys is limited to the size of the message. For a
message with only 20 characters, the transposition cipher can only have at most
18 keys (the keys 2 to 19). The affine cipher can be used to encrypt short
messages with more security than the Caesar cipher provided, since its number
of possible keys is based on the symbol set.</p>

<p class=MsoNormal>But we did learn some new mathematical concepts that we will
use later on. The concepts of modular arithmetic, greatest common divisor, and
modular inverses will help us in the RSA cipher at the end of this book.</p>

<p class=MsoNormal>But enough about how the affine cipher is weak in theory.
Let’s write a brute-force program that can actually break affine cipher
encrypted messages!</p>

</div>

</body>

</html>
