// Thanks to http://www.htmlescape.net/stringescape_tool.html
var sourceCodes = {
    "affineCipher": "# Affine Cipher\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport sys, pyperclip, cryptomath, random\nSYMBOLS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.\'\n\n\ndef main():\n    myMessage = \"\"\"\"A computer would deserve to be called intelligent if it could deceive a human into believing that it was human.\" -Alan Turing\"\"\"\n    myKey = 2894\n    myMode = \'encrypt\' # Set to either \'encrypt\' or \'decrypt\'.\n\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n    print(\'Key: %s\' % (myKey))\n    print(\'%sed text:\' % (myMode.title()))\n    print(translated)\n    pyperclip.copy(translated)\n    print(\'Full %sed text copied to clipboard.\' % (myMode))\n\n\ndef getKeyParts(key):\n    keyA = key \x2F\x2F len(SYMBOLS)\n    keyB = key % len(SYMBOLS)\n    return (keyA, keyB)\n\n\ndef checkKeys(keyA, keyB, mode):\n    if keyA == 1 and mode == \'encrypt\':\n        sys.exit(\'Cipher is weak if key A is 1. Choose a different key.\')\n    if keyB == 0 and mode == \'encrypt\':\n        sys.exit(\'Cipher is weak if key B is 0. Choose a different key.\')\n    if keyA \x3C 0 or keyB \x3C 0 or keyB \x3E len(SYMBOLS) - 1:\n        sys.exit(\'Key A must be greater than 0 and Key B must be between 0 and %s.\' % (len(SYMBOLS) - 1))\n    if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:\n        sys.exit(\'Key A (%s) and the symbol set size (%s) are not relatively prime. Choose a different key.\' % (keyA, len(SYMBOLS)))\n\n\ndef encryptMessage(key, message):\n    keyA, keyB = getKeyParts(key)\n    checkKeys(keyA, keyB, \'encrypt\')\n    ciphertext = \'\'\n    for symbol in message:\n        if symbol in SYMBOLS:\n            # Encrypt the symbol:\n            symbolIndex = SYMBOLS.find(symbol)\n            ciphertext += SYMBOLS[(symbolIndex * keyA + keyB) % len(SYMBOLS)]\n        else:\n            ciphertext += symbol # Append the symbol without encrypting.\n    return ciphertext\n\n\ndef decryptMessage(key, message):\n    keyA, keyB = getKeyParts(key)\n    checkKeys(keyA, keyB, \'decrypt\')\n    plaintext = \'\'\n    modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))\n\n    for symbol in message:\n        if symbol in SYMBOLS:\n            # Decrypt the symbol:\n            symbolIndex = SYMBOLS.find(symbol)\n            plaintext += SYMBOLS[(symbolIndex - keyB) * modInverseOfKeyA % len(SYMBOLS)]\n        else:\n            plaintext += symbol # Append the symbol without decrypting.\n    return plaintext\n\n\ndef getRandomKey():\n    while True:\n        keyA = random.randint(2, len(SYMBOLS))\n        keyB = random.randint(2, len(SYMBOLS))\n        if cryptomath.gcd(keyA, len(SYMBOLS)) == 1:\n            return keyA * len(SYMBOLS) + keyB\n\n\n# If affineCipher.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "affineHacker": "# Affine Cipher Hacker\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport pyperclip, affineCipher, detectEnglish, cryptomath\n\nSILENT_MODE = False\n\ndef main():\n    # You might want to copy \& paste this text from the source code at\n    # https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes\x2FaffineHacker.py\n    myMessage = \"\"\"\"5QG9ol3La6QI93!xQxaia6faQL9QdaQG1!!axQARLa!!AuaRLQADQALQG93!xQxaGaAfaQ1QX3o1RQARL9Qda!AafARuQLX1LQALQI1iQX3o1RN\"Q-5!1RQP36ARu\"\"\"\n\n    hackedMessage = hackAffine(myMessage)\n\n    if hackedMessage != None:\n        # The plaintext is displayed on the screen. For the convenience of\n        # the user, we copy the text of the code to the clipboard.\n        print(\'Copying hacked message to clipboard:\')\n        print(hackedMessage)\n        pyperclip.copy(hackedMessage)\n    else:\n        print(\'Failed to hack encryption.\')\n\n\ndef hackAffine(message):\n    print(\'Hacking...\')\n\n    # Python programs can be stopped at any time by pressing Ctrl-C (on\n    # Windows) or Ctrl-D (on Mac and Linux)\n    print(\'(Press Ctrl-C or Ctrl-D to quit at any time.)\')\n\n    # Brute-force by looping through every possible key\n    for key in range(len(affineCipher.SYMBOLS) ** 2):\n        keyA = affineCipher.getKeyParts(key)[0]\n        if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) != 1:\n            continue\n\n        decryptedText = affineCipher.decryptMessage(key, message)\n        if not SILENT_MODE:\n            print(\'Tried Key %s... (%s)\' % (key, decryptedText[:40]))\n\n        if detectEnglish.isEnglish(decryptedText):\n            # Check with the user if the decrypted key has been found.\n            print()\n            print(\'Possible encryption hack:\')\n            print(\'Key: %s\' % (key))\n            print(\'Decrypted message: \' + decryptedText[:200])\n            print()\n            print(\'Enter D if done, anything else to continue hacking:\')\n            response = input(\'\x3E \')\n\n            if response.strip().upper().startswith(\'D\'):\n                return decryptedText\n    return None\n\n\n# If affineHacker.py is run (instead of imported as a module)\n# call the main() function.\nif __name__ == \'__main__\':\n    main()",
    "affineKeyTest": "# This program proves that the keyspace of the affine cipher is limited\n# to less than len(SYMBOLS) ^ 2.\n\nimport affineCipher, cryptomath\n\nmessage = \'Make things as simple as possible, but not simpler.\'\nfor keyA in range(2, 80):\n    key = keyA * len(affineCipher.SYMBOLS) + 1\n\n    if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) == 1:\n        print(keyA, affineCipher.encryptMessage(key, message))",
    "caesarCipher": "# Caesar Cipher\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport pyperclip\n\n# The string to be encrypted\x2Fdecrypted:\nmessage = pyperclip.paste()\n\n# The encryption\x2Fdecryption key:\nkey = 22\n\n# Whether the program encrypts or decrypts:\nmode = \'decrypt\' # Set to either \'encrypt\' or \'decrypt\'.\n\n# Every possible symbol that can be encrypted:\nSYMBOLS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.\'\n\n# Stores the encrypted\x2Fdecrypted form of the message:\ntranslated = \'\'\n\nfor symbol in message:\n    # Note: Only symbols in the `SYMBOLS` string can be encrypted\x2Fdecrypted.\n    if symbol in SYMBOLS:\n        symbolIndex = SYMBOLS.find(symbol)\n\n        # Perform encryption\x2Fdecryption:\n        if mode == \'encrypt\':\n            translatedIndex = symbolIndex + key\n        elif mode == \'decrypt\':\n            translatedIndex = symbolIndex - key\n\n        # Handle wrap-around, if needed:\n        if translatedIndex \x3E= len(SYMBOLS):\n            translatedIndex = translatedIndex - len(SYMBOLS)\n        elif translatedIndex \x3C 0:\n            translatedIndex = translatedIndex + len(SYMBOLS)\n\n        translated = translated + SYMBOLS[translatedIndex]\n    else:\n        # Append the symbol without encrypting\x2Fdecrypting:\n        translated = translated + symbol\n\n# Output the translated string:\nprint(translated)\npyperclip.copy(translated)\n",
    "caesarHacker": "# Caesar Cipher Hacker\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\nimport pyperclip\nmessage = pyperclip.paste()\nSYMBOLS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.\'\n\n# Loop through every possible key:\nfor key in range(len(SYMBOLS)):\n    # It is important to set translated to the blank string so that the\n    # previous iteration\'s value for translated is cleared.\n    translated = \'\'\n\n    # The rest of the program is almost the same as the original program:\n\n    # Loop through each symbol in `message`:\n    for symbol in message:\n        if symbol in SYMBOLS:\n            symbolIndex = SYMBOLS.find(symbol)\n            translatedIndex = symbolIndex - key\n\n            # Handle the wrap-around:\n            if translatedIndex \x3C 0:\n                translatedIndex = translatedIndex + len(SYMBOLS)\n\n            # Append the decrypted symbol:\n            translated = translated + SYMBOLS[translatedIndex]\n\n        else:\n            # Append the symbol without encrypting\x2Fdecrypting:\n            translated = translated + symbol\n\n    # Display every possible decryption:\n    print(\'Key #%s: %s\' % (key, translated))\n",
    "cryptomath": "# Cryptomath Module\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\ndef gcd(a, b):\n    # Return the Greatest Common Divisor of a and b using Euclid\'s Algorithm\n    while a != 0:\n        a, b = b % a, a\n    return b\n\n\ndef findModInverse(a, m):\n    # Return the modular inverse of a % m, which is\n    # the number x such that a*x % m = 1\n\n    if gcd(a, m) != 1:\n        return None # No mod inverse exists if a \& m aren\'t relatively prime.\n\n    # Calculate using the Extended Euclidean Algorithm:\n    u1, u2, u3 = 1, 0, a\n    v1, v2, v3 = 0, 1, m\n    while v3 != 0:\n        q = u3 \x2F\x2F v3 # Note that \x2F\x2F is the integer division operator\n        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3\n    return u1 % m",
    "detectEnglish": "# Detect English module\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\n# To use, type this code:\n#   import detectEnglish\n#   detectEnglish.isEnglish(someString) # returns True or False\n# (There must be a \"dictionary.txt\" file in this directory with all English\n# words in it, one word per line. You can download this from\n# https:\x2F\x2Finvpy.com\x2Fdictionary.txt)\nUPPERLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\nLETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + \' \\t\\n\'\n\ndef loadDictionary():\n    dictionaryFile = open(\'dictionary.txt\')\n    englishWords = {}\n    for word in dictionaryFile.read().split(\'\\n\'):\n        englishWords[word] = None\n    dictionaryFile.close()\n    return englishWords\n\nENGLISH_WORDS = loadDictionary()\n\n\ndef getEnglishCount(message):\n    message = message.upper()\n    message = removeNonLetters(message)\n    possibleWords = message.split()\n\n    if possibleWords == []:\n        return 0.0 # No words at all, so return 0.0.\n\n    matches = 0\n    for word in possibleWords:\n        if word in ENGLISH_WORDS:\n            matches += 1\n    return float(matches) \x2F len(possibleWords)\n\n\ndef removeNonLetters(message):\n    lettersOnly = []\n    for symbol in message:\n        if symbol in LETTERS_AND_SPACE:\n            lettersOnly.append(symbol)\n    return \'\'.join(lettersOnly)\n\n\ndef isEnglish(message, wordPercentage=20, letterPercentage=85):\n    # By default, 20% of the words must exist in the dictionary file, and\n    # 85% of all the characters in the message must be letters or spaces\n    # (not punctuation or numbers).\n    wordsMatch = getEnglishCount(message) * 100 \x3E= wordPercentage\n    numLetters = len(removeNonLetters(message))\n    messageLettersPercentage = float(numLetters) \x2F len(message) * 100\n    lettersMatch = messageLettersPercentage \x3E= letterPercentage\n    return wordsMatch and lettersMatch",
    "freqAnalysis": "# Frequency Finder\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nETAOIN = \'ETAOINSHRDLCUMWFGYPBVKJXQZ\'\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\ndef getLetterCount(message):\n    # Returns a dictionary with keys of single letters and values of the\n    # count of how many times they appear in the message parameter:\n    letterCount = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'E\': 0, \'F\': 0, \'G\': 0, \'H\': 0, \'I\': 0, \'J\': 0, \'K\': 0, \'L\': 0, \'M\': 0, \'N\': 0, \'O\': 0, \'P\': 0, \'Q\': 0, \'R\': 0, \'S\': 0, \'T\': 0, \'U\': 0, \'V\': 0, \'W\': 0, \'X\': 0, \'Y\': 0, \'Z\': 0}\n\n    for letter in message.upper():\n        if letter in LETTERS:\n            letterCount[letter] += 1\n\n    return letterCount\n\n\ndef getItemAtIndexZero(items):\n    return items[0]\n\n\ndef getFrequencyOrder(message):\n    # Returns a string of the alphabet letters arranged in order of most\n    # frequently occurring in the message parameter.\n\n    # First, get a dictionary of each letter and its frequency count:\n    letterToFreq = getLetterCount(message)\n\n    # Second, make a dictionary of each frequency count to each letter(s)\n    # with that frequency:\n    freqToLetter = {}\n    for letter in LETTERS:\n        if letterToFreq[letter] not in freqToLetter:\n            freqToLetter[letterToFreq[letter]] = [letter]\n        else:\n            freqToLetter[letterToFreq[letter]].append(letter)\n\n    # Third, put each list of letters in reverse \"ETAOIN\" order, and then\n    # convert it to a string:\n    for freq in freqToLetter:\n        freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)\n        freqToLetter[freq] = \'\'.join(freqToLetter[freq])\n\n    # Fourth, convert the freqToLetter dictionary to a list of\n    # tuple pairs (key, value), then sort them:\n    freqPairs = list(freqToLetter.items())\n    freqPairs.sort(key=getItemAtIndexZero, reverse=True)\n\n    # Fifth, now that the letters are ordered by frequency, extract all\n    # the letters for the final string:\n    freqOrder = []\n    for freqPair in freqPairs:\n        freqOrder.append(freqPair[1])\n\n    return \'\'.join(freqOrder)\n\n\ndef englishFreqMatchScore(message):\n    # Return the number of matches that the string in the message\n    # parameter has when its letter frequency is compared to English\n    # letter frequency. A \"match\" is how many of its six most frequent\n    # and six least frequent letters is among the six most frequent and\n    # six least frequent letters for English.\n    freqOrder = getFrequencyOrder(message)\n\n    matchScore = 0\n    # Find how many matches for the six most common letters there are:\n    for commonLetter in ETAOIN[:6]:\n        if commonLetter in freqOrder[:6]:\n            matchScore += 1\n    # Find how many matches for the six least common letters there are:\n    for uncommonLetter in ETAOIN[-6:]:\n        if uncommonLetter in freqOrder[-6:]:\n            matchScore += 1\n\n    return matchScore",
    "makePublicPrivateKeys": "# Public Key Generator\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes\x2F (BSD Licensed)\n\nimport random, sys, os, primeNum, cryptomath\n\n\ndef main():\n    # Create a public\x2Fprivate keypair with 1024 bit keys:\n    print(\'Making key files...\')\n    makeKeyFiles(\'al_sweigart\', 1024)\n    print(\'Key files made.\')\n\ndef generateKey(keySize):\n    # Creates a public\x2Fprivate keys keySize bits in size.\n    p = 0\n    q = 0\n    # Step 1: Create two prime numbers, p and q. Calculate n = p * q.\n    print(\'Generating p \& q primes...\')\n    while p == q:\n        p = primeNum.generateLargePrime(keySize)\n        q = primeNum.generateLargePrime(keySize)\n    n = p * q\n\n    # Step 2: Create a number e that is relatively prime to (p-1)*(q-1):\n    print(\'Generating e that is relatively prime to (p-1)*(q-1)...\')\n    while True:\n        # Keep trying random numbers for e until one is valid:\n        e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))\n        if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1:\n            break\n\n    # Step 3: Calculate d, the mod inverse of e:\n    print(\'Calculating d that is mod inverse of e...\')\n    d = cryptomath.findModInverse(e, (p - 1) * (q - 1))\n\n    publicKey = (n, e)\n    privateKey = (n, d)\n\n    print(\'Public key:\', publicKey)\n    print(\'Private key:\', privateKey)\n\n    return (publicKey, privateKey)\n\n\ndef makeKeyFiles(name, keySize):\n    # Creates two files \'x_pubkey.txt\' and \'x_privkey.txt\' (where x\n    # is the value in name) with the n,e and d,e integers written in\n    # them, delimited by a comma.\n\n    # Our safety check will prevent us from overwriting our old key files:\n    if os.path.exists(\'%s_pubkey.txt\' % (name)) or os.path.exists(\'%s_privkey.txt\' % (name)):\n        sys.exit(\'WARNING: The file %s_pubkey.txt or %s_privkey.txt already exists! Use a different name or delete these files and re-run this program.\' % (name, name))\n\n    publicKey, privateKey = generateKey(keySize)\n\n    print()\n    print(\'The public key is a %s and a %s digit number.\' % (len(str(publicKey[0])), len(str(publicKey[1]))))\n    print(\'Writing public key to file %s_pubkey.txt...\' % (name))\n    fo = open(\'%s_pubkey.txt\' % (name), \'w\')\n    fo.write(\'%s,%s,%s\' % (keySize, publicKey[0], publicKey[1]))\n    fo.close()\n\n    print()\n    print(\'The private key is a %s and a %s digit number.\' % (len(str(publicKey[0])), len(str(publicKey[1]))))\n    print(\'Writing private key to file %s_privkey.txt...\' % (name))\n    fo = open(\'%s_privkey.txt\' % (name), \'w\')\n    fo.write(\'%s,%s,%s\' % (keySize, privateKey[0], privateKey[1]))\n    fo.close()\n\n\n# If makePublicPrivateKeys.py is run (instead of imported as a module),\n# call the main() function:\nif __name__ == \'__main__\':\n    main()",
    "makeWordPatterns": "# Makes the wordPatterns.py File\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\n# Creates wordPatterns.py based on the words in our dictionary\n# text file, dictionary.txt. (Download this file from\n# https:\x2F\x2Finvpy.com\x2Fdictionary.txt)\n\nimport pprint\n\n\ndef getWordPattern(word):\n    # Returns a string of the pattern form of the given word.\n    # e.g. \'0.1.2.3.4.1.2.3.5.6\' for \'DUSTBUSTER\'\n    word = word.upper()\n    nextNum = 0\n    letterNums = {}\n    wordPattern = []\n\n    for letter in word:\n        if letter not in letterNums:\n            letterNums[letter] = str(nextNum)\n            nextNum += 1\n        wordPattern.append(letterNums[letter])\n    return \'.\'.join(wordPattern)\n\n\ndef main():\n    allPatterns = {}\n\n    fo = open(\'dictionary.txt\')\n    wordList = fo.read().split(\'\\n\')\n    fo.close()\n\n    for word in wordList:\n        # Get the pattern for each string in wordList:\n        pattern = getWordPattern(word)\n\n        if pattern not in allPatterns:\n            allPatterns[pattern] = [word]\n        else:\n            allPatterns[pattern].append(word)\n\n    # This is code that writes code. The wordPatterns.py file contains\n    # one very, very large assignment statement:\n    fo = open(\'wordPatterns.py\', \'w\')\n    fo.write(\'allPatterns = \')\n    fo.write(pprint.pformat(allPatterns))\n    fo.close()\n\n\nif __name__ == \'__main__\':\n    main()",
    "primeNum": "# Prime Number Sieve\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes\x2F (BSD Licensed)\n\nimport math, random\n\n\ndef isPrimeTrialDiv(num):\n    # Returns True if num is a prime number, otherwise False.\n\n    # Uses the trial division algorithm for testing primality.\n\n    # All numbers less than 2 are not prime:\n    if num \x3C 2:\n        return False\n\n    # See if num is divisible by any number up to the square root of num:\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n\ndef primeSieve(sieveSize):\n    # Returns a list of prime numbers calculated using\n    # the Sieve of Eratosthenes algorithm.\n\n    sieve = [True] * sieveSize\n    sieve[0] = False # Zero and one are not prime numbers.\n    sieve[1] = False\n\n    # Create the sieve:\n    for i in range(2, int(math.sqrt(sieveSize)) + 1):\n        pointer = i * 2\n        while pointer \x3C sieveSize:\n            sieve[pointer] = False\n            pointer += i\n\n    # Compile the list of primes:\n    primes = []\n    for i in range(sieveSize):\n        if sieve[i] == True:\n            primes.append(i)\n\n    return primes\n\ndef rabinMiller(num):\n    # Returns True if num is a prime number.\n    if num % 2 == 0 or num \x3C 2:\n        return False # Rabin-Miller doesn\'t work on even integers.\n    if num == 3:\n        return True\n    s = num - 1\n    t = 0\n    while s % 2 == 0:\n        # Keep halving s until it is odd (and use t\n        # to count how many times we halve s):\n        s = s \x2F\x2F 2\n        t += 1\n    for trials in range(5): # Try to falsify num\'s primality 5 times.\n        a = random.randrange(2, num - 1)\n        v = pow(a, s, num)\n        if v != 1: # (This test does not apply if v is 1.)\n            i = 0\n            while v != (num - 1):\n                if i == t - 1:\n                    return False\n                else:\n                    i = i + 1\n                    v = (v ** 2) % num\n    return True\n\n# Most of the time we can quickly determine if num is not prime\n# by dividing by the first few dozen prime numbers. This is quicker\n# than rabinMiller(), but does not detect all composites.\nLOW_PRIMES = primeSieve(100)\n\n\ndef isPrime(num):\n    # Return True if num is a prime number. This function does a quicker\n    # prime number check before calling rabinMiller().\n    if (num \x3C 2):\n        return False # 0, 1, and negative numbers are not prime.\n\n    # See if any of the low prime numbers can divide num:\n    for prime in LOW_PRIMES:\n        if (num % prime == 0):\n            return False\n\n    # If all else fails, call rabinMiller() to determine if num is a prime:\n    return rabinMiller(num)\n\n\ndef generateLargePrime(keysize=1024):\n    # Return a random prime number that is keysize bits in size:\n    while True:\n        num = random.randrange(2**(keysize-1), 2**(keysize))\n        if isPrime(num):\n            return num",
    "publicKeyCipher": "# Public Key Cipher\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes\x2F (BSD Licensed)\n\nimport sys, math\n\n# The public and private keys for this program are created by\n# the makePublicPrivateKeys.py program.\n# This program must be run in the same folder as the key files.\n\nSYMBOLS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.\'\n\ndef main():\n    # Runs a test that encrypts a message to a file or decrypts a message\n    # from a file.\n    filename = \'encrypted_file.txt\' # The file to write to\x2Fread from.\n    mode = \'encrypt\' # Set to either \'encrypt\' or \'decrypt\'.\n\n    if mode == \'encrypt\':\n        message = \'Journalists belong in the gutter because that is where the ruling classes throw their guilty secrets. Gerald Priestland. The Founding Fathers gave the free press the protection it must have to bare the secrets of government and inform the people. Hugo Black.\'\n        pubKeyFilename = \'al_sweigart_pubkey.txt\'\n        print(\'Encrypting and writing to %s...\' % (filename))\n        encryptedText = encryptAndWriteToFile(filename, pubKeyFilename, message)\n\n        print(\'Encrypted text:\')\n        print(encryptedText)\n\n    elif mode == \'decrypt\':\n        privKeyFilename = \'al_sweigart_privkey.txt\'\n        print(\'Reading from %s and decrypting...\' % (filename))\n        decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)\n\n        print(\'Decrypted text:\')\n        print(decryptedText)\n\n\ndef getBlocksFromText(message, blockSize):\n    # Converts a string message to a list of block integers.\n    for character in message:\n        if character not in SYMBOLS:\n            print(\'ERROR: The symbol set does not have the character %s\' % (character))\n            sys.exit()\n    blockInts = []\n    for blockStart in range(0, len(message), blockSize):\n        # Calculate the block integer for this block of text:\n        blockInt = 0\n        for i in range(blockStart, min(blockStart + blockSize, len(message))):\n            blockInt += (SYMBOLS.index(message[i])) * (len(SYMBOLS) ** (i % blockSize))\n        blockInts.append(blockInt)\n    return blockInts\n\n\ndef getTextFromBlocks(blockInts, messageLength, blockSize):\n    # Converts a list of block integers to the original message string.\n    # The original message length is needed to properly convert the last\n    # block integer.\n    message = []\n    for blockInt in blockInts:\n        blockMessage = []\n        for i in range(blockSize - 1, -1, -1):\n            if len(message) + i \x3C messageLength:\n                # Decode the message string for the 128 (or whatever\n                # blockSize is set to) characters from this block integer:\n                charIndex = blockInt \x2F\x2F (len(SYMBOLS) ** i)\n                blockInt = blockInt % (len(SYMBOLS) ** i)\n                blockMessage.insert(0, SYMBOLS[charIndex])\n        message.extend(blockMessage)\n    return \'\'.join(message)\n\n\ndef encryptMessage(message, key, blockSize):\n    # Converts the message string into a list of block integers, and then\n    # encrypts each block integer. Pass the PUBLIC key to encrypt.\n    encryptedBlocks = []\n    n, e = key\n\n    for block in getBlocksFromText(message, blockSize):\n        # ciphertext = plaintext ^ e mod n\n        encryptedBlocks.append(pow(block, e, n))\n    return encryptedBlocks\n\n\ndef decryptMessage(encryptedBlocks, messageLength, key, blockSize):\n    # Decrypts a list of encrypted block ints into the original message\n    # string. The original message length is required to properly decrypt\n    # the last block. Be sure to pass the PRIVATE key to decrypt.\n    decryptedBlocks = []\n    n, d = key\n    for block in encryptedBlocks:\n        # plaintext = ciphertext ^ d mod n\n        decryptedBlocks.append(pow(block, d, n))\n    return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)\n\n\ndef readKeyFile(keyFilename):\n    # Given the filename of a file that contains a public or private key,\n    # return the key as a (n,e) or (n,d) tuple value.\n    fo = open(keyFilename)\n    content = fo.read()\n    fo.close()\n    keySize, n, EorD = content.split(\',\')\n    return (int(keySize), int(n), int(EorD))\n\n\ndef encryptAndWriteToFile(messageFilename, keyFilename, message, blockSize=None):\n    # Using a key from a key file, encrypt the message and save it to a\n    # file. Returns the encrypted message string.\n    keySize, n, e = readKeyFile(keyFilename)\n    if blockSize == None:\n        # If blockSize isn\'t given, set it to the largest size allowed by the key size and symbol set size.\n        blockSize = int(math.log(2 ** keySize, len(SYMBOLS)))\n    # Check that key size is large enough for the block size:\n    if not (math.log(2 ** keySize, len(SYMBOLS)) \x3E= blockSize):\n        sys.exit(\'ERROR: Block size is too large for the key and symbol set size. Did you specify the correct key file and encrypted file?\')\n    # Encrypt the message:\n    encryptedBlocks = encryptMessage(message, (n, e), blockSize)\n\n    # Convert the large int values to one string value:\n    for i in range(len(encryptedBlocks)):\n        encryptedBlocks[i] = str(encryptedBlocks[i])\n    encryptedContent = \',\'.join(encryptedBlocks)\n\n    # Write out the encrypted string to the output file:\n    encryptedContent = \'%s_%s_%s\' % (len(message), blockSize, encryptedContent)\n    fo = open(messageFilename, \'w\')\n    fo.write(encryptedContent)\n    fo.close()\n    # Also return the encrypted string:\n    return encryptedContent\n\n\ndef readFromFileAndDecrypt(messageFilename, keyFilename):\n    # Using a key from a key file, read an encrypted message from a file\n    # and then decrypt it. Returns the decrypted message string.\n    keySize, n, d = readKeyFile(keyFilename)\n\n\n    # Read in the message length and the encrypted message from the file:\n    fo = open(messageFilename)\n    content = fo.read()\n    messageLength, blockSize, encryptedMessage = content.split(\'_\')\n    messageLength = int(messageLength)\n    blockSize = int(blockSize)\n\n    # Check that key size is large enough for the block size:\n    if not (math.log(2 ** keySize, len(SYMBOLS)) \x3E= blockSize):\n        sys.exit(\'ERROR: Block size is too large for the key and symbol set size. Did you specify the correct key file and encrypted file?\')\n\n    # Convert the encrypted message into large int values:\n    encryptedBlocks = []\n    for block in encryptedMessage.split(\',\'):\n        encryptedBlocks.append(int(block))\n\n    # Decrypt the large int values:\n    return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)\n\n\n# If publicKeyCipher.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "reverseCipher": "# Reverse Cipher\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nmessage = \'Three can keep a secret, if two of them are dead.\'\ntranslated = \'\'\n\ni = len(message) - 1\nwhile i \x3E= 0:\n    translated = translated + message[i]\n    i = i - 1\n\nprint(translated)",
    "simpleSubCipher": "# Simple Substitution Cipher\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport pyperclip, sys, random\n\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\n\ndef main():\n    myMessage = \'If a man is offered a fact which goes against his instincts, he will scrutinize it closely, and unless the evidence is overwhelming, he will refuse to believe it. If, on the other hand, he is offered something which affords a reason for acting in accordance to his instincts, he will accept it even on the slightest evidence. The origin of myths is explained in this way. -Bertrand Russell\'\n    myKey = \'LFWOAYUISVKMNXPBDCRJTQEGHZ\'\n    myMode = \'encrypt\' # Set to either \'encrypt\' or \'decrypt\'.\n\n    if not keyIsValid(myKey):\n        sys.exit(\'There is an error in the key or symbol set.\')\n    if myMode == \'encrypt\':\n        translated = encryptMessage(myKey, myMessage)\n    elif myMode == \'decrypt\':\n        translated = decryptMessage(myKey, myMessage)\n    print(\'Using key %s\' % (myKey))\n    print(\'The %sed message is:\' % (myMode))\n    print(translated)\n    pyperclip.copy(translated)\n    print()\n    print(\'This message has been copied to the clipboard.\')\n\n\ndef keyIsValid(key):\n    keyList = list(key)\n    lettersList = list(LETTERS)\n    keyList.sort()\n    lettersList.sort()\n\n    return keyList == lettersList\n\n\ndef encryptMessage(key, message):\n    return translateMessage(key, message, \'encrypt\')\n\n\ndef decryptMessage(key, message):\n    return translateMessage(key, message, \'decrypt\')\n\n\ndef translateMessage(key, message, mode):\n    translated = \'\'\n    charsA = LETTERS\n    charsB = key\n    if mode == \'decrypt\':\n        # For decrypting, we can use the same code as encrypting. We\n        # just need to swap where the key and LETTERS strings are used.\n        charsA, charsB = charsB, charsA\n\n    # Loop through each symbol in message:\n    for symbol in message:\n        if symbol.upper() in charsA:\n            # Encrypt\x2Fdecrypt the symbol:\n            symIndex = charsA.find(symbol.upper())\n            if symbol.isupper():\n                translated += charsB[symIndex].upper()\n            else:\n                translated += charsB[symIndex].lower()\n        else:\n            # Symbol is not in LETTERS; just add it\n            translated += symbol\n\n    return translated\n\n\ndef getRandomKey():\n    key = list(LETTERS)\n    random.shuffle(key)\n    return \'\'.join(key)\n\n\nif __name__ == \'__main__\':\n    main()",
    "simpleSubHacker": "# Simple Substitution Cipher Hacker\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport re, copy, pyperclip, simpleSubCipher, wordPatterns, makeWordPatterns\n\n\n\n\n\nLETTERS = \'ABCDEFGHIJKLMNOPQRSTUVWXYZ\'\nnonLettersOrSpacePattern = re.compile(\'[^A-Z\\s]\')\n\ndef main():\n    message = \'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh. -Facjclxo Ctrramm\'\n\n    # Determine the possible valid ciphertext translations:\n    print(\'Hacking...\')\n    letterMapping = hackSimpleSub(message)\n\n    # Display the results to the user:\n    print(\'Mapping:\')\n    print(letterMapping)\n    print()\n    print(\'Original ciphertext:\')\n    print(message)\n    print()\n    print(\'Copying hacked message to clipboard:\')\n    hackedMessage = decryptWithCipherletterMapping(message, letterMapping)\n    pyperclip.copy(hackedMessage)\n    print(hackedMessage)\n\n\ndef getBlankCipherletterMapping():\n    # Returns a dictionary value that is a blank cipherletter mapping.\n    return {\'A\': [], \'B\': [], \'C\': [], \'D\': [], \'E\': [], \'F\': [], \'G\': [], \'H\': [], \'I\': [], \'J\': [], \'K\': [], \'L\': [], \'M\': [], \'N\': [], \'O\': [], \'P\': [], \'Q\': [], \'R\': [], \'S\': [], \'T\': [], \'U\': [], \'V\': [], \'W\': [], \'X\': [], \'Y\': [], \'Z\': []}\n\n\ndef addLettersToMapping(letterMapping, cipherword, candidate):\n    # The `letterMapping` parameter is a \"cipherletter mapping\" dictionary\n    # value that the return value of this function starts as a copy of.\n    # The `cipherword` parameter is a string value of the ciphertext word.\n    # The `candidate` parameter is a possible English word that the\n    # cipherword could decrypt to.\n\n    # This function adds the letters of the candidate as potential\n    # decryption letters for the cipherletters in the cipherletter\n    # mapping.\n\n\n    for i in range(len(cipherword)):\n        if candidate[i] not in letterMapping[cipherword[i]]:\n            letterMapping[cipherword[i]].append(candidate[i])\n\n\n\ndef intersectMappings(mapA, mapB):\n    # To intersect two maps, create a blank map, and then add only the\n    # potential decryption letters if they exist in BOTH maps.\n    intersectedMapping = getBlankCipherletterMapping()\n    for letter in LETTERS:\n\n        # An empty list means \"any letter is possible\". In this case just\n        # copy the other map entirely.\n        if mapA[letter] == []:\n            intersectedMapping[letter] = copy.deepcopy(mapB[letter])\n        elif mapB[letter] == []:\n            intersectedMapping[letter] = copy.deepcopy(mapA[letter])\n        else:\n            # If a letter in mapA[letter] exists in mapB[letter], add\n            # that letter to intersectedMapping[letter].\n            for mappedLetter in mapA[letter]:\n                if mappedLetter in mapB[letter]:\n                    intersectedMapping[letter].append(mappedLetter)\n\n    return intersectedMapping\n\n\ndef removeSolvedLettersFromMapping(letterMapping):\n    # Cipherletters in the mapping that map to only one letter are\n    # \"solved\" and can be removed from the other letters.\n    # For example, if \'A\' maps to potential letters [\'M\', \'N\'], and \'B\'\n    # maps to [\'N\'], then we know that \'B\' must map to \'N\', so we can\n    # remove \'N\' from the list of what \'A\' could map to. So \'A\' then maps\n    # to [\'M\']. Note that now that \'A\' maps to only one letter, we can\n    # remove \'M\' from the list of letters for every other\n    # letter. (This is why there is a loop that keeps reducing the map.)\n\n    loopAgain = True\n    while loopAgain:\n        # First assume that we will not loop again:\n        loopAgain = False\n\n        # `solvedLetters` will be a list of uppercase letters that have one\n        # and only one possible mapping in `letterMapping`:\n        solvedLetters = []\n        for cipherletter in LETTERS:\n            if len(letterMapping[cipherletter]) == 1:\n                solvedLetters.append(letterMapping[cipherletter][0])\n\n        # If a letter is solved, than it cannot possibly be a potential\n        # decryption letter for a different ciphertext letter, so we\n        # should remove it from those other lists:\n        for cipherletter in LETTERS:\n            for s in solvedLetters:\n                if len(letterMapping[cipherletter]) != 1 and s in letterMapping[cipherletter]:\n                    letterMapping[cipherletter].remove(s)\n                    if len(letterMapping[cipherletter]) == 1:\n                        # A new letter is now solved, so loop again.\n                        loopAgain = True\n    return letterMapping\n\n\ndef hackSimpleSub(message):\n    intersectedMap = getBlankCipherletterMapping()\n    cipherwordList = nonLettersOrSpacePattern.sub(\'\', message.upper()).split()\n    for cipherword in cipherwordList:\n        # Get a new cipherletter mapping for each ciphertext word:\n        candidateMap = getBlankCipherletterMapping()\n\n        wordPattern = makeWordPatterns.getWordPattern(cipherword)\n        if wordPattern not in wordPatterns.allPatterns:\n            continue # This word was not in our dictionary, so continue.\n\n        # Add the letters of each candidate to the mapping:\n        for candidate in wordPatterns.allPatterns[wordPattern]:\n            addLettersToMapping(candidateMap, cipherword, candidate)\n\n        # Intersect the new mapping with the existing intersected mapping:\n        intersectedMap = intersectMappings(intersectedMap, candidateMap)\n\n    # Remove any solved letters from the other lists:\n    return removeSolvedLettersFromMapping(intersectedMap)\n\n\ndef decryptWithCipherletterMapping(ciphertext, letterMapping):\n    # Return a string of the ciphertext decrypted with the letter mapping,\n    # with any ambiguous decrypted letters replaced with an _ underscore.\n\n    # First create a simple sub key from the letterMapping mapping:\n    key = [\'x\'] * len(LETTERS)\n    for cipherletter in LETTERS:\n        if len(letterMapping[cipherletter]) == 1:\n            # If there\'s only one letter, add it to the key.\n            keyIndex = LETTERS.find(letterMapping[cipherletter][0])\n            key[keyIndex] = cipherletter\n        else:\n            ciphertext = ciphertext.replace(cipherletter.lower(), \'_\')\n            ciphertext = ciphertext.replace(cipherletter.upper(), \'_\')\n    key = \'\'.join(key)\n\n    # With the key we\'ve created, decrypt the ciphertext:\n    return simpleSubCipher.decryptMessage(key, ciphertext)\n\n\nif __name__ == \'__main__\':\n    main()",
    "transpositionDecrypt": "# Transposition Cipher Decryption\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport math, pyperclip\n\ndef main():\n    myMessage = pyperclip.paste() #\'Cenoonommstmme oo snnio. s s c\'\n    myKey = 9\n\n    plaintext = decryptMessage(myKey, myMessage)\n\n    # Print with a | (\"pipe\" character) after it in case\n    # there are spaces at the end of the decrypted message.\n    print(plaintext + \'|\')\n\n    pyperclip.copy(plaintext)\n\n\ndef decryptMessage(key, message):\n    # The transposition decrypt function will simulate the \"columns\" and\n    # \"rows\" of the grid that the plaintext is written on by using a list\n    # of strings. First, we need to calculate a few values.\n\n    # The number of \"columns\" in our transposition grid:\n    numOfColumns = int(math.ceil(len(message) \x2F float(key)))\n    # The number of \"rows\" in our grid will need:\n    numOfRows = key\n    # The number of \"shaded boxes\" in the last \"column\" of the grid:\n    numOfShadedBoxes = (numOfColumns * numOfRows) - len(message)\n\n    # Each string in plaintext represents a column in the grid.\n    plaintext = [\'\'] * numOfColumns\n\n    # The column and row variables point to where in the grid the next\n    # character in the encrypted message will go.\n    column = 0\n    row = 0\n\n    for symbol in message:\n        plaintext[column] += symbol\n        column += 1 # Point to next column.\n\n        # If there are no more columns OR we\'re at a shaded box, go back to\n        # the first column and the next row:\n        if (column == numOfColumns) or (column == numOfColumns - 1 and row \x3E= numOfRows - numOfShadedBoxes):\n            column = 0\n            row += 1\n\n    return \'\'.join(plaintext)\n\n\n# If transpositionDecrypt.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionEncrypt": "# Transposition Cipher Encryption\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport pyperclip\n\ndef main():\n    myMessage = \'Common sense is not so common.\'\n    myKey = 8\n\n    ciphertext = encryptMessage(myKey, myMessage)\n\n    # Print the encrypted string in ciphertext to the screen, with\n    # a | (\"pipe\" character) after it in case there are spaces at\n    # the end of the encrypted message:\n    print(ciphertext + \'|\')\n\n    # Copy the encrypted string in ciphertext to the clipboard:\n    pyperclip.copy(ciphertext)\n\n\ndef encryptMessage(key, message):\n    # Each string in ciphertext represents a column in the grid:\n    ciphertext = [\'\'] * key\n\n    # Loop through each column in ciphertext:\n    for column in range(key):\n        currentIndex = column\n\n        # Keep looping until currentIndex goes past the message length:\n        while currentIndex \x3C len(message):\n            # Place the character at currentIndex in message at the\n            # end of the current column in the ciphertext list:\n            ciphertext[column] += message[currentIndex]\n\n            # Move currentIndex over:\n            currentIndex += key\n\n    # Convert the ciphertext list into a single string value and return it:\n    return \'\'.join(ciphertext)\n\n\n# If transpositionEncrypt.py is run (instead of imported as a module) call\n# the main() function.\nif __name__ == \'__main__\':\n    main()",
    "transpositionFileCipher": "# Transposition Cipher Encrypt\x2FDecrypt File\n# https:\x2F\x2Fwww.nostarch.com\x2Fcrackingcodes (BSD Licensed)\n\nimport time, os, sys, transpositionEncrypt, transpositionDecrypt\n\ndef main():\n    inputFilename = \'frankenstein.txt\'\n    # BE CAREFUL! If a file with the outputFilename name already exists,\n    # this program will overwrite that file.\n    outputFilename = \'frankenstein.encrypted.txt\'\n    myKey = 10\n    myMode = \'encrypt\' # set to \'encrypt\' or \'decrypt\'\n\n    # If the input file does not exist, then the program terminates early:\n    if not os.path.exists(inputFilename):\n        print(\'The file %s does not exist. Quitting...\' % (inputFilename))\n        sys.exit()\n\n    # If the output file already exists, give the user a chance to quit:\n    if os.path.exists(outputFilename):\n        print(\'This will overwrite the file %s. (C)ontinue or (Q)uit?\' % (outputFilename))\n        response = input(\'\x3E \')\n        if not response.lower().startswith(\'c\'):\n            sys.exit()\n\n    # Read in the message from the input file:\n    fileObj = open(inputFilename)\n    content = fileObj.read()\n    fileObj.close()\n\n    print(\'%sing...\' % (myMode.title()))\n\n    # Measure how long the encryption\x2Fdecryption takes:\n    startTime = time.time()\n    if myMode == \'encrypt\':\n        translated = transpositionEncrypt.encryptMessage(myKey, content)\n    elif myMode == \'decrypt\':\n        translated = transpositionDecrypt.decryptMessage(myKey, content)\n    totalTime = round(time.time() - startTime, 2)\n    print(\'%sion time: %s seconds\' % (myMode.title(), totalTime))\n\n    # Write out the translated message to the output file:\n    outputFileObj = open(outputFilename, \'w\')\n    outputFileObj.write(translated)\n    outputFileObj.close()\n\n    print(\'Done %sing %s (%s characters).\' % (myMode, inputFilename, len(content)))\n    print(\'%sed file is %s.\' % (myMode.title(), outputFilename))\n\n\n# If transpositionCipherFile.py is run (instead of imported as a module)\n# call the main() function.\nif __name__ == \'__main__\':\n    main()",
};
