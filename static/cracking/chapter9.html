<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Chapter 9 - Programming a Program to Test Your Program</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter8.html">Prev: Chapter 8 - Decrypting with the Transposition Cipher</a> | <a href="chapter10.html">Next: Chapter 10 - Encrypting and Decrypting Files</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter8.html">Previous Chapter - Decrypting with the Transposition Cipher</a> | <a href="chapter10.html">Next Chapter - Encrypting and Decrypting Files</a></div>
<div id="calibre_link-364" class="calibre">
<h2 class="h2a1" id="calibre_link-25"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-319" class="calibre1"></span><span class="big">9</span><br class="calibre15" />PROGRAMMING A PROGRAM TO TEST YOUR PROGRAM</h2>
<p class="epigraph"><em class="calibre7">“It is poor civic hygiene to install technologies that could someday facilitate a police state.”<br class="calibre9" />&mdash;Bruce Schneier,</em> Secrets and Lies</p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">The transposition programs seem to work pretty well at encrypting and decrypting different messages with various keys, but how do you know they <em class="calibre7">always</em> work? You can’t be absolutely sure the programs always work unless you test the <span class="literal">encryptMessage() and <span class="literal1">decryptMessage()</span> functions with</span> all sorts of <span class="literal">message</span> and <span class="literal">key</span> parameter values. But this would take a lot of time because you’d have to type a message in the encryption program, set the key, run the encryption program, paste the ciphertext into the decryption program, set the key, and then run the decryption program. You’d also need to repeat that process with several different keys and messages, resulting in a lot of boring work!</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-320"></span>Instead, let’s write another program that generates a random message and a random key to test the cipher programs. This new program will encrypt the message with <span class="literal">encryptMessage()</span> from <em class="calibre7">transpositionEncrypt.py</em> and then pass the ciphertext to <span class="literal">decryptMessage()</span> from <em class="calibre7">transpositionDecrypt.py</em>. If the plaintext returned by <span class="literal">decryptMessage()</span> is the same as the original message, the program will know that the encryption and decryption programs work. The process of testing a program automatically using another program is called <em class="calibre7">automated testing</em>.</p>
<p class="indent">Several different message and key combinations need to be tried, but it takes the computer only a minute or so to test thousands of combinations. If all of those tests pass, you can be more certain that your code works.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The <span class="literal">random.randint()</span> function</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">random.seed()</span> function</p></li>
<li class="calibre11"><p class="noindent">List references</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">copy.deepcopy()</span> functions</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">random.shuffle()</span> function</p></li>
<li class="calibre11"><p class="noindent">Randomly scrambling a string</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">sys.exit()</span> function</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-562"><strong class="calibre3">Source Code for the Transposition Cipher Tester Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and save it as <em class="calibre7">transpositionTest.py</em>. Then press F5 to run the program.</p>
<p class="noindentz"><em class="calibre7">transposition<br class="calibre9" />Test.py</em></p>
<p class="programs1">&nbsp;1. # Transposition Cipher Test<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import random, sys, transpositionEncrypt, transpositionDecrypt<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6. def main():<br class="calibre9" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.seed(42) # Set the random "seed" to a static value.<br class="calibre9" />&nbsp;8.<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(20): # Run 20 tests.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Generate random messages to test.<br class="calibre9" />11.<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The message will have a random length:<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' * random.randint(4, 40)<br class="calibre9" />14.<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the message string to a list to shuffle it:<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = list(message)<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-326"></span>17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(message)<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = ''.join(message) # Convert the list back to a string.<br class="calibre9" />19.<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Test #%s: "%s..."' % (i + 1, message[:50]))<br class="calibre9" />21.<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check all possible keys for each message:<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for key in range(1, int(len(message)/2)):<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encrypted = transpositionEncrypt.encryptMessage(key, message)<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypted = transpositionDecrypt.decryptMessage(key, encrypted)<br class="calibre9" />26.<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If the decryption doesn't match the original message, display<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# an error message and quit:<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if message != decrypted:<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Mismatch with key %s and message %s.' % (key,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message))<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted as: ' + decrypted)<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()<br class="calibre9" />33.<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Transposition cipher test passed.')<br class="calibre9" />35.<br class="calibre9" />36.<br class="calibre9" />37. # If transpositionTest.py is run (instead of imported as a module) call<br class="calibre9" />38. # the main() function:<br class="calibre9" />39. if __name__ == '__main__':<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-563"><strong class="calibre3">Sample Run of the Transposition Cipher Tester Program</strong></h3>
<p class="noindent">When you run the <em class="calibre7">transpositionTest.py</em> program, the output should look like this:</p>
<p class="programs1">Test #1: "JEQLDFKJZWALCOYACUPLTRRMLWHOBXQNEAWSLGWAGQQSRSIUIQ..."<br class="calibre9" />Test #2: "SWRCLUCRDOMLWZKOMAGVOTXUVVEPIOJMSBEQRQOFRGCCKENINV..."<br class="calibre9" />Test #3: "BIZBPZUIWDUFXAPJTHCMDWEGHYOWKWWWSJYKDQVSFWCJNCOZZA..."<br class="calibre9" />Test #4: "JEWBCEXVZAILLCHDZJCUTXASSZZRKRPMYGTGHBXPQPBEBVCODM..."<br class="calibre9" /><span class="codeitalic">--snip--</span><br class="calibre9" />Test #17: "KPKHHLPUWPSSIOULGKVEFHZOKBFHXUKVSEOWOENOZSNIDELAWR..."<br class="calibre9" />Test #18: "OYLFXXZENDFGSXTEAHGHPBNORCFEPBMITILSSJRGDVMNSOMURV..."<br class="calibre9" />Test #19: "SOCLYBRVDPLNVJKAFDGHCQMXIOPEJSXEAAXNWCCYAGZGLZGZHK..."<br class="calibre9" />Test #20: "JXJGRBCKZXPUIEXOJUNZEYYSEAEGVOJWIRTSSGPUWPNZUBQNDA..."<br class="calibre9" />Transposition cipher test passed.</p>
<p class="indent">The tester program works by importing the <em class="calibre7">transpositionEncrypt.py</em> and <em class="calibre7">transpositionDecrypt.py</em> programs as modules. Then the tester program calls <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage()</span> from the encryption and decryption programs. The tester program creates a random message and chooses a random key. It doesn’t matter that the message is just random letters, because the program only needs to check that encrypting and then decrypting the message results in the original message.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-302"></span>Using a loop, the program repeats this test 20 times. If at any point the string returned from <span class="literal">transpositionDecrypt()</span> isn’t the same as the original message, the program prints an error and exits.</p>
<p class="indent">Let’s explore the source code in more detail.</p>
<h3 class="h1" id="calibre_link-564"><strong class="calibre3">Importing the Modules</strong></h3>
<p class="noindent">The program starts by importing modules, including two you’ve already seen that come with Python, <span class="literal">random</span> and <span class="literal">sys</span>:</p>
<p class="programs1">&nbsp;1. # Transposition Cipher Test<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import random, sys, transpositionEncrypt, transpositionDecrypt</p>
<p class="indent">We also need to import the transposition cipher programs (that is, <em class="calibre7">transpositionEncrypt.py</em> and <em class="calibre7">transpositionDecrypt.py</em>) by just typing their names without the <em class="calibre7">.py</em> extension.</p>
<h3 class="h1" id="calibre_link-565"><strong class="calibre3">Creating Pseudorandom Numbers</strong></h3>
<p class="noindent">To create random numbers to generate the messages and keys, we’ll use the <span class="literal">random</span> module’s <span class="literal">seed()</span> function. Before we delve into what the seed does, let’s look at how random numbers work in Python by trying out the <span class="literal">random.randint()</span> function. The <span class="literal">random.randint()</span> function that we’ll use later in the program takes two integer arguments and returns a random integer between those two integers (including the integers). Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import random</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">random.randint(1, 20)</span><br class="calibre9" />20<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">random.randint(1, 20)</span><br class="calibre9" />18<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">random.randint(100, 200)</span><br class="calibre9" />107</p>
<p class="indent">Of course, the numbers you get will probably be different from those shown here because they’re random numbers.</p>
<p class="indent">But the numbers generated by Python’s <span class="literal">random.randint()</span> function are not truly random. They’re produced from a pseudorandom number generator algorithm, which takes an initial number and produces other numbers based on a formula.</p>
<p class="indent">The initial number that the pseudorandom number generator starts with is called the <em class="calibre7">seed</em>. If you know the seed, the rest of the numbers the generator produces are predictable, because when you set the seed to a <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-303"></span>specific number, the same numbers will be generated in the same order. These random-looking but predictable numbers are called <em class="calibre7">pseudorandom numbers</em>. Python programs for which you don’t set a seed use the computer’s current clock time to set a seed. You can reset Python’s random seed by calling the <span class="literal">random.seed()</span> function.</p>
<p class="indent">To see proof that the pseudorandom numbers aren’t completely random, enter the following into the interactive shell:</p>
<p class="programs1">&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">import random</span><br class="calibre9" /><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">random.seed(42)</span><br class="calibre9" /><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">numbers = []</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">for i in range(20):</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<span class="codestrong">numbers.append(random.randint(1, 10))</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...<br class="calibre9" /><span class="ent">➌</span> [2, 1, 5, 4, 4, 3, 2, 9, 2, 10, 7, 1, 1, 2, 4, 4, 9, 10, 1, 9]<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">random.seed(42)</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">numbers = []</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">for i in range(20):</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<span class="codestrong">numbers.append(random.randint(1, 10))</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...<br class="calibre9" /><span class="ent">➍</span> [2, 1, 5, 4, 4, 3, 2, 9, 2, 10, 7, 1, 1, 2, 4, 4, 9, 10, 1, 9]</p>
<p class="indent">In this code, we generate 20 numbers twice using the same seed. First, we import <span class="literal">random</span> and set the seed to <span class="literal">42</span> <span class="ent">➊</span>. Then we set up a list called <span class="literal">numbers</span> <span class="ent">➋</span> where we’ll store our generated numbers. We use a <span class="literal">for</span> loop to generate 20 numbers and append each one to the <span class="literal">numbers</span> list, which we print so we can see every number that was generated <span class="ent">➌</span>.</p>
<p class="indent">When the seed for Python’s pseudorandom number generator is set to <span class="literal">42</span>, the first “random” number between <span class="literal">1</span> and <span class="literal">10</span> will always be <span class="literal">2</span>. The second number will always be <span class="literal">1</span>, the third number will always be <span class="literal">5</span>, and so on. When you reset the seed to <span class="literal">42</span> and generate numbers with the seed again, the same set of pseudorandom numbers is returned from <span class="literal">random.randint()</span>, as you can see by comparing the <span class="literal">numbers</span> list at <span class="ent">➌</span> and <span class="ent">➍</span>.</p>
<p class="indent">Random numbers will become important for ciphers in later chapters, because they’re used not only for testing ciphers but also for encrypting and decrypting in more complex ciphers. Random numbers are so important that one common security flaw in encryption software is using predictable random numbers. If the random numbers in your programs can be predicted, a cryptanalyst can use this information to break your cipher.</p>
<p class="indent">Selecting encryption keys in a truly random manner is necessary for the security of a cipher, but for other uses, such as this code test, pseudo&shy;random numbers are fine. We’ll use pseudorandom numbers to generate test strings for our tester program. You can generate truly random numbers with Python by using the <span class="literal">random.SystemRandom().randint()</span> function, which you can learn more about at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<h3 class="h1" id="calibre_link-566"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-288" class="calibre1"></span><strong class="calibre3">Creating a Random String</strong></h3>
<p class="noindent">Now that you’ve learned how to use <span class="literal">random.randint()</span> and <span class="literal">random.seed()</span> to create random numbers, let’s return to the source code. To completely automate our encryption and decryption programs, we’ll need to automatically generate random string messages.</p>
<p class="indent">To do this, we’ll take a string of characters to use in the messages, duplicate it a random number of times, and store that as a string. Then, we’ll take the string of the duplicated characters and scramble them to make them more random. We’ll generate a new random string for each test so we can try many different letter combinations.</p>
<p class="indent">First, let’s set up the <span class="literal">main()</span> function, which contains code that tests the cipher programs. It starts by setting a seed for the pseudorandom string:</p>
<p class="programs1">&nbsp;6. def main():<br class="calibre9" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.seed(42) # Set the random "seed" to a static value.</p>
<p class="indent">Setting the random seed by calling <span class="literal">random.seed()</span> is useful for the tester program because you want predictable numbers so the same pseudo&shy;random messages and keys are chosen each time the program is run. As a result, if you notice one message fails to encrypt and decrypt properly, you’ll be able to reproduce this failing test case.</p>
<p class="indent">Next, we’ll duplicate a string using a <span class="literal">for</span> loop.</p>
<h4 class="h2" id="calibre_link-567"><strong class="calibre3"><em class="calibre12">Duplicating a String a Random Number of Times</em></strong></h4>
<p class="noindent">We’ll use a <span class="literal">for</span> loop to run 20 tests and to generate our random message:</p>
<p class="programs1">&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(20): # Run 20 tests.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Generate random messages to test.<br class="calibre9" />11.<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The message will have a random length:<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' * random.randint(4, 40)</p>
<p class="indent">Each time the <span class="literal">for</span> loop iterates, the program will create and test a new message. We want this program to run multiple tests because the more tests we try, the more certain we’ll be that the programs work.</p>
<p class="indent">Line 13 is the first line of testing code and creates a message of a random length. It takes a string of uppercase letters and uses <span class="literal">randint()</span> and string replication to duplicate the string a random number of times between <span class="literal">4</span> and <span class="literal">40</span>. Then it stores the new string in the <span class="literal">message</span> variable.</p>
<p class="indent">If we leave the <span class="literal">message</span> string as it is now, it will always just be the alphabet string repeated a random number of times. Because we want to test different combinations of characters, we’ll need to take things a step further and scramble the characters in <span class="literal">message</span>. To do that, let’s first learn a bit more about lists.</p>
<h4 class="h2" id="calibre_link-19"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-270" class="calibre1"></span><strong class="calibre3"><em class="calibre12">List Variables Use References</em></strong></h4>
<p class="noindent">Variables store lists differently than they store other values. A variable will contain a reference to the list, rather than the list itself. A <em class="calibre7">reference</em> is a value that points to some bit of data, and a <em class="calibre7">list reference</em> is a value that points to a list. This results in slightly different behavior for your code.</p>
<p class="indent">You already know that variables store strings and integer values. Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = 42</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cheese = spam</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam = 100</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />100<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre9" />42</p>
<p class="indent">We assign <span class="literal">42</span> to the <span class="literal">spam</span> variable, and then copy the value in <span class="literal">spam</span> and assign it to the variable <span class="literal">cheese</span>. When we later change the value in <span class="literal">spam</span> to <span class="literal">100</span>, the new number doesn’t affect the value in <span class="literal">cheese</span> because <span class="literal">spam</span> and <span class="literal">cheese</span> are different variables that store different values.</p>
<p class="indent">But lists don’t work this way. When we assign a list to a variable, we are actually assigning a list reference to the variable. The following code makes this distinction easier to understand. Enter this code into the interactive shell:</p>
<p class="programs1"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5]</span><br class="calibre9" /><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">cheese = spam</span><br class="calibre9" /><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">cheese[1] = 'Hello!'</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;[0, 'Hello!', 2, 3, 4, 5]<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;[0, 'Hello!', 2, 3, 4, 5]</p>
<p class="indent">This code might look odd to you. The code changed only the <span class="literal">cheese</span> list, but both the <span class="literal">cheese</span> and <span class="literal">spam</span> lists have changed.</p>
<p class="indent">When we create the list <span class="ent">➊</span>, we assign a reference to it in the <span class="literal">spam</span> variable. But the next line <span class="ent">➋</span> copies only the list reference in <span class="literal">spam</span> to <span class="literal">cheese</span>, not the list value. This means the values stored in <span class="literal">spam</span> and <span class="literal">cheese</span> now both refer to the same list. There is only one underlying list because the actual list was never actually copied. So when we modify the first element of <span class="literal">cheese</span> <span class="ent">➌</span>, we are modifying the same list that <span class="literal">spam</span> refers to.</p>
<p class="indent">Remember that variables are like boxes that contain values. But list variables don’t actually contain lists&mdash;they contain references to lists. (These references will have ID numbers that Python uses internally, but you can ignore them.) Using boxes as a metaphor for variables, <a href="#calibre_link-365" class="calibre8">Figure 9-1</a> shows what happens when a list is assigned to the <span class="literal">spam</span> variable.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-923"></span><img src="images/00001.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-365" class="calibre8"></a><em class="calibre7">Figure 9-1: <span class="literalcaption">spam = [0, 1, 2, 3, 4, 5]</span> stores a reference to a list, not the actual list.</em></p>
<p class="indent">Then, in <a href="#calibre_link-366" class="calibre8">Figure 9-2</a>, the reference in <span class="literal">spam</span> is copied to <span class="literal">cheese</span>. Only a new reference was created and stored in <span class="literal">cheese</span>, not a new list. Notice that both references refer to the same list.</p>
<div class="image"><img src="images/00003.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-366" class="calibre8"></a><em class="calibre7">Figure 9-2: <span class="literalcaption">spam = cheese</span> copies the reference, not the list.</em></p>
<p class="indent">When we alter the list that <span class="literal">cheese</span> refers to, the list that <span class="literal">spam</span> refers to also changes, because both <span class="literal">cheese</span> and <span class="literal">spam</span> refer to the same list. You can see this in <a href="#calibre_link-367" class="calibre8">Figure 9-3</a>.</p>
<p class="indent">Although Python variables technically contain references to list values, people often casually say that the variable “contains the list.”</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-117"></span><img src="images/00005.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-367" class="calibre8"></a><em class="calibre7">Figure 9-3: <span class="literalcaption">cheese[1] = 'Hello!'</span> modifies the list that both variables refer to.</em></p>
<h4 class="h2" id="calibre_link-568"><strong class="calibre3"><em class="calibre12">Passing References</em></strong></h4>
<p class="noindent">References are particularly important for understanding how arguments are passed to functions. When a function is called, the arguments’ values are copied to the parameter variables. For lists, this means a copy of the reference is used for the parameter. To see the consequences of this action, open a new file editor window, enter the following code, and save it as <em class="calibre7">passingReference.py</em>. Press F5 to run the code.</p>
<p class="noindentz"><em class="calibre7">passing<br class="calibre9" />Reference.py</em></p>
<p class="programs1">def eggs(someParameter):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;someParameter.append('Hello')<br class="calibre9" />spam = [1, 2, 3]<br class="calibre9" />eggs(spam)<br class="calibre9" />print(spam)</p>
<p class="indent">When you run the code, notice that when <span class="literal">eggs()</span> is called, a return value isn’t used to assign a new value to <span class="literal">spam</span>. Instead, the list is modified directly. When run, this program produces the following output:</p>
<p class="programs1">[1, 2, 3, 'Hello']</p>
<p class="indent">Even though <span class="literal">spam</span> and <span class="literal">someParameter</span> contain separate references, they both refer to the same list. This is why the <span class="literal">append('Hello')</span> method call inside the function affects the list even after the function call has returned.</p>
<p class="indent">Keep this behavior in mind: forgetting that Python handles list variables this way can lead to confusing bugs.</p>
<h4 class="h2" id="calibre_link-569"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-130" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Using copy.deepcopy() to Duplicate a List</em></strong></h4>
<p class="noindent">If you want to copy a list value, you can import the <span class="literal">copy</span> module to call the <span class="literal">copy.deepcopy()</span> function, which returns a separate copy of the list it is passed:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">import copy</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cheese = copy.deepcopy(spam)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cheese[1] = 'Hello!'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />[0, 1, 2, 3, 4, 5]<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre9" />[0, 'Hello!', 2, 3, 4, 5]</p>
<p class="indent">Because the <span class="literal">copy.deepcopy()</span> function was used to copy the list in <span class="literal">spam</span> to <span class="literal">cheese</span>, when an item in <span class="literal">cheese</span> is changed, <span class="literal">spam</span> is unaffected.</p>
<p class="indent">We’ll use this function in <a href="#calibre_link-63" class="calibre8">Chapter 17</a> when we hack the simple substitution cipher.</p>
<h4 class="h2" id="calibre_link-570"><strong class="calibre3"><em class="calibre12">The random.shuffle() Function</em></strong></h4>
<p class="noindent">With a foundation in how references work, you can now understand how the <span class="literal">random.shuffle()</span> function that we’ll use next works. The <span class="literal">random.shuffle()</span> function is part of the <span class="literal">random</span> module and accepts a list argument whose items it randomly rearranges. Enter the following into the interactive shell to see how <span class="literal">random.shuffle()</span> works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import random</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">random.shuffle(spam)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />[3, 0, 5, 9, 6, 8, 2, 4, 1, 7]<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">random.shuffle(spam)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />[1, 2, 5, 9, 4, 7, 0, 3, 6, 8]</p>
<p class="indent">An important detail to note is that <span class="literal">shuffle()</span> <em class="calibre7">does not return a list value</em>. Instead, it changes the list value that is passed to it (because <span class="literal">shuffle()</span> modifies the list directly from the list reference value it is passed). The <span class="literal">shuffle()</span> function modifies the list <em class="calibre7">in place</em>, which is why we execute <span class="literal">random.shuffle(spam)</span> instead of <span class="literal">spam = random.shuffle(spam)</span>.</p>
<h4 class="h2" id="calibre_link-571"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-265" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Randomly Scrambling a String</em></strong></h4>
<p class="noindent">Let’s return to <em class="calibre7">transpositionTest.py</em>. To shuffle the characters in a string value, we first need to convert the string to a list using <span class="literal">list()</span>:</p>
<p class="programs1">15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the message string to a list to shuffle it:<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = list(message)<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(message)<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = ''.join(message) # Convert the list back to a string.</p>
<p class="indent">The return value from <span class="literal">list()</span> is a list value with one-character strings of each character in the string passed to it; so on line 16, we’re reassigning <span class="literal">message</span> to be a list of its characters. Next, <span class="literal">shuffle()</span> randomizes the order of the items in <span class="literal">message</span>. Then the program converts the list of strings back to a string value using the <span class="literal">join()</span> string method. This shuffling of the <span class="literal">message</span> string allows us to test many different messages.</p>
<h3 class="h1" id="calibre_link-572">Testing Each Message</h3>
<p class="noindent">Now that the random message has been made, the program tests the encryption and decryption functions with it. We’ll have the program print some feedback so we can see what it’s doing while it’s testing:</p>
<p class="programs1">20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Test #%s: "%s..."' % (i + 1, message[:50]))</p>
<p class="indent">Line 20 has a <span class="literal">print()</span> call that displays which test number the program is on (we need to add 1 to <span class="literal">i</span> because <span class="literal">i</span> starts at <span class="literal">0</span> and the test numbers should start at <span class="literal">1</span>). Because the string in <span class="literal">message</span> can be long, we use string slicing to show only the first 50 characters of <span class="literal">message</span>.</p>
<p class="indent">Line 20 also uses string interpolation. The value that <span class="literal">i + 1</span> evaluates to replaces the first <span class="literal">%s</span> in the string, and the value that <span class="literal">message[:50]</span> evaluates to replaces the second <span class="literal">%s</span>. When using string interpolation, be sure the number of <span class="literal">%s</span> in the string matches the number of values that are between the parentheses after it.</p>
<p class="indent">Next, we’ll test all the possible keys. Although the key for the Caesar cipher could be an integer from <span class="literal">0</span> to <span class="literal">65</span> (the length of the symbol set), the key for the transposition cipher can be between <span class="literal">1</span> and half the length of the message. The <span class="literal">for</span> loop on line 23 runs the test code with the keys <span class="literal">1</span> up to (but not including) the length of the message.</p>
<p class="programs1">22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check all possible keys for each message:<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for key in range(1, int(len(message)/2)):<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encrypted = transpositionEncrypt.encryptMessage(key, message)<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decrypted = transpositionDecrypt.decryptMessage(key, encrypted)</p>
<p class="indent">Line 24 encrypts the string in <span class="literal">message</span> using the <span class="literal">encryptMessage()</span> function. Because this function is inside the <em class="calibre7">transpositionEncrypt.py</em> file, we need <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-226"></span>to add <span class="literal">transpositionEncrypt.</span> (with the period at the end) to the front of the function name.</p>
<p class="indent">The encrypted string that is returned from <span class="literal">encryptMessage()</span> is then passed to <span class="literal">decryptMessage()</span>. We need to use the same key for both function calls. The return value from <span class="literal">decryptMessage()</span> is stored in a variable named <span class="literal">decrypted</span>. If the functions worked, the string in <span class="literal">message</span> should be the same as the string in <span class="literal">decrypted</span>. We’ll look at how the program checks this next.</p>
<h3 class="h1" id="calibre_link-573"><strong class="calibre3">Checking Whether the Cipher Worked and Ending the Program</strong></h3>
<p class="noindent">After we’ve encrypted and decrypted the message, we need to check whether both processes worked correctly. To do that, we simply need to check whether the original message is the same as the decrypted message.</p>
<p class="programs1">27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If the decryption doesn't match the original message, display<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# an error message and quit:<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if message != decrypted:<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Mismatch with key %s and message %s.' % (key,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message))<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted as: ' + decrypted)<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()<br class="calibre9" />33.<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Transposition cipher test passed.')</p>
<p class="indent">Line 29 tests whether <span class="literal">message</span> and <span class="literal">decrypted</span> are equal. If they aren’t, Python displays an error message on the screen. Lines 30 and 31 print the <span class="literal">key</span>, <span class="literal">message</span>, and <span class="literal">decrypted</span> values as feedback to help us figure out what went wrong. Then the program exits.</p>
<p class="indent">Normally, programs exit when the execution reaches the end of the code and there are no more lines to execute. However, when <span class="literal">sys.exit()</span> is called, the program ends immediately and stops testing new messages (because you’ll want to fix your cipher programs if even one test fails!).</p>
<p class="indent">But if the values in <span class="literal">message</span> and <span class="literal">decrypted</span> are equal, the program execution skips the <span class="literal">if</span> statement’s block and the call to <span class="literal">sys.exit()</span>. The program continues looping until it finishes running all of its tests. After the loop ends, the program runs line 34, which you know is outside of line 9’s loop because it has different indentation. Line 34 prints <span class="literal">'</span><span class="literal">Transposition cipher test passed.'</span>.</p>
<h3 class="h1" id="calibre_link-574"><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">As with our other programs, we want to check whether the program is being imported as a module or being run as the main program.</p>
<p class="programs1">37. # If transpositionTest.py is run (instead of imported as a module) call<br class="calibre9" />38. # the main() function:<br class="calibre9" />39. if __name__ == '__main__':<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-924"></span>Lines 39 and 40 do the trick, checking whether the special variable <span class="literal">__name__</span> is set to <span class="literal">'__main__'</span> and if so, calling the <span class="literal">main()</span> function.</p>
<h3 class="h1" id="calibre_link-575"><strong class="calibre3">Testing the Test Program</strong></h3>
<p class="noindent">We’ve written a program that tests the transposition cipher programs, but how do we know that the test program works? What if the test program has a bug, and it just indicates that the transposition cipher programs work when they really don’t?</p>
<p class="indent">We can test the test program by purposely adding bugs to the encryption or decryption functions. Then, if the test program doesn’t detect a problem, we know that it isn’t running as expected.</p>
<p class="indent">To add a bug to the program, we open <em class="calibre7">transpositionEncrypt.py</em> and add <span class="literal">+ 1</span> to line 36:</p>
<p class="noindentz"><em class="calibre7">transposition<br class="calibre9" />Encrypt.py</em></p>
<p class="programs1">35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move currentIndex over:<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currentIndex += key <span class="codestrong">+ 1</span></p>
<p class="indent">Now that the encryption code is broken, when we run the test program, it should print an error, like this:</p>
<p class="programs1">Test #1: "JEQLDFKJZWALCOYACUPLTRRMLWHOBXQNEAWSLGWAGQQSRSIUIQ..."<br class="calibre9" />Mismatch with key 1 and message<br class="calibre9" />JEQLDFKJZWALCOYACUPLTRRMLWHOBXQNEAWSLGWAGQQSRSIUIQTRGJHDVCZECRESZJARAVIPFOBWZ<br class="calibre9" />XXTBFOFHVSIGBWIBBHGKUWHEUUDYONYTZVKNVVTYZPDDMIDKBHTYJAHBNDVJUZDCEMFMLUXEONCZX<br class="calibre9" />WAWGXZSFTMJNLJOKKIJXLWAPCQNYCIQOFTEAUHRJODKLGRIZSJBXQPBMQPPFGMVUZHKFWPGNMRYXR<br class="calibre9" />OMSCEEXLUSCFHNELYPYKCNYTOUQGBFSRDDMVIGXNYPHVPQISTATKVKM.<br class="calibre9" />Decrypted as:<br class="calibre9" />JQDKZACYCPTRLHBQEWLWGQRIITGHVZCEZAAIFBZXBOHSGWBHKWEUYNTVNVYPDIKHYABDJZCMMUENZ<br class="calibre9" />WWXSTJLOKJLACNCQFEUROKGISBQBQPGVZKWGMYRMCELSFNLPKNTUGFRDVGNPVQSAKK</p>
<p class="indent">The test program failed at the first message after we purposely inserted a bug, so we know that it’s working exactly as we planned!</p>
<h3 class="h1" id="calibre_link-576">Summary</h3>
<p class="noindent">You can use your new programming skills for more than just writing programs. You can also program the computer to test programs you write to make sure they work for different inputs. Writing code to test code is a common practice.</p>
<p class="indent">In this chapter, you learned how to use the <span class="literal">random.randint()</span> function to produce pseudorandom numbers and how to use <span class="literal">random.seed()</span> to reset the seed to create more pseudorandom numbers. Although pseudorandom numbers aren’t random enough to use in cryptography programs, they’re good enough to use in this chapter’s testing program.</p>
<p class="indent">You also learned the difference between a list and list reference and that the <span class="literal">copy.deepcopy()</span> function will create copies of list values instead of <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-925"></span>reference values. Additionally, you learned how the <span class="literal">random.shuffle()</span> function can scramble the order of items in a list value by shuffling list items in place using references.</p>
<p class="indent">All of the programs we’ve created so far encrypt only short messages. In <a href="#calibre_link-58" class="calibre8">Chapter 10</a>, you’ll learn how to encrypt and decrypt entire files.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-577"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">If you ran the following program and it printed the number 8, what would it print the next time you ran it?</p>
<p class="programs1">import random<br class="calibre9" />random.seed(9)<br class="calibre9" />print(random.randint(1, 10))</p>
</li>
<li value="2" class="calibre11"><p class="noindent">What does the following program print?</p>
<p class="programs1">spam = [1, 2, 3]<br class="calibre9" />eggs = spam<br class="calibre9" />ham = eggs<br class="calibre9" />ham[0] = 99<br class="calibre9" />print(ham == spam)</p>
</li>
<li value="3" class="calibre11"><p class="noindent">Which module contains the deepcopy() function?</p></li>
<li value="4" class="calibre11"><p class="noindent">What does the following program print?</p>
<p class="programs1">import copy<br class="calibre9" />spam = [1, 2, 3]<br class="calibre9" />eggs = copy.deepcopy(spam)<br class="calibre9" />ham = copy.deepcopy(eggs)<br class="calibre9" />ham[0] = 99<br class="calibre9" />print(ham == spam)</p>
</li>
</ol>
</div>
</div>



<a href="chapter8.html">Prev: Chapter 8 - Decrypting with the Transposition Cipher</a> | <a href="chapter10.html">Next: Chapter 10 - Encrypting and Decrypting Files</a>
</body></html>