<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 13 - A Modular Arithmetic Module for the Affine Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter12.html">Prev: Chapter 12 - Hacking the Transposition Cipher</a> | <a href="chapter14.html">Next: Chapter 14 - Programming the Affine Cipher</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter12.html">Previous Chapter - Hacking the Transposition Cipher</a> | <a href="chapter14.html">Next Chapter - Programming The Affine Cipher</a></div>
<div id="calibre_link-847" class="calibre">
<h2 class="h2a1" id="calibre_link-59"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-938" class="calibre1"></span><span class="big">13</span><br class="calibre15" />A MODULAR ARITHMETIC MODULE FOR THE AFFINE CIPHER</h2>
<p class="epigraph"><em class="calibre7">“People have been defending their own privacy for centuries with whispers, darkness, envelopes, closed doors, secret handshakes, and couriers. The technologies of the past did not allow for strong privacy, but electronic technologies do.”<br class="calibre9" />&mdash;Eric Hughes, “A Cypherpunk’s Manifesto” (1993)</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In this chapter, you’ll learn about the multiplicative cipher and the affine cipher. The multiplicative cipher is similar to the Caesar cipher but encrypts using multiplication rather than addition. The affine cipher combines the multiplicative cipher and the Caesar cipher, resulting in a stronger and more reliable encryption.</p>
<p class="indent">But first, you’ll learn about modular arithmetic and greatest common divisors&mdash;two mathematical concepts that are required to understand and implement the affine cipher. Using these concepts, we’ll create a module to handle wraparound and find valid keys for the affine cipher. We’ll use this module when we create a program for the affine cipher in <a href="#calibre_link-60" class="calibre8">Chapter 14</a>.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-170"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Modular arithmetic</p>
<p class="bull">• The modulo operator (<span class="literal">%</span>)</p>
<p class="bull">• The greatest common divisor (GCD)</p>
<p class="bull">• Multiple assignment</p>
<p class="bull">• Euclid’s algorithm for finding the GCD</p>
<p class="bull">• The multiplicative and affine ciphers</p>
<p class="bull">• Euclid’s extended algorithm for finding modular inverses</p>
</div>
<h3 class="h1" id="calibre_link-640"><strong class="calibre3">Modular Arithmetic</strong></h3>
<p class="noindent"><em class="calibre7">Modular arithmetic</em>, or <em class="calibre7">clock arithmetic</em>, refers to math in which numbers wrap around when they reach a particular value. We’ll use modular arithmetic to handle wraparound in the affine cipher. Let’s see how it works.</p>
<div class="image"><img src="images/00006.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-848" class="calibre8"></a><em class="calibre7">Figure 13-1: 3 o’clock + 5 hours = 8 o’clock</em></p>
<p class="indent">Imagine a clock with just an hour hand and the 12 replaced with a 0. (If programmers designed clocks, the first hour would begin at 0.) If the current time is 3 o’clock, what time will it be in 5 hours? This is easy enough to figure out: 3 + 5 = 8. It will be 8 o’clock in 5 hours. Think of the hour hand starting at 3 and then moving 5 hours clockwise, as shown in <a href="#calibre_link-848" class="calibre8">Figure 13-1</a>.</p>
<p class="indent">If the current time is 10 o’clock, what time will it be in 5 hours? Adding 5 + 10 = 15, but 15 o’clock doesn’t make sense for clocks that show only 12 hours. To find out what time it will be, you subtract 15 &ndash; 12 = 3, so it will be 3 o’clock. (Normally, you would distinguish between 3 <small class="calibre14">am</small> and 3 <small class="calibre14">pm</small>, but that doesn’t matter in modular arithmetic.)</p>
<div class="image"><img src="images/00007.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-849" class="calibre8"></a><em class="calibre7">Figure 13-2: 10 o’clock + 5 hours = 3 o’clock</em></p>
<p class="indent">Double-check this math by moving the hour hand clockwise 5 hours, starting from 10. It does indeed land on 3, as shown in <a href="#calibre_link-849" class="calibre8">Figure 13-2</a>.</p>
<p class="indent">If the current time is 10 o’clock, what time will it be in 200 hours? Adding 200 + 10 = 210, and 210 is certainly larger than 12. Because one full rotation brings the hour hand back to its original position, we can solve this problem by subtracting by 12 (which is one full rotation) until the result is a number less than 12. Subtracting 210 &ndash; 12 = 198. But 198 is still larger than 12, so we continue to subtract 12 until the difference is less than 12; <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-90"></span>in this case the final answer will be 6. If the current time is 10 o’clock, the time 200 hours later will be 6 o’clock, as shown in <a href="#calibre_link-850" class="calibre8">Figure 13-3</a>.</p>
<p class="indent">If you want to double-check the 10 o’clock + 200 hours math, you can repeatedly move the hour hand around the clock face. When you move the hour hand for the 200th hour, it should land on 6.</p>
<p class="indent">However, it’s easier to have the computer do this modular arithmetic for us with the modulo operator.</p>
<div class="image"><img src="images/00008.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-850" class="calibre8"></a><em class="calibre7">Figure 13-3: 10 o’clock + 200 hours = 6 o’clock</em></p>
<h3 class="h1" id="calibre_link-641">The Modulo Operator</h3>
<p class="noindent">You can use the <em class="calibre7">modulo operator</em>, abbreviated as <em class="calibre7">mod</em>, to write modular expressions. In Python, the mod operator is the percent sign (<span class="literal">%</span>). You can think of the mod operator as a kind of division remainder operator; for example, 21 ÷ 5 = 4 with a remainder of 1, and 21 % 5 = 1. Similarly, 15 % 12 is equal to 3, just as 15 o’clock would be 3 o’clock. Enter the following into the interactive shell to see the mod operator in action:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">21 % 5</span><br class="calibre9" />1<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">(10 + 200) % 12</span><br class="calibre9" />6<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">10 % 10</span><br class="calibre9" />0<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">20 % 10</span><br class="calibre9" />0</p>
<p class="indent">Just as 10 o’clock plus 200 hours will wrap around to 6 o’clock on a clock with 12 hours, <span class="literal">(10 + 200) % 12</span> will evaluate to <span class="literal">6</span>. Notice that numbers that divide evenly will mod to <span class="literal">0</span>, such as <span class="literal">10 % 10</span> or <span class="literal">20 % 10</span>.</p>
<p class="indent">Later, we’ll use the mod operator to handle wraparound in the affine cipher. It’s also used in the algorithm that we’ll use to find the greatest common divisor of two numbers, which will enable us to find valid keys for the affine cipher.</p>
<h3 class="h1" id="calibre_link-642">Finding Factors to Calculate the Greatest Common Divisor</h3>
<p class="noindent"><em class="calibre7">Factors</em> are the numbers that are multiplied to produce a particular number. Consider 4 × 6 = 24. In this equation, 4 and 6 are factors of 24. Because a number’s factors can also be used to divide that number without leaving a remainder, factors are also called <em class="calibre7">divisors</em>.</p>
<p class="indent">The number 24 also has some other factors:</p>
<div class="image1"><img src="images/00009.jpeg" alt="Images" class="calibre4" /></div>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-183"></span>So the factors of 24 are 1, 2, 3, 4, 6, 8, 12, and 24.</p>
<p class="indent">Let’s look at the factors of 30:</p>
<div class="image1"><img src="images/00011.jpeg" alt="Images" class="calibre4" /></div>
<p class="indent">The factors of 30 are 1, 2, 3, 5, 6, 10, 15, and 30. Note that any number will always have 1 and itself as its factors because 1 times a number is equal to that number. Notice too that the list of factors for 24 and 30 have 1, 2, 3, and 6 in common. The greatest of these common factors is 6, so 6 is the <em class="calibre7">greatest common factor</em>, more commonly known as the <em class="calibre7">greatest common divisor (GCD)</em>, of 24 and 30.</p>
<p class="indent">It’s easiest to find a GCD of two numbers by visualizing their factors. We’ll visualize factors and the GCD using <em class="calibre7">Cuisenaire rods</em>. A Cuisenaire rod is made up of squares equal to the number the rod represents, and the rods help us visualize math operations. <a href="#calibre_link-851" class="calibre8">Figure 13-4</a> uses Cuisenaire rods to visualize 3 + 2 = 5 and 5 × 3 = 15.</p>
<div class="image"><img src="images/00012.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-851" class="calibre8"></a><em class="calibre7">Figure 13-4: Using Cuisenaire rods to demonstrate addition and multiplication</em></p>
<p class="indent">A rod of 3 added to a rod of 2 is the same length as a rod of 5. You can even use rods to find answers to multiplication problems by making a rectangle with sides made from rods of the numbers you want to multiply. The number of squares in the rectangle is the answer to the multiplication problem.</p>
<p class="indent">If a rod 20 units long represents the number 20, a number is a factor of 20 if that number’s rods can evenly fit inside the 20-square rod. <a href="#calibre_link-852" class="calibre8">Figure 13-5</a> shows that 4 and 10 are factors of 20 because they fit evenly into 20.</p>
<div class="image"><img src="images/00013.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-852" class="calibre8"></a><em class="calibre7">Figure 13-5: Cuisenaire rods demonstrating 4 and 10 are factors of 20</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-184"></span>But 6 and 7 are not factors of 20, because the 6-square and 7-square rods won’t evenly fit into the 20-square rod, as shown in <a href="#calibre_link-853" class="calibre8">Figure 13-6</a>.</p>
<div class="image"><img src="images/00014.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-853" class="calibre8"></a><em class="calibre7">Figure 13-6: Cuisenaire rods demonstrating 6 and 7 are not factors of 20</em></p>
<p class="indent">The GCD of two rods, or two numbers represented by those rods, is the <em class="calibre7">longest</em> rod that can evenly fit into <em class="calibre7">both</em> rods, as shown in <a href="#calibre_link-854" class="calibre8">Figure 13-7</a>.</p>
<div class="image"><img src="images/00015.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-854" class="calibre8"></a><em class="calibre7">Figure 13-7: Cuisenaire rods demonstrating the GCD of 16 and 24</em></p>
<p class="indent">In this example, the 8-square rod is the longest rod that can fit evenly into 24 and 32. Therefore, 8 is their GCD.</p>
<p class="indent">Now that you know how factors and the GCD work, let’s find the GCD of two numbers using a function we can write in Python.</p>
<h3 class="h1" id="calibre_link-643">Multiple Assignment</h3>
<p class="noindent">The <span class="literal">gcd()</span> function we’ll write finds the GCD of two numbers. But before you learn how to code it, let’s look at a trick in Python called <em class="calibre7">multiple assignment</em>. The multiple assignment trick lets you assign values to more than one variable at once in a single assignment statement. Enter the following into the interactive shell to see how this works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam, eggs = 42, 'Hello'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />42<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs</span><br class="calibre9" />'Hello'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">a, b, c, d = ['Alice', 'Brienne', 'Carol', 'Danielle']</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">a</span><br class="calibre9" />'Alice'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">d</span><br class="calibre9" />'Danielle'</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-225"></span>You can separate the variable names on the left side of the <span class="literal">=</span> operator as well as the values on the right side of the <span class="literal">=</span> operator using commas. You can also assign each of the values in a list to its own variable as long as the number of items in the list is the same as the number of variables on the left side of the <span class="literal">=</span> operator. If you don’t have the same number of variables as you have values, Python will raise an error that indicates the call needs more or has too many values.</p>
<p class="indent">One of the main uses of multiple assignment is to swap the values in two variables. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = 'hello'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs = 'goodbye'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam, eggs = eggs, spam</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />'goodbye'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs</span><br class="calibre9" />'hello'</p>
<p class="indent">After assigning <span class="literal">'</span><span class="literal">hello'</span> to <span class="literal">spam</span> and <span class="literal">'goodbye'</span> to <span class="literal">eggs</span>, we swap those values using multiple assignment. Let’s look at how to use this swapping trick to implement Euclid’s algorithm for finding the GCD.</p>
<h3 class="h1" id="calibre_link-644">Euclid’s Algorithm for Finding the GCD</h3>
<p class="noindent">Finding the GCD seems simple enough: identify all the factors of the two numbers you’ll use and then find the largest factor they have in common. But it isn’t so easy to find the GCD of larger numbers.</p>
<p class="indent">Euclid, a mathematician who lived 2000 years ago, came up with a short algorithm for finding the GCD of two numbers using modular arithmetic. Here’s a <span class="literal">gcd()</span> function that implements his algorithm in Python code, returning the GCD of integers <span class="literal">a</span> and <span class="literal">b</span>:</p>
<p class="programs1">def gcd(a, b):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;while a != 0:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a, b = b % a, a<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;return b</p>
<p class="indent">The <span class="literal">gcd()</span> function takes two numbers <span class="literal">a</span> and <span class="literal">b</span>, and then uses a loop and multiple assignment to find the GCD. <a href="#calibre_link-855" class="calibre8">Figure 13-8</a> shows how the <span class="literal">gcd()</span> function finds the GCD of 24 and 32.</p>
<p class="indent">Exactly how Euclid’s algorithm works is beyond the scope of this book, but you can rely on this function to return the GCD of the two integers you pass it. If you call this function from the interactive shell and pass it <span class="literal">24</span> and <span class="literal">32</span> for the parameters <span class="literal">a</span> and <span class="literal">b</span>, the function will return <span class="literal">8</span>:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">gcd(24, 32)</span><br class="calibre9" />8</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-99"></span><img src="images/00016.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-855" class="calibre8"></a><em class="calibre7">Figure 13-8: How the <span class="literalcaption">gcd()</span> function works</em></p>
<p class="indent">The great benefit of this <span class="literal">gcd()</span> function, though, is that it can easily handle large numbers:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">gcd(409119243, 87780243)</span><br class="calibre9" />6837</p>
<p class="indent">This <span class="literal">gcd()</span> function will come in handy when choosing valid keys for the multiplicative and affine ciphers, as you’ll learn in the next section.</p>
<h3 class="h1" id="calibre_link-645">Understanding How the Multiplicative and Affine Ciphers Work</h3>
<p class="noindent">In the Caesar cipher, encrypting and decrypting symbols involved converting them to numbers, adding or subtracting the key, and then converting the new number back to a symbol.</p>
<p class="indent">When encrypting with the <em class="calibre7">multiplicative cipher</em>, you’ll <em class="calibre7">multiply</em> the index by the key. For example, if you encrypted the letter E with the key 3, you would find E’s index (4) and multiply it by the key (3) to get the index of the encrypted letter (4 × 3 = 12), which would be M.</p>
<p class="indent">When the product exceeds the total number of letters, the multiplicative cipher has a wraparound issue similar to the Caesar cipher, but now we can use the mod operator to solve that issue. For example, the Caesar cipher’s <span class="literal">SYMBOLS</span> variable contained the string <span class="literal">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'</span>. The following is a table of the first and last few characters of <span class="literal">SYMBOLS</span> along with their indexes:</p>
<div class="image"><img src="images/00018.jpeg" alt="Images" class="calibre4" /></div>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-318"></span>Let’s calculate what these symbols encrypt to when the key is 17. To encrypt the symbol F with key 17, multiply its index 5 by 17 and mod the result by 66 to handle the wraparound of the 66-symbol set. The result of (5 × 17) mod 66 is 19, and 19 corresponds to the symbol T. So F encrypts to T in the multiplicative cipher with key 17. The following two strings show all the characters in plaintext and their corresponding ciphertext symbols. The symbol at a given index in the first string encrypts to the symbol at that same index in the second string:</p>
<p class="programs1">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'<br class="calibre9" />'ARizCTk2EVm4GXo6IZq8Kbs0Mdu!Ofw.QhyBSj1DUl3FWn5HYp7Jar9Lct Nev?Pgx'</p>
<p class="indent">Compare this encryption output to the one you’d get when you encrypt using the Caesar cipher, which simply shifts the plaintext symbols over to create the ciphertext symbols:</p>
<p class="programs1">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'<br class="calibre9" />'RSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.ABCDEFGHIJKLMNOPQ'</p>
<p class="indent">As you can see, the multiplicative cipher with key 17 results in ciphertext that is more randomized and harder to crack. However, you’ll need to be careful when choosing keys for the multiplicative ciphers. I’ll discuss why next.</p>
<h4 class="h2" id="calibre_link-646"><strong class="calibre3"><em class="calibre12">Choosing Valid Multiplicative Keys</em></strong></h4>
<p class="noindent">You can’t just use any number for the multiplicative cipher’s key. For example, if you chose the key 11, here’s the mapping you would end up with:</p>
<p class="programs1">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'<br class="calibre9" />'ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4ALWhs4'</p>
<p class="indent">Notice that this key doesn’t work because the symbols A, G, and M all encrypt to the same letter, A. When you encounter an A in the ciphertext, you wouldn’t know which symbol it decrypts to. Using this key, you would run into the same problem when encrypting letters A, N, F, S, and others.</p>
<p class="indent">In the multiplicative cipher, the key and the size of the symbol set must be relatively prime to each other. Two numbers are <em class="calibre7">relatively prime</em> (or <em class="calibre7">coprime</em>) if their GCD is 1. In other words, they have no factors in common except 1. For example, the numbers <span class="literal">num1</span> and <span class="literal">num2</span> are relatively prime if <span class="literal">gcd(num1, num2) == 1</span>, where <span class="literal">num1</span> is the key and <span class="literal">num2</span> is the size of the symbol set. In the previous example, because 11 (the key) and 66 (the symbol set size) have a GCD that isn’t 1, they are not relatively prime, which means that the key 11 cannot be used for the multiplicative cipher. Note that numbers don’t actually have to be prime numbers to be relatively prime to each other.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-100"></span>Knowing how to use modular arithmetic and the <span class="literal">gcd()</span> function is important when using the multiplicative cipher. You can use the <span class="literal">gcd()</span> function to figure out whether a pair of numbers is relatively prime, which you need to know to choose valid keys for the multiplicative cipher.</p>
<p class="indent">The multiplicative cipher has only 20 different keys for a set of 66 symbols, even fewer than the Caesar cipher! However, you can combine the multiplicative cipher and the Caesar cipher to get the more powerful affine cipher, which I explain next.</p>
<h4 class="h2" id="calibre_link-647"><strong class="calibre3"><em class="calibre12">Encrypting with the Affine Cipher</em></strong></h4>
<p class="noindent">One downside to using the multiplicative cipher is that the letter <em class="calibre7">A</em> always maps to the letter <em class="calibre7">A</em>. The reason is that <em class="calibre7">A</em>’s number is 0, and 0 multiplied by anything will always be 0. You can fix this issue by adding a second key to perform a Caesar cipher encryption after the multiplicative cipher’s multiplication and modding is done. This extra step changes the multiplicative cipher into the <em class="calibre7">affine cipher</em>.</p>
<p class="indent">The affine cipher has two keys: Key A and Key B. Key A is the integer you use to multiply the letter’s number. After you multiply the plaintext by Key A, you add Key B to the product. Then you mod the sum by 66, as you did in the original Caesar cipher. This means the affine cipher has 66 times as many possible keys as the multiplicative cipher. It also ensures that the letter A doesn’t always encrypt to itself.</p>
<p class="indent">The decryption process for the affine cipher mirrors the encryption process; both are shown in <a href="#calibre_link-856" class="calibre8">Figure 13-9</a>.</p>
<div class="image"><img src="images/00019.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-856" class="calibre8"></a><em class="calibre7">Figure 13-9: The affine cipher’s encryption and decryption processes</em></p>
<p class="indent">We decrypt the affine cipher using the opposite operations used for encryption. Let’s look at the decryption process and how to calculate the modular inverse in more detail.</p>
<h4 class="h2" id="calibre_link-648"><strong class="calibre3"><em class="calibre12">Decrypting with the Affine Cipher</em></strong></h4>
<p class="noindent">In the Caesar cipher, you used addition to encrypt and subtraction to decrypt. In the affine cipher, you use multiplication to encrypt. Naturally, you might think you can divide to decrypt with the affine cipher. But if you <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-101"></span>try this, you’ll see that it doesn’t work. To decrypt with the affine cipher, you need to multiply by the key’s modular inverse. This reverses the mod operation from the encryption process.</p>
<p class="indent">A <em class="calibre7">modular inverse</em> of two numbers is represented by the expression <span class="literal">(a * i)</span> <span class="literal">% m == 1</span>, where <span class="literal">i</span> is the modular inverse and <span class="literal">a</span> and <span class="literal">m</span> are the two numbers. For example, the modular inverse of 5 mod 7 would be some number <span class="literal">i</span> where <span class="literal">(5 * i) % 7</span> is equal to 1. You can brute-force this calculation like this:</p>
<p class="equationt">1 isn’t the modular inverse of 5 mod 7, because (5 * 1) % 7 = 5.</p>
<p class="equation">2 isn’t the modular inverse of 5 mod 7, because (5 * 2) % 7 = 3.</p>
<p class="equationb">3 is the modular inverse of 5 mod 7, because (5 * 3) % 7 = 1.</p>
<p class="indent">Although the encryption and decryption keys for the Caesar cipher part of the affine cipher are the same, the encryption key and decryption keys for the multiplicative cipher are two different numbers. The encryption key can be anything you choose as long as it’s relatively prime to the size of the symbol set, which in this case is 66. If you choose the key 53 for encrypting with the affine cipher, the decryption key is the modular inverse of 53 mod 66:</p>
<p class="equationt">1 isn’t the modular inverse of 53 mod 66, because (53 * 1) % 66 = 53.</p>
<p class="equation">2 isn’t the modular inverse of 53 mod 66, because (53 * 2) % 66 = 40.</p>
<p class="equation">3 isn’t the modular inverse of 53 mod 66, because (53 * 3) % 66 = 27.</p>
<p class="equation">4 isn’t the modular inverse of 53 mod 66, because (53 * 4) % 66 = 14.</p>
<p class="equationb">5 is the modular inverse of 53 mod 66, because (53 * 5) % 66 = 1.</p>
<p class="indent">Because 5 is the modular inverse of 53 and 66, you know that the affine cipher decryption key is also 5. To decrypt a ciphertext letter, multiply that letter’s number by 5 and then mod 66. The result is the number of the original plaintext’s letter.</p>
<p class="indent">Using the 66-character symbol set, let’s encrypt the word <em class="calibre7">Cat</em> using the key <span class="literal">53</span>. <em class="calibre7">C</em> is at index <span class="literal">2</span>, and <span class="literal">2 * 53</span> is <span class="literal">106</span>, which is larger than the symbol set size, so we mod <span class="literal">106</span> by <span class="literal">66</span>, and the result is <span class="literal">40</span>. The character at index <span class="literal">40</span> in the symbol set is <span class="literal">'o'</span>, so the symbol <em class="calibre7">C</em> encrypts to <em class="calibre7">o</em>.</p>
<p class="indent">We’ll use the same steps for the next letter, <em class="calibre7">a</em>. The string <span class="literal">'a'</span> is at index <span class="literal">26</span> in the symbol set, and <span class="literal">26 * 53 % 66</span> is <span class="literal">58</span>, which is the index of <span class="literal">'7'</span>. So the symbol <em class="calibre7">a</em> encrypts to <em class="calibre7">7</em>. The string <span class="literal">'t'</span> is at index <span class="literal">45</span>, and <span class="literal">45 * 53 % 66</span> is <span class="literal">9</span>, which is the index of <span class="literal">'J'</span>. Therefore, the word <em class="calibre7">Cat</em> encrypts to <em class="calibre7">o7J</em>.</p>
<p class="indent">To decrypt, we multiply by the modular inverse of <span class="literal">53</span> <span class="literal">%</span> <span class="literal">66</span>, which is <span class="literal">5</span>. The symbol <em class="calibre7">o</em> is at index <span class="literal">40</span>, and <span class="literal">40 * 5 % 66</span> is <span class="literal">2</span>, which is the index of <span class="literal">'C'</span>. The symbol <em class="calibre7">7</em> is at index <span class="literal">58</span>, and <span class="literal">58 * 5 % 66</span> is <span class="literal">26</span>, which is the index of <span class="literal">'a'</span>. The symbol <em class="calibre7">J</em> is at index <span class="literal">9</span>, and <span class="literal">9 * 5 % 66</span> is <span class="literal">45</span>, which is the index of <span class="literal">'t'</span>. The ciphertext <em class="calibre7">o7J</em> decrypts to <em class="calibre7">Cat</em>, which is the original plaintext, just as expected.</p>
<h4 class="h2" id="calibre_link-649"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-89" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Finding Modular Inverses</em></strong></h4>
<p class="noindent">To calculate the modular inverse to determine the decryption key, you could take a brute-force approach and start testing the integer 1, and then 2, and then 3, and so on. But this is time-consuming for large keys such as 8,953,851.</p>
<p class="indent">Fortunately, you can use Euclid’s extended algorithm to find the modular inverse of a number, which in Python looks like this:</p>
<p class="programs1">def findModInverse(a, m):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;if gcd(a, m) != 1:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None&nbsp;&nbsp;# No mod inverse if a &amp; m aren't relatively prime.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;u1, u2, u3 = 1, 0, a<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;v1, v2, v3 = 0, 1, m<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;while v3 != 0:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = u3 // v3&nbsp;&nbsp;# Note that // is the integer division operator.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1, v2, v3<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;return u1 % m</p>
<p class="indent">You don’t have to understand how Euclid’s extended algorithm works to use the <span class="literal">findModInverse()</span> function. As long as the two arguments you pass to the <span class="literal">findModInverse()</span> function are relatively prime, <span class="literal">findModInverse()</span> will return the modular inverse of the <span class="literal">a</span> parameter.</p>
<p class="indent">You can learn more about how Euclid’s extended algorithm works at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<h4 class="h2" id="calibre_link-650"><strong class="calibre3"><em class="calibre12">The Integer Division Operator</em></strong></h4>
<p class="noindent">You may have noticed the <span class="literal">//</span> operator used in the <span class="literal">findModInverse()</span> function in the preceding section. This is the <em class="calibre7">integer division operator</em>. It divides two numbers and rounds down to the nearest integer. Enter the following into the interactive shell to see how the <span class="literal">//</span> operator works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">41 / 7</span><br class="calibre9" />5.857142857142857<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">41 // 7</span><br class="calibre9" />5<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">10 // 5</span><br class="calibre9" />2</p>
<p class="indent">Whereas <span class="literal">41 / 7</span> evaluates to <span class="literal">5.857142857142857</span>, using <span class="literal">41 // 7</span> evaluates to <span class="literal">5</span>. For division expressions that do not divide evenly, the <span class="literal">//</span> operator is useful for getting the whole number part of the answer (sometimes called the <em class="calibre7">quotient</em>), while the <span class="literal">%</span> operator gets the remainder. An expression that uses the <span class="literal">//</span> integer division operator always evaluates to an int, not a float. As you can see when evaluating <span class="literal">10 // 5</span>, the result is <span class="literal">2</span> instead of <span class="literal">2.0</span>.</p>
<h3 class="h1" id="calibre_link-651"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-182" class="calibre1"></span><strong class="calibre3">Source Code for the Cryptomath Module</strong></h3>
<p class="noindent">We’ll use <span class="literal">gcd()</span> and <span class="literal">findModInverse()</span> in more cipher programs later in this book, so let’s put both functions into a module. Open a new file editor window, enter the following code, and save the file as <em class="calibre7">cryptomath.py</em>:</p>
<p class="noindentz"><em class="calibre7">cryptomath.py</em></p>
<p class="programs1">&nbsp;1. # Cryptomath Module<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. def gcd(a, b):<br class="calibre9" />&nbsp;5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the GCD of a and b using Euclid's algorithm:<br class="calibre9" />&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while a != 0:<br class="calibre9" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a, b = b % a, a<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return b<br class="calibre9" />&nbsp;9.<br class="calibre9" />10.<br class="calibre9" />11. def findModInverse(a, m):<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the modular inverse of a % m, which is<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the number x such that a*x % m = 1.<br class="calibre9" />14.<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if gcd(a, m) != 1:<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None&nbsp;&nbsp;# No mod inverse if a &amp; m aren't relatively prime.<br class="calibre9" />17.<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Calculate using the extended Euclidean algorithm:<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1, u2, u3 = 1, 0, a<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1, v2, v3 = 0, 1, m<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while v3 != 0:<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = u3 // v3&nbsp;&nbsp;# Note that // is the integer division operator.<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(u3 - q * v3), v1, v2, v3<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return u1 % m</p>
<p class="indent">This program contains the <span class="literal">gcd()</span> function described earlier in this chapter and the <span class="literal">findModInverse()</span> function that implements Euclid’s extended algorithm.</p>
<p class="indent">After importing the <em class="calibre7">cryptomath.py</em> module, you can try out these functions from the interactive shell. Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import cryptomath</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cryptomath.gcd(24, 32)</span><br class="calibre9" />8<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cryptomath.gcd(37, 41)</span><br class="calibre9" />1<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cryptomath.findModInverse(7, 26)</span><br class="calibre9" />15<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">cryptomath.findModInverse(8953851, 26)</span><br class="calibre9" />17</p>
<p class="indent">As you can see, you can call the <span class="literal">gcd()</span> function and the <span class="literal">findModInverse()</span> function to find the GCD or modular inverse of two numbers.</p>
<h3 class="h1" id="calibre_link-652"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-939" class="calibre1"></span><strong class="calibre3">Summary</strong></h3>
<p class="noindent">This chapter covered some useful math concepts. The <span class="literal">%</span> operator finds the remainder after dividing one number by another. The <span class="literal">gcd()</span> function returns the largest number that can evenly divide two numbers. If the GCD of two numbers is 1, you know that those numbers are relatively prime to each other. The most useful algorithm to find the GCD of two numbers is Euclid’s algorithm.</p>
<p class="indent">Unlike the Caesar cipher, the affine cipher uses multiplication and addition instead of just addition to encrypt letters. However, not all numbers work as keys for the affine cipher. The key number and the size of the symbol set must be relatively prime to each other.</p>
<p class="indent">To decrypt with the affine cipher, you multiply the ciphertext’s index by the modular inverse of the key. The modular inverse of <span class="literal">a % m</span> is a number <span class="literal">i</span> such that <span class="literal">(a * i) % m == 1</span>. You can use Euclid’s extended algorithm to calculate modular inverses. <a href="#calibre_link-53" class="calibre8">Chapter 23</a>’s public key cipher also uses modular inverses.</p>
<p class="indent">Using the math concepts you learned in this chapter, you’ll write a program for the affine cipher in <a href="#calibre_link-60" class="calibre8">Chapter 14</a>. Because the multiplicative cipher is the same thing as the affine cipher using a Key B of <span class="literal">0</span>, you won’t have a separate multiplicative cipher program. And because the multiplicative cipher is just a less secure version of the affine cipher, you shouldn’t use it anyway.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-653"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What do the following expressions evaluate to?</p>
<p class="programs1">17 % 1000<br class="calibre9" />5 % 5</p>
</li>
<li value="2" class="calibre11"><p class="noindent">What is the GCD of 10 and 15?</p>
</li>
<li value="3" class="calibre11"><p class="noindent">What does <span class="literal">spam</span> contain after executing <span class="literal">spam, eggs = 'hello', 'world'</span>?</p>
</li>
<li value="4" class="calibre11"><p class="noindent">The GCD of 17 and 31 is 1. Are 17 and 31 relatively prime?</p>
</li>
<li value="5" class="calibre11"><p class="noindent">Why aren’t 6 and 8 relatively prime?</p></li>
<li value="6" class="calibre11"><p class="noindent">What is the formula for the modular inverse of A mod C?</p></li>
</ol>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-940"></span>
</div>
</div>
<div><a href="chapter12.html">Previous Chapter - Hacking the Transposition Cipher</a> | <a href="chapter14.html">Next Chapter - Programming The Affine Cipher</a></div>



<a href="chapter12.html">Prev: Chapter 12 - Hacking the Transposition Cipher</a> | <a href="chapter14.html">Next: Chapter 14 - Programming the Affine Cipher</a>
</body></html>