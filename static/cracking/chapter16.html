<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Chapter 16 - Programming the Simple Substitution Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter15.html">Prev: Chapter 15 - Hacking the Affine Cipher</a> | <a href="chapter17.html">Next: Chapter 17 - Hacking the Simple Substitution Cipher</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter15.html">Previous Chapter - Hacking the Affine Cipher</a> | <a href="chapter17.html">Next Chapter - Hacking the Simple Substitution Cipher</a></div>
<div id="calibre_link-843" class="calibre">
<h2 class="h2a1" id="calibre_link-62"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-947" class="calibre1"></span><span class="big">16</span><br class="calibre15" />PROGRAMMING THE SIMPLE SUBSTITUTION CIPHER</h2>
<p class="epigraph"><em class="calibre7">“The internet is the most liberating tool for humanity ever invented, and also the best for surveillance. It’s not one or the other. It’s both.”<br class="calibre9" />&mdash;John Perry Barlow, co-founder of the Electronic Frontier Foundation</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In <a href="#calibre_link-61" class="calibre8">Chapter 15</a>, you learned that the affine cipher has about a thousand possible keys but that computers can still brute-force through all of them easily. We need a cipher that has so many possible keys that no computer can brute-force through them all.</p>
<p class="indent">The <em class="calibre7">simple substitution cipher</em> is one such cipher that is effectively invulnerable to a brute-force attack because it has an enormous number of possible keys. Even if your computer could try a trillion keys every second, it would still take 12 million years for it to try every one! In this chapter, you’ll write a program to implement the simple substitution cipher and learn some useful Python functions and string methods as well.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-315"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The <span class="literal">sort()</span> list method</p></li>
<li class="calibre11"><p class="noindent">Getting rid of duplicate characters from a string</p></li>
<li class="calibre11"><p class="noindent">Wrapper functions</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">isupper()</span> and <span class="literal">islower()</span> string methods</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-678"><strong class="calibre3">How the Simple Substitution Cipher Works</strong></h3>
<p class="noindent">To implement the simple substitution cipher, we choose a random letter to encrypt each letter of the alphabet, using each letter only once. The key for the simple substitution cipher is always a string of 26 letters of the alphabet in random order. There are 403,291,461,126,605,635,584,000,000 different possible key orderings for the simple substitution cipher. That’s a lot of keys! More important, this number is so large that it’s impossible to brute-force. (To see how this number was calculated, go to <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.)</p>
<p class="indent">Let’s try using the simple substitution cipher with paper and pencil first. For this example, we’ll encrypt the message “Attack at dawn.” using the key VJZBGNFEPLITMXDWKQUCRYAHSO. First, write out the letters of the alphabet and the corresponding key underneath each letter, as in <a href="#calibre_link-844" class="calibre8">Figure 16-1</a>.</p>
<div class="image"><img src="images/00020.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-844" class="calibre8"></a><em class="calibre7">Figure 16-1: Encryption letters for the example key</em></p>
<p class="indent">To encrypt a message, find the letter in the plaintext in the top row and substitute it with the letter in the bottom row. <em class="calibre7">A</em> encrypts to <em class="calibre7">V</em>, <em class="calibre7">T</em> encrypts to <em class="calibre7">C</em>, <em class="calibre7">C</em> encrypts to <em class="calibre7">Z</em>, and so on. So the message “Attack at dawn.” encrypts to “Vccvzi vc bvax.”</p>
<p class="indent">To decrypt the encrypted message, find the letter in the ciphertext in the bottom row and replace it with the corresponding letter in the top row. <em class="calibre7">V</em> decrypts to <em class="calibre7">A</em>, <em class="calibre7">C</em> decrypts to <em class="calibre7">T</em>, <em class="calibre7">Z</em> decrypts to <em class="calibre7">C</em>, and so on.</p>
<p class="indent">Unlike the Caesar cipher, in which the bottom row shifts but remains in alphabetical order, in the simple substitution cipher the bottom row is completely scrambled. This results in far more possible keys, which is a huge advantage of using the simple substitution cipher. The disadvantage is that the key is 26 characters long and more difficult to memorize. You may need to write down the key, but if you do, make sure no one else ever reads it!</p>
<h3 class="h1" id="calibre_link-679"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-310" class="calibre1"></span>Source Code for the Simple Substitution Cipher Program</h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and save it as <em class="calibre7">simpleSubCipher.py</em>. Be sure to place the <em class="calibre7">pyperclip.py</em> file in the same directory as the <em class="calibre7">simpleSubCipher.py</em> file. Press F5 to run the program.</p>
<p class="noindentz">simpleSub<br class="calibre9" />Cipher.py</p>
<p class="programs1">&nbsp;1. # Simple Substitution Cipher<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import pyperclip, sys, random<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6.<br class="calibre9" />&nbsp;7. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br class="calibre9" />&nbsp;8.<br class="calibre9" />&nbsp;9. def main():<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = 'If a man is offered a fact which goes against his<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instincts, he will scrutinize it closely, and unless the evidence<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is overwhelming, he will refuse to believe it. If, on the other<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hand, he is offered something which affords a reason for acting<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in accordance to his instincts, he will accept it even on the<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slightest evidence. The origin of myths is explained in this way.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Bertrand Russell'<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = 'LFWOAYUISVKMNXPBDCRJTQEGHZ'<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMode = 'encrypt' # Set to 'encrypt' or 'decrypt'.<br class="calibre9" />13.<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyIsValid(myKey):<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('There is an error in the key or symbol set.')<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if myMode == 'encrypt':<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = encryptMessage(myKey, myMessage)<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif myMode == 'decrypt':<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = decryptMessage(myKey, myMessage)<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Using key %s' % (myKey))<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The %sed message is:' % (myMode))<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(translated)<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(translated)<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('This message has been copied to the clipboard.')<br class="calibre9" />26.<br class="calibre9" />27.<br class="calibre9" />28. def keyIsValid(key):<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyList = list(key)<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lettersList = list(LETTERS)<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyList.sort()<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lettersList.sort()<br class="calibre9" />33.<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return keyList == lettersList<br class="calibre9" />35.<br class="calibre9" />36.<br class="calibre9" />37. def encryptMessage(key, message):<br class="calibre9" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translateMessage(key, message, 'encrypt')<br class="calibre9" />39.<br class="calibre9" />40.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-313"></span>41. def decryptMessage(key, message):<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translateMessage(key, message, 'decrypt')<br class="calibre9" />43.<br class="calibre9" />44.<br class="calibre9" />45. def translateMessage(key, message, mode):<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = ''<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsA = LETTERS<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsB = key<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode == 'decrypt':<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# For decrypting, we can use the same code as encrypting. We<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# just need to swap where the key and LETTERS strings are used.<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsA, charsB = charsB, charsA<br class="calibre9" />53.<br class="calibre9" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Loop through each symbol in the message:<br class="calibre9" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.upper() in charsA:<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt/decrypt the symbol:<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symIndex = charsA.find(symbol.upper())<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += charsB[symIndex].upper()<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += charsB[symIndex].lower()<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Symbol is not in LETTERS; just add it:<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol<br class="calibre9" />66.<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translated<br class="calibre9" />68.<br class="calibre9" />69.<br class="calibre9" />70. def getRandomKey():<br class="calibre9" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = list(LETTERS)<br class="calibre9" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(key)<br class="calibre9" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(key)<br class="calibre9" />74.<br class="calibre9" />75.<br class="calibre9" />76. if __name__ == '__main__':<br class="calibre9" />77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-680">Sample Run of the Simple Substitution Cipher Program</h3>
<p class="noindent">When you run the <em class="calibre7">simpleSubCipher.py</em> program, the encrypted output should look like this:</p>
<p class="programs1">Using key LFWOAYUISVKMNXPBDCRJTQEGHZ<br class="calibre9" />The encrypted message is:<br class="calibre9" />Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm<br class="calibre9" />rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra<br class="calibre9" />jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor<br class="calibre9" />l calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax<br class="calibre9" />px jia rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh.<br class="calibre9" />-Facjclxo Ctrramm<br class="calibre9" /><br class="calibre9" />This message has been copied to the clipboard.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-280"></span>Notice that if the letter in the plaintext is lowercase, it’s lowercase in the ciphertext. Likewise, if the letter is uppercase in the plaintext, it’s uppercase in the ciphertext. The simple substitution cipher doesn’t encrypt spaces or punctuation marks and simply returns those characters as is.</p>
<p class="indent">To decrypt this ciphertext, paste it as the value for the <span class="literal">myMessage</span> variable on line 10 and change <span class="literal">myMode</span> to the string <span class="literal">'decrypt'</span>. When you run the program again, the decryption output should look like this:</p>
<p class="programs1">Using key LFWOAYUISVKMNXPBDCRJTQEGHZ<br class="calibre9" />The decrypted message is:<br class="calibre9" />If a man is offered a fact which goes against his instincts, he will<br class="calibre9" />scrutinize it closely, and unless the evidence is overwhelming, he will refuse<br class="calibre9" />to believe it. If, on the other hand, he is offered something which affords<br class="calibre9" />a reason for acting in accordance to his instincts, he will accept it even<br class="calibre9" />on the slightest evidence. The origin of myths is explained in this way.<br class="calibre9" />-Bertrand Russell<br class="calibre9" /><br class="calibre9" />This message has been copied to the clipboard.</p>
<h3 class="h1" id="calibre_link-681">Setting Up Modules, Constants, and the main() Function</h3>
<p class="noindent">Let’s look at the first lines of simple substitution cipher program’s source code.</p>
<p class="programs1">&nbsp;1. # Simple Substitution Cipher<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import pyperclip, sys, random<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6.<br class="calibre9" />&nbsp;7. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>
<p class="indent">Line 4 imports the <span class="literal">pyperclip</span>, <span class="literal">sys</span>, and <span class="literal">random</span> modules. The <span class="literal">LETTERS</span> constant variable is set to a string of all the uppercase letters, which is the symbol set for the simple substitution cipher program.</p>
<p class="indent">The <span class="literal">main()</span> function in <em class="calibre7">simpleSubCipher.py</em>, which is similar to the <span class="literal">main()</span> function of cipher programs in the previous chapters, is called when the program is first run. It contains the variables that store the <span class="literal">message</span>, <span class="literal">key</span>, and <span class="literal">mode</span> used for the program.</p>
<p class="programs1">9. def main():<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = 'If a man is offered a fact which goes against his<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instincts, he will scrutinize it closely, and unless the evidence<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is overwhelming, he will refuse to believe it. If, on the other<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hand, he is offered something which affords a reason for acting<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in accordance to his instincts, he will accept it even on the<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slightest evidence. The origin of myths is explained in this way.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Bertrand Russell'<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = 'LFWOAYUISVKMNXPBDCRJTQEGHZ'<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMode = 'encrypt' # Set to 'encrypt' or 'decrypt'.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-271"></span>The keys for simple substitution ciphers are easy to get wrong because they’re fairly long and need to have every letter in the alphabet. For example, it’s easy to enter a key that is missing a letter or a key that has the same letter twice. The <span class="literal">keyIsValid()</span> function makes sure the key is usable by the encryption and decryption functions, and the function exits the program with an error message if the key is not valid:</p>
<p class="programs1">14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyIsValid(myKey):<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('There is an error in the key or symbol set.')</p>
<p class="indent">If line 14 returns <span class="literal">False</span> from <span class="literal">keyIsValid()</span>, then <span class="literal">myKey</span> contains an invalid key and line 15 terminates the program.</p>
<p class="indent">Lines 16 through 19 check whether the <span class="literal">myMode</span> variable is set to <span class="literal">'encrypt'</span> or <span class="literal">'decrypt'</span> and calls either <span class="literal">encryptMessage()</span> or <span class="literal">decryptMessage()</span> accordingly:</p>
<p class="programs1">16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if myMode == 'encrypt':<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = encryptMessage(myKey, myMessage)<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif myMode == 'decrypt':<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = decryptMessage(myKey, myMessage)</p>
<p class="indent">The return value of <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage()</span> is a string of the encrypted or decrypted message that is stored in the <span class="literal">translated</span> variable.</p>
<p class="indent">Line 20 prints the key that was used to the screen. The encrypted or decrypted message is printed to the screen and also copied to the clipboard.</p>
<p class="programs1">20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Using key %s' % (myKey))<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The %sed message is:' % (myMode))<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(translated)<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(translated)<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('This message has been copied to the clipboard.')</p>
<p class="indent">Line 25 is the last line of code in the <span class="literal">main()</span> function, so the program execution returns after line 25. When the <span class="literal">main()</span> call is done on the last line of the program, the program exits.</p>
<p class="indent">Next, we’ll look at how the <span class="literal">keyIsValid()</span> function uses the <span class="literal">sort()</span> method to test whether the key is valid.</p>
<h3 class="h1" id="calibre_link-682">The sort() List Method</h3>
<p class="noindent">Lists have a <span class="literal">sort()</span> method that rearranges the list’s items into numerical or alphabetical order. This ability to sort items in a list comes in handy when you have to check whether two lists contain the same items but don’t list them in the same order.</p>
<p class="indent">In <em class="calibre7">simpleSubCipher.py</em>, a simple substitution key string value is valid only if it has each of the characters in the symbol set with no duplicate or missing letters. We can check whether a string value is a valid key by sorting it and checking whether it’s equal to the sorted <span class="literal">LETTERS</span>. But because <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-266"></span>we can sort only lists, not strings (recall that strings are immutable, meaning their values cannot be changed), we’ll obtain list versions of the string values by passing them to <span class="literal">list()</span>. Then, after sorting these lists, we can compare the two to see whether or not they’re equal. Although <span class="literal">LETTERS</span> is already in alphabetical order, we’ll sort it because we’ll expand it to contain other characters later on.</p>
<p class="programs1">28. def keyIsValid(key):<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyList = list(key)<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lettersList = list(LETTERS)<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyList.sort()<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lettersList.sort()</p>
<p class="indent">The string in <span class="literal">key</span> is passed to <span class="literal">list()</span> on line 29. The list value returned is stored in a variable named <span class="literal">keyList</span>.</p>
<p class="indent">On line 30, the <span class="literal">LETTERS</span> constant variable (which contains the string <span class="literal">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>) is passed to <span class="literal">list()</span>, which returns the list in the following format: <span class="literal">['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']</span>.</p>
<p class="indent">On lines 31 and 32, the lists in <span class="literal">keyList</span> and <span class="literal">lettersList</span> are then sorted in alphabetical order by calling the <span class="literal">sort()</span> list method on them. Note that similar to the <span class="literal">append()</span> list method, the <span class="literal">sort()</span> list method modifies the list in place and doesn’t have a return value.</p>
<p class="indent">When sorted, the <span class="literal">keyList</span> and <span class="literal">lettersList</span> values <em class="calibre7">should</em> be the same, because <span class="literal">keyList</span> was simply the characters in <span class="literal">LETTERS</span> with the order scrambled. Line 34 checks whether the values <span class="literal">keyList</span> and <span class="literal">lettersList</span> are equal:</p>
<p class="programs1">34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return keyList == lettersList</p>
<p class="indent">If <span class="literal">keyList</span> and <span class="literal">lettersList</span> are equal, you can be sure that <span class="literal">keyList</span> and the <span class="literal">key</span> parameter don’t have any duplicated characters, because <span class="literal">LETTERS</span> doesn’t have duplicates in it. In that case, line 34 returns <span class="literal">True</span>. But if <span class="literal">keyList</span> and <span class="literal">lettersList</span> don’t match, the key is invalid and line 34 returns <span class="literal">False</span>.</p>
<h3 class="h1" id="calibre_link-683">Wrapper Functions</h3>
<p class="noindent">The encryption code and the decryption code in the <em class="calibre7">simpleSubCipher.py</em> program are almost identical. When you have two very similar pieces of code, it’s best to put them into a function and call it twice rather than enter the code twice. Not only does this save time, but more important, it avoids introducing bugs while copying and pasting code. It’s also advantageous because if there’s ever a bug in the code, you only have to fix the bug in one place instead of in multiple places.</p>
<p class="indent"><em class="calibre7">Wrapper functions</em> help you avoid having to enter duplicate code by wrapping the code of another function and returning the value the wrapped function returns. Often, the wrapper function makes a slight change to <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-331"></span>the arguments or return value of the wrapped function. Otherwise, there would be no need for wrapping because you could just call the function directly.</p>
<p class="indent">Let’s look at an example of using wrapper functions in our code to understand how they work. In this case, <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage</span><span class="literal">()</span> on lines 37 and 41 are the wrapper functions:</p>
<p class="programs1">37. def encryptMessage(key, message):<br class="calibre9" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translateMessage(key, message, 'encrypt')<br class="calibre9" />39.<br class="calibre9" />40.<br class="calibre9" />41. def decryptMessage(key, message):<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translateMessage(key, message, 'decrypt')</p>
<p class="indent">Each of these wrapper functions calls <span class="literal">translateMessage</span><span class="literal">()</span>, which is the wrapped function, and returns the value that <span class="literal">translateMessage()</span> returns. (We’ll look at the <span class="literal">translateMessage()</span> function in the next section.) Because both wrapper functions use the same <span class="literal">translateMessage()</span> function, we need to modify only that one function instead of the <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage</span><span class="literal">()</span> functions if we need to make any changes to the cipher.</p>
<p class="indent">With these wrapper functions, someone who imports the program <em class="calibre7">simpleSubCipher.py</em> can call the functions named <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage()</span> just as they can with all the other cipher programs in this book. The wrapper functions have clear names that tell others who use the functions what they do without having to look at the code. As a result, if we want to share our code, others can use it more easily.</p>
<p class="indent">Other programs can encrypt a message in various ciphers by importing the cipher programs and calling their <span class="literal">encryptMessage()</span> functions, as shown here:</p>
<p class="programs1">import affineCipher, simpleSubCipher, transpositionCipher<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />ciphertext1 =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;affineCipher.encryptMessage(encKey1, 'Hello!')<br class="calibre9" />ciphertext2 = transpositionCipher.encryptMessage(encKey2, 'Hello!')<br class="calibre9" />ciphertext3 =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;simpleSubCipher.encryptMessage(encKey3, 'Hello!')</p>
<p class="indent">Naming consistency is helpful, because it makes it easier for someone familiar with one of the cipher programs to use the other cipher programs. For example, you can see that the first parameter is always the key and the second parameter is always the message, which is the convention used for most of the cipher programs in this book. Using the <span class="literal">translateMessage()</span> function instead of separate <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage</span><span class="literal">()</span> functions would be inconsistent with the other programs.</p>
<p class="indent">Let’s look at the <span class="literal">translateMessage()</span> function next.</p>
<h3 class="h1" id="calibre_link-684"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-212" class="calibre1"></span>The translateMessage() Function</h3>
<p class="noindent">The <span class="literal">translateMessage()</span> function is used for both encryption and decryption.</p>
<p class="programs1">45. def translateMessage(key, message, mode):<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = ''<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsA = LETTERS<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsB = key<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode == 'decrypt':<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# For decrypting, we can use the same code as encrypting. We<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# just need to swap where the key and LETTERS strings are used.<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charsA, charsB = charsB, charsA</p>
<p class="indent">Notice that <span class="literal">translateMessage()</span> has the parameters <span class="literal">key</span> and <span class="literal">message</span> but also a third parameter named <span class="literal">mode</span>. When we call <span class="literal">translateMessage</span><span class="literal">()</span>, the call in the <span class="literal">encryptMessage()</span> function passes <span class="literal">'encrypt'</span> for the <span class="literal">mode</span> parameter, and the call in the <span class="literal">decryptMessage()</span> function passes <span class="literal">'decrypt'</span>. This is how the <span class="literal">translateMessage()</span> function knows whether it should encrypt or decrypt the message passed to it.</p>
<p class="indent">The actual encryption process is simple: for each letter in the <span class="literal">message</span> parameter, the function looks up that letter’s index in <span class="literal">LETTERS</span> and replaces the character with the letter at that same index in the <span class="literal">key</span> parameter. Decryption does the opposite: it looks up the index in <span class="literal">key</span> and replaces the character with the letter at the same index in <span class="literal">LETTERS</span>.</p>
<p class="indent">Instead of using <span class="literal">LETTERS</span> and <span class="literal">key</span>, the program uses the variables <span class="literal">charsA</span> and <span class="literal">charsB</span>, which allow it to replace the letter in <span class="literal">charsA</span> with the letter at the same index in <span class="literal">charsB</span>. Being able to change which values are assigned to <span class="literal">charsA</span> and <span class="literal">charsB</span> makes it easy for the program to switch between encrypting and decrypting. Line 47 sets the characters in <span class="literal">charsA</span> to the characters in <span class="literal">LETTERS</span>, and line 48 sets the characters in <span class="literal">charsB</span> to the characters in <span class="literal">key</span>.</p>
<p class="indent">The following figures show how the same code can be used to either encrypt or decrypt a letter. <a href="#calibre_link-845" class="calibre8">Figure 16-2</a> illustrates the encryption process. The top row in this figure shows the characters in <span class="literal">charsA</span> (set to <span class="literal">LETTERS</span>), the middle row shows the characters in <span class="literal">charsB</span> (set to <span class="literal">key</span>), and the bottom row shows the integer indexes corresponding to the characters.</p>
<div class="image"><img src="images/00021.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-845" class="calibre8"></a><em class="calibre7">Figure 16-2: Using the index to encrypt plaintext</em></p>
<p class="indent">The code in <span class="literal">translateMessage()</span> always looks up the message character’s index in <span class="literal">charsA</span> and replaces it with the corresponding character in <span class="literal">charsB</span> at that index. So to encrypt, we just leave <span class="literal">charsA</span> and <span class="literal">charsB</span> as they are. Using the variables <span class="literal">charsA</span> and <span class="literal">charsB</span> replaces the character in <span class="literal">LETTERS</span> with the character in <span class="literal">key</span>, because <span class="literal">charsA</span> is set to <span class="literal">LETTERS</span> and <span class="literal">charsB</span> is set to <span class="literal">key</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-156"></span>To decrypt, the values in <span class="literal">charsA</span> and <span class="literal">charsB</span> are switched using <span class="literal">charsA, charsB = charsB, charsA</span> on line 52. <a href="#calibre_link-846" class="calibre8">Figure 16-3</a> shows the decryption process.</p>
<div class="image"><img src="images/00022.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-846" class="calibre8"></a><em class="calibre7">Figure 16-3: Using the index to decrypt ciphertext</em></p>
<p class="indent">Keep in mind that the code in <span class="literal">translateMessage()</span> always replaces the character in <span class="literal">charsA</span> with the character at that same index in <span class="literal">charsB</span>. So when line 52 swaps the values, the code in <span class="literal">translateMessage()</span> does the decryption process instead of the encryption process.</p>
<p class="indent">The next lines of code show how the program finds the index to use for encryption and decryption.</p>
<p class="programs1">54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Loop through each symbol in the message:<br class="calibre9" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.upper() in charsA:<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt/decrypt the symbol:<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symIndex = charsA.find(symbol.upper())</p>
<p class="indent">The <span class="literal">for</span> loop on line 55 sets the <span class="literal">symbol</span> variable to a character in the <span class="literal">message</span> string on each iteration through the loop. If the uppercase form of this symbol exists in <span class="literal">charsA</span> (recall that <span class="literal">key</span> and <span class="literal">LETTERS</span> have only uppercase characters in them), line 58 finds the index of the uppercase form of <span class="literal">symbol</span> in <span class="literal">charsA</span>. The <span class="literal">symIndex</span> variable stores this index.</p>
<p class="indent">We already know that the <span class="literal">find()</span> method would never return <span class="literal">-1</span> (a <span class="literal">-1</span> from the <span class="literal">find()</span> method means the argument could not be found in the string) because the <span class="literal">if</span> statement on line 56 guarantees that <span class="literal">symbol.upper()</span> exists in <span class="literal">charsA</span>. Otherwise, line 58 wouldn’t have been executed.</p>
<p class="indent">Next, we’ll use each encrypted or decrypted <span class="literal">symbol</span> to build the string that is returned by the <span class="literal">translateMessage()</span> function. But because <span class="literal">key</span> and <span class="literal">LETTERS</span> are both only in uppercase, we’ll need to check whether the original <span class="literal">symbol</span> in <span class="literal">message</span> was lowercase and then adjust the decrypted or encrypted <span class="literal">symbol</span> to lowercase if it was. To do this, you need to learn two string methods: <span class="literal">isupper()</span> and <span class="literal">islower()</span>.</p>
<h4 class="h2" id="calibre_link-685"><strong class="calibre3"><em class="calibre12">The isupper() and islower() String Methods</em></strong></h4>
<p class="noindent">The <span class="literal">isupper()</span> and <span class="literal">islower()</span> methods check whether a string is in uppercase or lowercase.</p>
<p class="indent">More specifically, the <span class="literal">isupper()</span> string method returns <span class="literal">True</span> if both of these conditions are met:</p><ul class="calibre10"><li class="calibre11"><p class="noindent">The string has at least one uppercase letter.</p></li><li class="calibre11"><p class="noindent">The string does not have any lowercase letters in it.</p></li></ul>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-157"></span>The <span class="literal">islower()</span> string method returns <span class="literal">True</span> if both of these conditions are met:</p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The string has at least one lowercase letter.</p></li>
<li class="calibre11"><p class="noindent">The string does not have any uppercase letters in it.</p></li>
</ul>
<p class="indent">Non-letter characters in the string don’t affect whether these methods return <span class="literal">True</span> or <span class="literal">False</span>, although both methods evaluate to <span class="literal">False</span> if only non-letter characters exist in the string. Enter the following into the interactive shell to see how these methods work:</p>
<p class="programs1">&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">'HELLO'.isupper()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;True<br class="calibre9" /><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">'HELLO WORLD 123'.isupper()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;True<br class="calibre9" /><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">'hello'.islower()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;True<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">'123'.isupper()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;False<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">''.islower()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;False</p>
<p class="indent">The example at <span class="ent">➊</span> returns <span class="literal">True</span> because <span class="literal">'HELLO WORLD 123'</span> has at least one uppercase letter in it and no lowercase letters. The numbers in that string don’t affect the evaluation. At <span class="ent">➋</span>, <span class="literal">'hello'.islower()</span> returns <span class="literal">True</span> because the string <span class="literal">'hello'</span> has at least one lowercase letter in it and no uppercase letters.</p>
<p class="indent">Let’s return to our code to see how it uses the <span class="literal">isupper()</span> and <span class="literal">islower()</span> string methods.</p>
<h4 class="h2" id="calibre_link-686"><strong class="calibre3"><em class="calibre12">Preserving Cases with isupper()</em></strong></h4>
<p class="noindent">The <em class="calibre7">simpleSubCipher.py</em> program uses the <span class="literal">isupper()</span> and <span class="literal">islower()</span> string methods to help ensure that the cases of the plaintext are reflected in the ciphertext.</p>
<p class="programs1">59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol.isupper():<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += charsB[symIndex].upper()<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += charsB[symIndex].lower()</p>
<p class="indent">Line 59 tests whether <span class="literal">symbol</span> has an uppercase letter. If it does, line 60 concatenates the uppercase version of the character at <span class="literal">charsB[symIndex]</span> to <span class="literal">translated</span>. This results in the uppercase version of the <span class="literal">key</span> character corresponding to the uppercase input. If <span class="literal">symbol</span> instead has a lowercase letter, line 62 concatenates the lowercase version of the character at <span class="literal">charsB[symIndex]</span> to <span class="literal">translated</span>.</p>
<p class="indent">If <span class="literal">symbol</span> is not a character in the symbol set, such as <span class="literal">'5'</span> or <span class="literal">'?'</span>, line 59 would return <span class="literal">False</span>, and line 62 would execute instead of line 60. The reason is that the conditions for <span class="literal">isupper()</span> wouldn’t be met because those strings don’t have at least one uppercase letter. In this case, the <span class="literal">lower()</span> <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-253"></span>method call on line 62 would have no effect on the string because it has no letters at all. The <span class="literal">lower()</span> method doesn’t change non-letter characters like <span class="literal">'5'</span> and <span class="literal">'?'</span>. It simply returns the original non-letter characters.</p>
<p class="indent">Line 62 in the <span class="literal">else</span> block accounts for any lowercase characters <em class="calibre7">and</em> non-letter characters in our <span class="literal">symbol</span> string.</p>
<p class="indent">The indentation on line 63 indicates that the <span class="literal">else</span> statement is paired with the <span class="literal">if</span> <span class="literal">symbol.upper() in charsA:</span> statement on line 56, so line 63 executes if <span class="literal">symbol</span> is not in <span class="literal">LETTERS</span>.</p>
<p class="programs1">63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Symbol is not in LETTERS; just add it:<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated += symbol</p>
<p class="indent">If <span class="literal">symbol</span> is not in <span class="literal">LETTERS</span>, line 65 executes. This means we cannot encrypt or decrypt the character in <span class="literal">symbol</span>, so we simply concatenate it to the end of <span class="literal">translated</span> as is.</p>
<p class="indent">At the end of the <span class="literal">translateMessage()</span> function, line 67 returns the value in the <span class="literal">translated</span> variable, which contains the encrypted or decrypted message:</p>
<p class="programs1">67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return translated</p>
<p class="indent">Next, we’ll look at how to use the <span class="literal">getRandomKey()</span> function to generate a valid key for the simple substitution cipher.</p>
<h3 class="h1" id="calibre_link-687"><strong class="calibre3">Generating a Random Key</strong></h3>
<p class="noindent">Typing a string for a key that contains each letter of the alphabet can be difficult. To help us with this, the <span class="literal">getRandomKey()</span> function returns a valid key to use. Lines 71 to 73 randomly scramble the characters in the <span class="literal">LETTERS</span> constant.</p>
<p class="programs1">70. def getRandomKey():<br class="calibre9" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = list(LETTERS)<br class="calibre9" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;random.shuffle(key)<br class="calibre9" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(key)</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Read “<a href="#calibre_link-571" class="calibre8">Randomly Scrambling a String</a>” on <a href="#calibre_link-571" class="calibre8">page 123</a> for an explanation of how to scramble a string using the <span class="codeitalic">list()</span>, <span class="codeitalic">random.shuffle()</span>, and <span class="codeitalic">join()</span> methods.</em></p>
</div>
<p class="indent">To use the <span class="literal">getRandomKey()</span> function, we need to change line 11 from <span class="literal">myKey = 'LFWOAYUISVKMNXPBDCRJTQEGHZ'</span> to this:</p>
<p class="programs1">11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = <span class="codestrong">getRandomKey()</span></p>
<p class="indent">Because line 20 in our simple substitution cipher program prints the key being used, you’ll be able to see the key the <span class="literal">getRandomKey()</span> function returned.</p>
<h3 class="h1" id="calibre_link-688"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-281" class="calibre1"></span><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">Lines 76 and 77 at the end of the program call <span class="literal">main()</span> if <em class="calibre7">simpleSubCipher.py</em> is being run as a program instead of being imported as a module by another program.</p>
<p class="programs1">76. if __name__ == '__main__':<br class="calibre9" />77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">This concludes our study of the simple substitution cipher program.</p>
<h3 class="h1" id="calibre_link-689">Summary</h3>
<p class="noindent">In this chapter, you learned how to use the <span class="literal">sort()</span> list method to order items in a list and how to compare two ordered lists to check for duplicate or missing characters from a string. You also learned about the <span class="literal">isupper()</span> and <span class="literal">islower()</span> string methods, which check whether a string value is made up of uppercase or lowercase letters. You learned about wrapper functions, which are functions that call other functions, usually adding only slight changes or different arguments.</p>
<p class="indent">The simple substitution cipher has far too many possible keys to brute-force through. This makes it impervious to the techniques you used to hack previous cipher programs. You’ll have to make smarter programs to break this code.</p>
<p class="indent">In <a href="#calibre_link-63" class="calibre8">Chapter 17</a>, you’ll learn how to hack the simple substitution cipher. Instead of brute-forcing through all the keys, you’ll use a more intelligent and sophisticated algorithm.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-690"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">Why can’t a brute-force attack be used against a simple substitution cipher, even with a powerful supercomputer?</p></li>
<li value="2" class="calibre11"><p class="noindent">What does the <span class="literal">spam</span> variable contain after running this code?</p>
<p class="programs1">&nbsp;&nbsp;spam = [4, 6, 2, 8]<br class="calibre9" />&nbsp;&nbsp;spam.sort()</p></li>
<li value="3" class="calibre11"><p class="noindent">What is a wrapper function?</p></li>
<li value="4" class="calibre11"><p class="noindent">What does <span class="literal">'hello'.islower()</span> evaluate to?</p></li>
<li value="5" class="calibre11"><p class="noindent">What does <span class="literal">'HELLO 123'.isupper()</span> evaluate to?</p></li>
<li value="6" class="calibre11"><p class="noindent">What does <span class="literal">'123'.islower()</span> evaluate to?</p></li>
</ol>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-948"></span>
</div>
</div>



<a href="chapter15.html">Prev: Chapter 15 - Hacking the Affine Cipher</a> | <a href="chapter17.html">Next: Chapter 17 - Hacking the Simple Substitution Cipher</a>
</body></html>