<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Chapter 14 - Programming the Affine Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter13.html">Prev: Chapter 13 - A Modular Arithmetic Module for the Affine Cipher</a> | <a href="chapter15.html">Next: Chapter 15 - Hacking the Affine Cipher</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter13.html">Previous Chapter - A Modular Arithmetic Module for the Affine Cipher</a> | <a href="chapter15.html">Next Chapter - Hacking the Affine Cipher</a></div>
<div id="calibre_link-389" class="calibre">
<h2 class="h2a1" id="calibre_link-60"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-941" class="calibre1"></span><span class="big">14</span><br class="calibre15" />PROGRAMMING THE AFFINE CIPHER</h2>
<p class="epigraph"><em class="calibre7">“I should be able to whisper something in your ear, even if your ear is 1000 miles away, and the government disagrees with that.”<br class="calibre9" />&mdash;Philip Zimmermann, creator of Pretty Good Privacy (PGP), the most widely used email encryption software in the world</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In <a href="#calibre_link-59" class="calibre8">Chapter 13</a>, you learned that the affine cipher is actually the multiplicative cipher combined with the Caesar cipher (<a href="#calibre_link-2" class="calibre8">Chapter 5</a>), and the multiplicative cipher is similar to the Caesar cipher except it uses multiplication instead of addition to encrypt messages. In this chapter, you’ll build and run programs to implement the affine cipher. Because the affine cipher uses two different ciphers as part of its encryption process, it needs two keys: one for the multiplicative cipher and another for the Caesar cipher. For the affine cipher program, we’ll split a single integer into two keys.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-106"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The tuple data type</p></li>
<li class="calibre11"><p class="noindent">How many different keys can the affine cipher have?</p></li>
<li class="calibre11"><p class="noindent">Generating random keys</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-654"><strong class="calibre3">Source Code for the Affine Cipher Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and then save it as <em class="calibre7">affineCipher.py</em>. Make sure the <em class="calibre7">pyperclip.py</em> module and the <em class="calibre7">cryptomath.py</em> module you made in <a href="#calibre_link-59" class="calibre8">Chapter 13</a> are in the same folder as the <em class="calibre7">affineCipher.py</em> file.</p>
<p class="noindentz"><em class="calibre7">affineCipher.py</em></p>
<p class="programs1">&nbsp;1. # Affine Cipher<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import sys, pyperclip, cryptomath, random<br class="calibre9" />&nbsp;5. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67890 !?.'<br class="calibre9" />&nbsp;6.<br class="calibre9" />&nbsp;7.<br class="calibre9" />&nbsp;8. def main():<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = """"A computer would deserve to be called intelligent<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if it could deceive a human into believing that it was human."<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Alan Turing"""<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = 2894<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.<br class="calibre9" />12.<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if myMode == 'encrypt':<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = encryptMessage(myKey, myMessage)<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif myMode == 'decrypt':<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = decryptMessage(myKey, myMessage)<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key: %s' % (myKey))<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%sed text:' % (myMode.title()))<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(translated)<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(translated)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Full %sed text copied to clipboard.' % (myMode))<br class="calibre9" />22.<br class="calibre9" />23.<br class="calibre9" />24. def getKeyParts(key):<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = key // len(SYMBOLS)<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyB = key % len(SYMBOLS)<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (keyA, keyB)<br class="calibre9" />28.<br class="calibre9" />29.<br class="calibre9" />30. def checkKeys(keyA, keyB, mode):<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyA == 1 and mode == 'encrypt':<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Cipher is weak if key A is 1. Choose a different key.')<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-107"></span>33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyB == 0 and mode == 'encrypt':<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Cipher is weak if key B is 0. Choose a different key.')<br class="calibre9" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; len(SYMBOLS) - 1:<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Key A must be greater than 0 and Key B must be<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;between 0 and %s.' % (len(SYMBOLS) - 1))<br class="calibre9" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:<br class="calibre9" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Key A (%s) and the symbol set size (%s) are not<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relatively prime. Choose a different key.' % (keyA,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)))<br class="calibre9" />39.<br class="calibre9" />40.<br class="calibre9" />41. def encryptMessage(key, message):<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA, keyB = getKeyParts(key)<br class="calibre9" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkKeys(keyA, keyB, 'encrypt')<br class="calibre9" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ''<br class="calibre9" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol in SYMBOLS:<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt the symbol:<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext += SYMBOLS[(symbolIndex * keyA + keyB) %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)]<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext += symbol # Append the symbol without encrypting.<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ciphertext<br class="calibre9" />53.<br class="calibre9" />54.<br class="calibre9" />55. def decryptMessage(key, message):<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA, keyB = getKeyParts(key)<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkKeys(keyA, keyB, 'decrypt')<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext = ''<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))<br class="calibre9" />60.<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol in SYMBOLS:<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypt the symbol:<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext += SYMBOLS[(symbolIndex - keyB) * modInverseOfKeyA %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)]<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext += symbol # Append the symbol without decrypting.<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return plaintext<br class="calibre9" />69.<br class="calibre9" />70.<br class="calibre9" />71. def getRandomKey():<br class="calibre9" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = random.randint(2, len(SYMBOLS))<br class="calibre9" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyB = random.randint(2, len(SYMBOLS))<br class="calibre9" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(SYMBOLS)) == 1:<br class="calibre9" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return keyA * len(SYMBOLS) + keyB<br class="calibre9" />77.<br class="calibre9" />78.<br class="calibre9" />79. # If affineCipher.py is run (instead of imported as a module), call<br class="calibre9" />80. # the main() function:<br class="calibre9" />81. if __name__ == '__main__':<br class="calibre9" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-655"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-180" class="calibre1"></span><strong class="calibre3">Sample Run of the Affine Cipher Program</strong></h3>
<p class="noindent">From the file editor, press F5 to run the <em class="calibre7">affineCipher.py</em> program; the output should look like this:</p>
<p class="programs1">Key: 2894<br class="calibre9" />Encrypted text:<br class="calibre9" />"5QG9ol3La6QI93!xQxaia6faQL9QdaQG1!!axQARLa!!AuaRLQADQALQG93!xQxaGaAfaQ1QX3o1R<br class="calibre9" />QARL9Qda!AafARuQLX1LQALQI1iQX3o1RN"Q-5!1RQP36ARuFull encrypted text copied to<br class="calibre9" />clipboard.</p>
<p class="indent">In the affine cipher program, the message, <span class="literal">"A computer would deserve to be called intelligent if it could deceive a human into believing that it was human." -Alan Turing</span>, gets encrypted with the key 2894 into ciphertext. To decrypt this ciphertext, you can copy and paste it as the new value to be stored in <span class="literal">myMessage</span> on line 9 and change <span class="literal">myMode</span> on line 13 to the string <span class="literal">'</span><span class="literal">decrypt'</span>.</p>
<h3 class="h1" id="calibre_link-656"><strong class="calibre3">Setting Up Modules, Constants, and the main() Function</strong></h3>
<p class="noindent">Lines 1 and 2 of the program are comments describing what the program is. There’s also an <span class="literal">import</span> statement for the modules used in this program:</p>
<p class="programs1">&nbsp;1. # Affine Cipher<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import sys, pyperclip, cryptomath, random</p>
<p class="indent">The four modules imported in this program serve the following functions:</p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The <span class="literal">sys</span> module is imported for the <span class="literal">exit()</span> function.</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">pyperclip</span> module is imported for the <span class="literal">copy()</span> clipboard function.</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">cryptomath</span> module that you created in <a href="#calibre_link-59" class="calibre8">Chapter 13</a> is imported for the <span class="literal">gcd()</span> and <span class="literal">findModInverse()</span> functions.</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">random</span> module is imported for the <span class="literal">random.randint()</span> function to generate random keys.</p></li>
</ul>
<p class="indent">The string stored in the <span class="literal">SYMBOLS</span> variable is the symbol set, which is the list of all characters that can be encrypted:</p>
<p class="programs1">&nbsp;5. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67890 !?.'</p>
<p class="indent">Any characters in the message that don’t appear in <span class="literal">SYMBOLS</span> remain unencrypted in the ciphertext. For example, in the sample run of <em class="calibre7">affineCipher.py</em>, the quotation marks and the hyphen (<span class="literal">-</span>) don’t get encrypted in the ciphertext because they don’t belong in the symbol set.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-277"></span>Line 8 calls the <span class="literal">main()</span> function, which is almost exactly the same as the one in the transposition cipher programs. Lines 9, 10, and 11 store the message, key, and mode in variables, respectively:</p>
<p class="programs1">&nbsp;8. def main():<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = """"A computer would deserve to be called intelligent<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if it could deceive a human into believing that it was human."<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Alan Turing"""<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = 2894<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.</p>
<p class="indent">The value stored in <span class="literal">myMode</span> determines whether the program encrypts or decrypts the message:</p>
<p class="programs1">13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if myMode == 'encrypt':<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = encryptMessage(myKey, myMessage)<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif myMode == 'decrypt':<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translated = decryptMessage(myKey, myMessage)</p>
<p class="indent">If <span class="literal">myMode</span> is set to <span class="literal">'encrypt'</span>, line 14 executes and the return value of <span class="literal">encryptMessage()</span> is stored in <span class="literal">translated</span>. But if <span class="literal">myMode</span> is set to <span class="literal">'decrypt'</span>, <span class="literal">decryptMessage()</span> is called on line 16 and the return value is stored in <span class="literal">translated</span>. I’ll cover how the <span class="literal">encryptMessage()</span> and <span class="literal">decryptMessage()</span> functions work when we define them later in the chapter.</p>
<p class="indent">After the execution passes line 16, the <span class="literal">translated</span> variable has the encrypted or decrypted version of the message in <span class="literal">myMessage</span>.</p>
<p class="indent">Line 17 displays the key used for the cipher using the <span class="literal">%s</span> placeholder, and line 18 tells the user whether the output is encrypted or decrypted text:</p>
<p class="programs1">17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key: %s' % (myKey))<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%sed text:' % (myMode.title()))<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(translated)<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(translated)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Full %sed text copied to clipboard.' % (myMode))</p>
<p class="indent">Line 19 prints the string in <span class="literal">translated</span>, which is the encrypted or decrypted version of the string in <span class="literal">myMessage</span>, and line 20 copies it to the clipboard. Line 21 notifies the user that it is on the clipboard.</p>
<h3 class="h1" id="calibre_link-657"><strong class="calibre3">Calculating and Validating the Keys</strong></h3>
<p class="noindent">Unlike the Caesar cipher, which uses addition with only one key, the affine cipher uses multiplication and addition with two integer keys, which we’ll call Key A and Key B. Because it’s easier to remember just one number, we’ll use a mathematical trick to convert two keys into one key. Let’s look at how this works in <em class="calibre7">affineCipher.py</em>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-189"></span>The <span class="literal">getKeyParts()</span> function on line 24 splits a single integer key into two integers for Key A and Key B:</p>
<p class="programs1">24. def getKeyParts(key):<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = key // len(SYMBOLS)<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyB = key % len(SYMBOLS)<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (keyA, keyB)</p>
<p class="indent">The key to split is passed to the <span class="literal">key</span> parameter. On line 25, Key A is calculated by using integer division to divide <span class="literal">key</span> by <span class="literal">len(SYMBOLS)</span>, the size of the symbol set. Integer division (<span class="literal">//</span>) returns the quotient without a remainder. The mod operator (<span class="literal">%</span>) on line 26 calculates the remainder, which we’ll use for Key B.</p>
<p class="indent">For example, with <span class="literal">2894</span> as the <span class="literal">key</span> parameter and a <span class="literal">SYMBOLS</span> string of 66 characters, Key A would be <span class="literal">2894 // 66 = 43</span> and Key B would be <span class="literal">2894 % 66 = 56</span>.</p>
<p class="indent">To combine Key A and Key B back into a single key, multiply Key A by the size of the symbol set and add Key B to the product: <span class="literal">(43 * 66) + 56</span> evaluates to <span class="literal">2894</span>, which is the integer key we started with.</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Keep in mind that according to Shannon’s Maxim (“The enemy knows the system!”) we must assume hackers know everything about the encryption algorithm, including the symbol set and the size of the symbol set. We assume that the only piece a hacker doesn’t know is the key that was used. The security of our cipher program should depend only on the secrecy of the key, not the secrecy of the symbol set or the program’s source code.</em></p>
</div>
<h4 class="h2" id="calibre_link-658"><strong class="calibre3"><em class="calibre12">The Tuple Data Type</em></strong></h4>
<p class="noindent">Line 27 looks like it returns a list value, except parentheses are used instead of square brackets. This is a <em class="calibre7">tuple</em> value.</p>
<p class="programs1">27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (keyA, keyB)</p>
<p class="indent">A tuple value is similar to a list value in that it can store other values, which can be accessed with indexes or slices. However, unlike list values, tuple values cannot be modified. There’s no <span class="literal">append()</span> method for tuple values.</p>
<p class="indent">Because <em class="calibre7">affineCipher.py</em> doesn’t need to modify the value returned by <span class="literal">getKeyParts()</span>, using a tuple is more appropriate than a list.</p>
<h4 class="h2" id="calibre_link-659"><strong class="calibre3"><em class="calibre12">Checking for Weak Keys</em></strong></h4>
<p class="noindent">Encrypting with the affine cipher involves a character’s index in <span class="literal">SYMBOLS</span> being multiplied by Key A and added to Key B. But if <span class="literal">keyA</span> is <span class="literal">1</span>, the encrypted text is very weak because multiplying the index by <span class="literal">1</span> results in the same index. In fact, as defined by the multiplicative identity property, the product of any number and 1 is that number. Similarly, if <span class="literal">keyB</span> is <span class="literal">0</span>, the encrypted text is weak because adding <span class="literal">0</span> to the index doesn’t change it. If <span class="literal">keyA</span> is <span class="literal">1</span> and <span class="literal">keyB</span> is <span class="literal">0</span> at the same time, the “encrypted” output would be identical to the original message. In other words, it wouldn’t be encrypted at all!</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-942"></span>We check for weak keys using the <span class="literal">checkKeys()</span> function on line 30. The <span class="literal">if</span> statements on lines 31 and 33 check whether <span class="literal">keyA</span> is <span class="literal">1</span> or <span class="literal">keyB</span> is <span class="literal">0</span>.</p>
<p class="programs1">30. def checkKeys(keyA, keyB, mode):<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyA == 1 and mode == 'encrypt':<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Cipher is weak if key A is 1. Choose a different key.')<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyB == 0 and mode == 'encrypt':<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Cipher is weak if key B is 0. Choose a different key.')</p>
<p class="indent">If these conditions are met, the program exits with a message indicating what went wrong. Lines 32 and 34 each pass a string to the <span class="literal">sys.exit()</span> call. The <span class="literal">sys.exit()</span> function has an optional parameter that lets you print a string to the screen before terminating the program. You can use this function to display an error message on the screen before the program quits.</p>
<p class="indent">These checks prevent you from encrypting with weak keys, but if your <span class="literal">mode</span> is set to <span class="literal">'decrypt'</span>, the checks on lines 31 and 33 don’t apply.</p>
<p class="indent">The condition on line 35 checks whether <span class="literal">keyA</span> is a negative number (that is, whether it’s less than <span class="literal">0</span>) <em class="calibre7">or</em> whether <span class="literal">keyB</span> is greater than <span class="literal">0</span> <em class="calibre7">or</em> less than the size of the symbol set minus one:</p>
<p class="programs1">35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyA &lt; 0 or keyB &lt; 0 or keyB &gt; len(SYMBOLS) - 1:<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Key A must be greater than 0 and Key B must be<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;between 0 and %s.' % (len(SYMBOLS) - 1))</p>
<p class="indent">The reason the keys are in these ranges is described in the next section. If any of these conditions is <span class="literal">True</span>, the keys are invalid and the program exits.</p>
<p class="indent">Additionally, Key A must be relatively prime to the symbol set size. This means that the greatest common divisor (GCD) of <span class="literal">keyA</span> and <span class="literal">len(SYMBOLS)</span> must be equal to <span class="literal">1</span>. Line 37 checks for this using an <span class="literal">if</span> statement, and line 38 exits the program if the two values are not relatively prime:</p>
<p class="programs1">37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:<br class="calibre9" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('Key A (%s) and the symbol set size (%s) are not<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;relatively prime. Choose a different key.' % (keyA,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)))</p>
<p class="indent">If all the conditions in the <span class="literal">checkKeys()</span> function return <span class="literal">False</span>, nothing is wrong with the key, and the program doesn’t exit. Program execution returns to the line that originally called <span class="literal">checkKeys()</span>.</p>
<h4 class="h2" id="calibre_link-660"><strong class="calibre3"><em class="calibre12">How Many Keys Can the Affine Cipher Have?</em></strong></h4>
<p class="noindent">Let’s try to calculate the number of possible keys the affine cipher has. The affine cipher’s Key B is limited to the size of the symbol set, where <span class="literal">len(SYMBOLS)</span> is <span class="literal">66</span>. At first glance, it seems like Key A could be as large as you want it to be as long as it’s relatively prime to the symbol set size. Therefore, you might think that the affine cipher has an infinite number of keys and cannot be brute-forced.</p>
<p class="indent">But this is not the case. Recall how large keys in the Caesar cipher ended up being the same as smaller keys due to the wraparound effect. <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-110"></span>With a symbol set size of 66, the key <span class="literal">67</span> in the Caesar cipher would produce the same encrypted text as the key <span class="literal">1</span>. The affine cipher also wraps around in this way.</p>
<p class="indent">Because the Key B part of the affine cipher is the same as the Caesar cipher, its range is limited from 1 to the size of the symbol set. To determine whether the affine cipher’s Key A is also limited, we’ll write a short program to encrypt a message using several different integers for Key A and see what the ciphertext looks like.</p>
<p class="indent">Open a new file editor window and enter the following source code. Save this file as <em class="calibre7">affineKeyTest.py</em> in the same folder as <em class="calibre7">affineCipher.py</em> and <em class="calibre7">cryptomath.py</em>. Then press F5 to run it.</p>
<p class="noindentz"><em class="calibre7">affineKeyTest.py</em></p>
<p class="programs1">&nbsp;1. # This program proves that the keyspace of the affine cipher is limited<br class="calibre9" />&nbsp;2. # to less than len(SYMBOLS) ^ 2.<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import affineCipher, cryptomath<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6. message = 'Make things as simple as possible, but not simpler.'<br class="calibre9" />&nbsp;7. for keyA in range(2, 80):<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = keyA * len(affineCipher.SYMBOLS) + 1<br class="calibre9" />&nbsp;9.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) == 1:<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(keyA, affineCipher.encryptMessage(key, message))</p>
<p class="indent">This program imports the <span class="literal">affineCipher</span> module for its <span class="literal">encrypt&shy;Message</span><span class="literal">()</span> function and the <span class="literal">cryptomath</span> module for its <span class="literal">gcd()</span> function. We’ll always encrypt the string stored in the <span class="literal">message</span> variable. The <span class="literal">for</span> loop remains in a range between <span class="literal">2</span> and <span class="literal">80</span>, because <span class="literal">0</span> and <span class="literal">1</span> are not allowed as valid Key A integers, as explained earlier.</p>
<p class="indent">On each iteration of the loop, line 8 calculates the key from the current <span class="literal">keyA</span> value and always uses <span class="literal">1</span> for Key B, which is why <span class="literal">1</span> is added at the end of line 8. Keep in mind that Key A must be relatively prime with the symbol set size to be valid. Key A is relatively prime with the symbol set size if the GCD of the key and the symbol set size is equal to <span class="literal">1</span>. So if the GCD of the key and the symbol set size is not equal to <span class="literal">1</span>, the <span class="literal">if</span> statement on line 10 will skip the call to <span class="literal">encryptMessage()</span> on line 11.</p>
<p class="indent">In short, this program prints the same message encrypted with several different integers for Key A. The output of this program looks like this:</p>
<p class="programs1">5 0.xTvcin?dXv.XvXn8I3Tv.XvIDXXnE3T,vEhcv?DcvXn8I3TS<br class="calibre9" />7 Tz4Nn1ipKbtnztntpDY NnztnYRttp7 N,n781nKR1ntpDY Nm9<br class="calibre9" />13 ZJH0P7ivuVtPJtPtvhGU0PJtPG8ttvWU0,PWF7Pu87PtvhGU0g3<br class="calibre9" />17 HvTx.oizERX.vX.Xz2mkx.vX.mVXXz?kx,.?6o.EVo.Xz2mkxGy<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />67 Nblf!uijoht!bt!tjnqmf!bt!qpttjcmf,!cvu!opu!tjnqmfsA<br class="calibre9" />71 0.xTvcin?dXv.XvXn8I3Tv.XvIDXXnE3T,vEhcv?DcvXn8I3TS<br class="calibre9" />73 Tz4Nn1ipKbtnztntpDY NnztnYRttp7 N,n781nKR1ntpDY Nm9<br class="calibre9" />79 ZJH0P7ivuVtPJtPtvhGU0PJtPG8ttvWU0,PWF7Pu87PtvhGU0g3</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-104"></span>Look carefully at the output, and you’ll notice that the ciphertext for Key A of <span class="literal">5</span> is the same as the ciphertext for Key A of <span class="literal">71</span>! In fact, the ciphertext from keys <span class="literal">7</span> and <span class="literal">73</span> are the same, as are the ciphertext from keys <span class="literal">13</span> and <span class="literal">79</span>!</p>
<p class="indent">Notice also that subtracting 5 from 71 results in 66, the size of our symbol set. This is why a Key A of <span class="literal">71</span> does the same thing as a Key A of <span class="literal">5</span>: the encrypted output repeats itself, or wraps around, every 66 keys. As you can see, the affine cipher has the same wraparound effect for Key A as it does for Key B. In sum, Key A is also limited to the symbol set size.</p>
<p class="indent">When you multiply 66 possible Key A keys by 66 possible Key B keys, the result is 4356 possible combinations. Then when you subtract the integers that can’t be used for Key A because they’re not relatively prime with 66, the total number of possible key combinations for the affine cipher drops to 1320.</p>
<h3 class="h1" id="calibre_link-661"><strong class="calibre3">Writing the Encryption Function</strong></h3>
<p class="noindent">To encrypt the message in <em class="calibre7">affineCipher.py</em>, we first need the <span class="literal">key</span> and the <span class="literal">message</span> to encrypt, which the <span class="literal">encryptMessage()</span> function takes as parameters:</p>
<p class="programs1">41. def encryptMessage(key, message):<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA, keyB = getKeyParts(key)<br class="calibre9" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkKeys(keyA, keyB, 'encrypt')</p>
<p class="indent">Then we need to get the integer values for Key A and Key B from the <span class="literal">getKeyParts</span><span class="literal">()</span> function by passing it <span class="literal">key</span> on line 42. Next, we check whether these values are valid keys by passing them to the <span class="literal">checkKeys()</span> function. If the <span class="literal">checkKeys()</span> function doesn’t cause the program to exit, the keys are valid and the rest of the code in the <span class="literal">encryptMessage()</span> function after line 43 can proceed.</p>
<p class="indent">On line 44, the <span class="literal">ciphertext</span> variable starts as a blank string but will eventually hold the encrypted string. The <span class="literal">for</span> loop that begins on line 45 iterates through each of the characters in <span class="literal">message</span> and then adds the encrypted character to <span class="literal">ciphertext</span>:</p>
<p class="programs1">44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ''<br class="calibre9" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:</p>
<p class="indent">By the time the <span class="literal">for</span> loop is done looping, the <span class="literal">ciphertext</span> variable will contain the complete string of the encrypted message.</p>
<p class="indent">On each iteration of the loop, the <span class="literal">symbol</span> variable is assigned a single character from <span class="literal">message</span>. If this character exists in <span class="literal">SYMBOLS</span>, which is our symbol set, the index in <span class="literal">SYMBOLS</span> is found and assigned to <span class="literal">symbolIndex</span> on line 48:</p>
<p class="programs1">46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol in SYMBOLS:<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt the symbol:<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext += SYMBOLS[(symbolIndex * keyA + keyB) %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)]<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext += symbol # Append the symbol without encrypting.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-102"></span>To encrypt the text, we need to calculate the index of the encrypted letter. Line 49 multiplies this <span class="literal">symbolIndex</span> by <span class="literal">keyA</span> and adds <span class="literal">keyB</span> to the product. Then it mods the result by the size of the symbol set, represented by the expression <span class="literal">len(SYMBOLS)</span>. Modding by <span class="literal">len(SYMBOLS)</span> handles the wraparound by ensuring the calculated index is always between <span class="literal">0</span> and up to, but not including, <span class="literal">len(SYMBOLS)</span>. The resulting number will be the index in <span class="literal">SYMBOLS</span> of the encrypted character, which is concatenated to the end of the string in <span class="literal">ciphertext</span>.</p>
<p class="indent">Everything in the previous paragraph is done on line 49, using a single line of code!</p>
<p class="indent">If <span class="literal">symbol</span> isn’t in our symbol set, <span class="literal">symbol</span> is concatenated to the end of the <span class="literal">ciphertext</span> string on line 51. For example, the quotation marks and hyphen in the original message are not in the symbol set and therefore are concatenated to the string.</p>
<p class="indent">After the code has iterated through each character in the message string, the <span class="literal">ciphertext</span> variable should contain the full encrypted string. Line 52 returns the encrypted string from <span class="literal">encryptMessage()</span>:</p>
<p class="programs1">52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ciphertext</p>
<h3 class="h1" id="calibre_link-662"><strong class="calibre3">Writing the Decryption Function</strong></h3>
<p class="noindent">The <span class="literal">decryptMessage()</span> function that decrypts the text is almost the same as <span class="literal">encryptMessage()</span>. Lines 56 to 58 are equivalent to lines 42 to 44.</p>
<p class="programs1">55. def decryptMessage(key, message):<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA, keyB = getKeyParts(key)<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkKeys(keyA, keyB, 'decrypt')<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext = ''<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;modInverseOfKeyA = cryptomath.findModInverse(keyA, len(SYMBOLS))</p>
<p class="indent">However, instead of multiplying by Key A, the decryption process multiplies by the modular inverse of Key A. The mod inverse is calculated by calling <span class="literal">cryptomath.findModInverse()</span>, as explained in <a href="#calibre_link-59" class="calibre8">Chapter 13</a>.</p>
<p class="indent">Lines 61 to 68 are almost identical to the <span class="literal">encryptMessage()</span> function’s lines 45 to 52. The only difference is on line 65.</p>
<p class="programs1">61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for symbol in message:<br class="calibre9" />62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if symbol in SYMBOLS:<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypt the symbol:<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symbolIndex = SYMBOLS.find(symbol)<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext += SYMBOLS[(symbolIndex - keyB) * modInverseOfKeyA %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(SYMBOLS)]<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext += symbol # Append the symbol without decrypting.<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return plaintext</p>
<p class="indent">In the <span class="literal">encryptMessage()</span> function, the symbol index was multiplied by Key A and then Key B was added to it. In the <span class="literal">decryptMessage()</span> function’s <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-103"></span>line 65, the symbol index first subtracts Key B from the symbol index and then multiplies it by the modular inverse. Then it mods this number by the size of the symbol set, <span class="literal">len(SYMBOLS)</span>.</p>
<p class="indent">This is how the decryption process in <em class="calibre7">affineCipher.py</em> undoes the encryption. Now let’s look at how we can change <em class="calibre7">affineCipher.py</em> so that it randomly selects valid keys for the affine cipher.</p>
<h3 class="h1" id="calibre_link-663"><strong class="calibre3">Generating Random Keys</strong></h3>
<p class="noindent">It can be difficult to come up with a valid key for the affine cipher, so you can instead use the <span class="literal">getRandomKey()</span> function to generate a random but valid key. To do this, simply change line 10 to store the return value of <span class="literal">getRandomKey</span><span class="literal">()</span> in the <span class="literal">myKey</span> variable:</p>
<p class="programs1">10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myKey = <span class="codestrong">getRandomKey()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key: %s' % (myKey))</p>
<p class="indent">Now the program randomly selects the key and prints it to the screen when line 17 executes. Let’s look at how the <span class="literal">getRandomKey()</span> function works.</p>
<p class="indent">The code on line 72 enters a <span class="literal">while</span> loop where the condition is <span class="literal">True</span>. This <em class="calibre7">infinite loop</em> will loop forever until it is told to return or the user terminates the program. If your program gets stuck in an infinite loop, you can terminate the program by pressing <small class="calibre14">ctrl</small>-C (<small class="calibre14">ctrl</small>-D on Linux or macOS). The <span class="literal">getRandomKey()</span> function will eventually exit the infinite loop with a <span class="literal">return</span> statement.</p>
<p class="programs1">71. def getRandomKey():<br class="calibre9" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = random.randint(2, len(SYMBOLS))<br class="calibre9" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyB = random.randint(2, len(SYMBOLS))</p>
<p class="indent">Lines 73 and 74 determine random numbers between <span class="literal">2</span> and the size of the symbol set for <span class="literal">keyA</span> and for <span class="literal">keyB</span>. This code ensures that there’s no chance that Key A or Key B will be equal to the invalid values <span class="literal">0</span> or <span class="literal">1</span>.</p>
<p class="indent">The <span class="literal">if</span> statement on line 75 checks to make sure that <span class="literal">keyA</span> is relatively prime with the size of the symbol set by calling the <span class="literal">gcd()</span> function in the <span class="literal">cryptomath</span> module.</p>
<p class="programs1">75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(SYMBOLS)) == 1:<br class="calibre9" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return keyA * len(SYMBOLS) + keyB</p>
<p class="indent">If <span class="literal">keyA</span> is relatively prime with the size of the symbol set, these two randomly selected keys are combined into a single key by multiplying <span class="literal">keyA</span> by the symbol set size and adding <span class="literal">keyB</span> to the product. (Note that this is the opposite of the <span class="literal">getKeyParts()</span> function, which splits a single integer key into two integers.) Line 76 returns this value from the <span class="literal">getRandomKey()</span> function.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-251"></span>If the condition on line 75 returns <span class="literal">False</span>, the code loops back to the start of the <span class="literal">while</span> loop on line 73 and picks random numbers for <span class="literal">keyA</span> and <span class="literal">keyB</span> again. The infinite loop ensures that the program continues looping until it finds random numbers that are valid keys.</p>
<h3 class="h1" id="calibre_link-664"><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">Lines 81 and 82 call the <span class="literal">main()</span> function if this program was run by itself rather than being imported by another program:</p>
<p class="programs1">79. # If affineCipher.py is run (instead of imported as a module), call<br class="calibre9" />80. # the main() function:<br class="calibre9" />81. if __name__ == '__main__':<br class="calibre9" />82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">This ensures that the <span class="literal">main()</span> function runs when the program is run but not when the program is imported as a module.</p>
<h3 class="h1" id="calibre_link-665"><strong class="calibre3">Summary</strong></h3>
<p class="noindent">Just as we did in <a href="#calibre_link-25" class="calibre8">Chapter 9</a>, in this chapter we wrote a program (<em class="calibre7">affineKeyTest.py</em>) that can test our cipher program. Using this test program, you learned that the affine cipher has approximately 1320 possible keys, which is a number you can easily hack using brute-force. This means that we’ll have to toss the affine cipher onto the heap of easily hackable weak ciphers.</p>
<p class="indent">So the affine cipher isn’t much more secure than the previous ciphers we’ve looked at. The transposition cipher can have more possible keys, but the number of possible keys is limited to the size of the message. For a message with only 20 characters, the transposition cipher can have at most 18 keys, with keys ranging from 2 to 19. You can use the affine cipher to encrypt short messages with more security than the Caesar cipher provides, because its number of possible keys is based on the symbol set.</p>
<p class="indent">In <a href="#calibre_link-61" class="calibre8">Chapter 15</a>, we’ll write a brute-force program that can break affine cipher&ndash;encrypted messages!</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-666"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">The affine cipher is the combination of which two other ciphers?</p></li>
<li value="2" class="calibre11"><p class="noindent">What is a tuple? How is a tuple different from a list?</p></li>
<li value="3" class="calibre11"><p class="noindent">If Key A is 1, why does it make the affine cipher weak?</p></li>
<li value="4" class="calibre11"><p class="noindent">If Key B is 0, why does it make the affine cipher weak?</p></li>
</ol>
</div>
</div>



<a href="chapter13.html">Prev: Chapter 13 - A Modular Arithmetic Module for the Affine Cipher</a> | <a href="chapter15.html">Next: Chapter 15 - Hacking the Affine Cipher</a>
</body></html>