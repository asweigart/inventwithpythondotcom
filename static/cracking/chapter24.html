<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 24 - Programming the Public Key Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter23.html">Prev: Chapter 23 - Generating Keys for the Public Key Cipher</a> | <a href="appendixa.html">Next: Debugging Python Code</a>


<div id="calibre_link-369" class="calibre">
<h2 class="h2a1" id="calibre_link-54"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-998" class="calibre1"></span><span class="big">24</span><br class="calibre15" />PROGRAMMING THE PUBLIC KEY CIPHER</h2>
<p class="epigraph"><em class="calibre7">“A colleague once told me that the world was full of bad security systems designed by people who read</em> Applied Cryptography.”<br class="calibre9" /><em class="calibre7">&mdash;Bruce Schneier, author of</em> Applied Cryptography</p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In <a href="#calibre_link-53" class="calibre8">Chapter 23</a>, you learned how public key cryptography works and how to generate public and private key files using the public key generation program. Now you’re ready to send your public key file to others (or post it online) so they can</p>
<p class="noindent">use it to encrypt their messages before sending them to you. In this chapter, you’ll write the public key cipher program that encrypts and decrypts messages using the public and private keys you generated.</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">WARNING</span></strong></p>
<p class="notep"><em class="calibre7">The implementation of public key cipher in this book is based on the RSA cipher. However, many additional details that we won’t cover here make this cipher unsuitable for real-world use. Although the public key cipher is impervious to the cryptanalysis techniques in this book, it is vulnerable to the advanced techniques professional cryptographers use today.</em></p>
</div>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-138"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The <span class="literal">pow()</span> function</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">min()</span> and <span class="literal">max()</span> functions</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">insert()</span> list method</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-808"><strong class="calibre3">How the Public Key Cipher Works</strong></h3>
<p class="noindent">Similar to the previous ciphers we’ve programmed, the public key cipher converts characters into numbers and then performs math on those numbers to encrypt them. What sets the public key cipher apart from other ciphers you’ve learned about is that it converts multiple characters into one integer called a <em class="calibre7">block</em> and then encrypts one block at a time.</p>
<p class="indent">The reason the public key cipher needs to work on a block that represents multiple characters is that if we used the public key encryption algorithm on a single character, the same plaintext characters would always encrypt to the same ciphertext characters. Therefore, the public key cipher would be no different from a simple substitution cipher with fancy mathematics.</p>
<h4 class="h2" id="calibre_link-809"><strong class="calibre3"><em class="calibre12">Creating Blocks</em></strong></h4>
<p class="noindent">In cryptography, a <em class="calibre7">block</em> is a large integer that represents a fixed number of text characters. The <em class="calibre7">publicKeyCipher.py</em> program we’ll create in this chapter converts the message string value into blocks, and each block is an integer that represents 169 text characters. The maximum block size depends on the symbol set size and key size. In our program, the symbol set, which contains the only characters a message can have, will be the 66 character string <span class="literal">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890 !?.'</span>.</p>
<p class="indent">The equation 2<sup class="calibre21"><em class="calibre7">key size</em></sup> &gt; <em class="calibre7">symbol set size</em><sup class="calibre21"><em class="calibre7">block size</em></sup> must hold true. For example, when you use a 1024-bit key and a symbol set of 66 characters, the maximum block size is an integer up to 169 characters because 2<sup class="calibre21">1024</sup> is greater than 66<sup class="calibre21">169</sup>. However, 2<sup class="calibre21">1024</sup> is not greater than 66<sup class="calibre21">170</sup>. If you use blocks that are too large, the math of the public key cipher won’t work, and you won’t be able to decrypt the ciphertext the program produced.</p>
<p class="indent">Let’s explore how to convert a message string into a large integer block.</p>
<h4 class="h2" id="calibre_link-371"><strong class="calibre3"><em class="calibre12">Converting a String into a Block</em></strong></h4>
<p class="noindent">As in our previous cipher programs, we can use the index of the symbol set string to convert text characters to integers and vice versa. We’ll store the symbol set in a constant named <span class="literal">SYMBOLS</span> where <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-999"></span>the character at index <span class="literal">0</span> is <span class="literal">'A'</span>, the character at index <span class="literal">1</span> is <span class="literal">'B'</span>, and so on. Enter the following into the interactive shell to see how this conversion works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456</span><br class="calibre9" /><span class="codestrong">7890 !?.'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">len(SYMBOLS)</span><br class="calibre9" />66<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[0]</span><br class="calibre9" />'A'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[30]</span><br class="calibre9" />'e'</p>
<p class="indent">We can represent text characters by their integer indexes in the symbol set. However, we also need a way to combine these small integers into a large integer that represents a block.</p>
<p class="indent">To create a block, we multiply the symbol set index of a character by the symbol set size raised to increasing powers. The block is the sum of all of these numbers. Let’s look at an example of combining small integers into one large block for the string <span class="literal">'Howdy'</span> using the following steps.</p>
<p class="indent">The integer for the block starts at <span class="literal">0</span>, and the symbol set is 66 characters long. Enter the following into the interactive shell using these numbers as an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">blockInteger = 0</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">len(SYMBOLS)</span><br class="calibre9" />66</p>
<p class="indent">The first character in the <span class="literal">'Howdy'</span> message is <span class="literal">'H'</span>, so we find the symbol set index for that character, like this:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">SYMBOLS.index('H')</span><br class="calibre9" />7</p>
<p class="indent">Because this is the first character of the message, we multiply its symbol set index by 66<sup class="calibre21">0</sup> (in Python, the exponent operator is <span class="literal">**</span>), which evaluates to <span class="literal">7</span>. We add that value to the block:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">7 * (66 ** 0)</span><br class="calibre9" />7<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger = blockInteger + 7</span></p>
<p class="indent">Then we find the symbol set index for <span class="literal">'o'</span>, the second character in <span class="literal">'Howdy'</span>. Because this is the second character of the message, we multiply the symbol set index for <span class="literal">'o'</span> by 66<sup class="calibre21">1</sup> instead of 66<sup class="calibre21">0</sup>, and then add it to the block:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">SYMBOLS.index('o')</span><br class="calibre9" />40<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger += 40 * (66 ** 1)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger</span><br class="calibre9" />2647</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-141"></span>The block is now <span class="literal">2647</span>. We can shorten the process of finding the symbol set index for each character using a single line of code:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">blockInteger += SYMBOLS.index('w') * (len(SYMBOLS) ** 2)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger += SYMBOLS.index('d') * (len(SYMBOLS) ** 3)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger += SYMBOLS.index('y') * (len(SYMBOLS) ** 4)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger</span><br class="calibre9" />957285919</p>
<p class="indent">Encoding <span class="literal">'Howdy'</span> into a single large integer block yields the integer 957,285,919, which uniquely refers to the string. By continuing to use larger and larger powers of 66, we can use a large integer to represent a string of any length up to the block size. For example, 277,981 is a block that represents the string <span class="literal">'42!'</span> and 10,627,106,169,278,065,987,481,042,235,655,809,080,528 represents the string <span class="literal">'I named my cat Zophie.'</span>.</p>
<p class="indent">Because our block size is 169, we can only encrypt up to 169 characters in a single block. If the message we want to encode is longer than 169 characters, we can just use more blocks. In the <em class="calibre7">publicKeyCipher.py</em> program, we’ll use commas to separate the blocks so the user can identify when one block ends and the next one begins.</p>
<p class="indent"><a href="#calibre_link-370" class="calibre8">Table 24-1</a> contains an example message split into blocks and shows the integer that represents each block. Each block can store at most 169 characters of the message.</p>
<p class="tabcap"><a id="calibre_link-370" class="calibre8"></a><strong class="calibre5">Table 24-1:</strong> A Message Split into Blocks</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"></td>
<td class="table_th"><p class="table"><strong class="calibre5">Message</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Block integer</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18">
<p class="table"><strong class="calibre5">1st block</strong></p>
<p class="table"><strong class="calibre5">(169 characters)</strong></p></td>
<td class="calibre18"><p class="table">Alan Mathison Turing was a British cryptanalyst and computer scientist. He was highly influential in the development of computer science and provided a formalisation of</p></td>
<td class="calibre18"><p class="programs">3013810338120027658120611166332270159047154<br class="calibre9" />7608326152595431391575797140707837485089852<br class="calibre9" />659286061395648657712401264848061468979996<br class="calibre9" />871106525448961558640277994456848107158423<br class="calibre9" />162065952633246425985956987627719631460939<br class="calibre9" />2565956887693059829154012923414594664511373<br class="calibre9" />093526087354321666137736234609864038110994<br class="calibre9" />85392482698</p></td>
</tr>
<tr class="table_w">
<td class="calibre18">
<p class="table"><strong class="calibre5">2nd block</strong></p>
<p class="table"><strong class="calibre5">(169 characters)</strong></p></td>
<td class="calibre18"><p class="table">the concepts of algorithm and computation with the Turing machine. Turing is widely considered to be the father of computer science and artificial intelligence. During W</p></td>
<td class="calibre18"><p class="programs">1106890780922147455215935080195634373132680<br class="calibre9" />102708192713651484085475402677752791958075<br class="calibre9" />872272026708702634070281109709555761008584<br class="calibre9" />1376819190225258032442691476944762174257333<br class="calibre9" />902148064107269871669093655004577014280290<br class="calibre9" />4244524711751435049117398986044838791597315<br class="calibre9" />078937194860112574798016587564452792451567<br class="calibre9" />15863348631</p></td>
</tr>
<tr class="table_w">
<td class="calibre18">
<p class="table"><strong class="calibre5">3rd block</strong></p>
<p class="table"><strong class="calibre5">(82 characters)</strong></p></td>
<td class="calibre18"><p class="table">orld War II he worked for the Government Code and Cypher School at Bletchley Park.</p></td>
<td class="calibre18"><p class="programs">1583679754961601914428952447217583697875837<br class="calibre9" />635974864128047509439056559022732095918077<br class="calibre9" />290541944859809053286915764228326887495095<br class="calibre9" />27709935741799076979034</p></td>
</tr></tbody></table>
<p class="indent">In this example, the 420-character message consists of two 169-character blocks and needs a third block for the remaining 82 characters.</p>
<h4 class="h2" id="calibre_link-810"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-299" class="calibre1"></span><strong class="calibre3"><em class="calibre12">The Mathematics of Public Key Cipher Encryption and Decryption</em></strong></h4>
<p class="noindent">Now that you know how to convert characters into block integers, let’s explore how the public key cipher uses math to encrypt each block.</p>
<p class="indent">Here are the general equations for the public key cipher:</p>
<p class="centera"><em class="calibre7">C</em> = <em class="calibre7">M</em><sup class="calibre21"><em class="calibre7">e</em></sup> mod <em class="calibre7">n</em><br class="calibre9" /><em class="calibre7">M</em> = <em class="calibre7">C</em><sup class="calibre21"><em class="calibre7">d</em></sup> mod <em class="calibre7">n</em></p>
<p class="indent">We use the first equation to encrypt each integer block and the second equation to decrypt. <em class="calibre7">M</em> represents a message block integer, and <em class="calibre7">C</em> is a ciphertext block integer. The numbers <em class="calibre7">e</em> and <em class="calibre7">n</em> make up the public key for encryption, and the numbers <em class="calibre7">d</em> and <em class="calibre7">n</em> make up the private key. Recall that everyone, including the cryptanalyst, has access to the public key (<em class="calibre7">e</em>, <em class="calibre7">n</em>).</p>
<p class="indent">Typically, we create the encrypted message by raising every block integer, like those we calculated in the previous section, to the <em class="calibre7">e</em> power and modding the result by <em class="calibre7">n</em>. This calculation results in an integer that represents the encrypted block <em class="calibre7">C</em>. Combining all the blocks results in the complete encrypted message.</p>
<p class="indent">For example, let’s encrypt the five-character string <span class="literal">'Howdy'</span> and send it to Alice. When converted to an integer block, the message is <span class="literal">[957285919]</span> (the full message fits into one block, so there is only one integer in the list value). Alice’s public key is 64 bits, which is too small to be secure, but we’ll use it to simplify our output in this example. Its <em class="calibre7">n</em> is 116,284,564,958,604,315,258,674,918,142,848,831,759 and <em class="calibre7">e</em> is 13,805,220,545,651,593,223. (These numbers would be much larger for 1024-bit keys.)</p>
<p class="indent">To encrypt, we calculate (957,285,919<sup class="calibre21">13,805,220,545,651,593,223</sup>) % 116,284,564,958,604,315,258,674,918,142,848,831,759 by passing these numbers to Python’s <span class="literal">pow()</span> function, like this:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">pow(957285919, 13805220545651593223,</span> <br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;116284564958604315258674918142848831759)</span><br class="calibre9" />43924807641574602969334176505118775186</p>
<p class="indent">Python’s <span class="literal">pow()</span> function uses a mathematical trick called modular exponentiation to quickly calculate such a large exponent. In fact, evaluating the expression <span class="literal">(957285919 ** 13805220545651593223) % 116284564958604315258674918142848831759</span> would yield the same answer but take hours to complete. The integer that <span class="literal">pow()</span> returns is a block that represents the encrypted message.</p>
<p class="indent">To decrypt, the encrypted message’s recipient needs to have the private key (<em class="calibre7">d</em>, <em class="calibre7">n</em>), raise each encrypted block integer to the <em class="calibre7">d</em> power, and then mod by <em class="calibre7">n</em>. When all the decrypted blocks are decoded into characters and combined, the recipient would get the original plaintext message.</p>
<p class="indent">For example, Alice tries to decrypt the block integer 43,924,807,641,574,602,969,334,176,505,118,775,186. Her private key’s <em class="calibre7">n</em> is the same as her <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-139"></span>public key’s <em class="calibre7">n</em>, but her private key has a <em class="calibre7">d</em> of 72,424,475,949,690,145,396,970,707,764,378,340,583. To decrypt, she runs the following:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">pow(43924807641574602969334176505118775186,</span> <br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72424475949690145396970707764378340583,</span> <br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;116284564958604315258674918142848831759)</span><br class="calibre9" />957285919</p>
<p class="indent">When we convert the block integer <span class="literal">957285919</span> to a string, we get <span class="literal">'Howdy'</span>, which is the original message. Next, you’ll learn how to convert a block into a string.</p>
<h4 class="h2" id="calibre_link-372"><strong class="calibre3"><em class="calibre12">Converting a Block to a String</em></strong></h4>
<p class="noindent">To decrypt a block to the original block integer, the first step is to convert it to the small integers for each text character. This process starts with the last character that was added to the block. We use floor division and mod operators to calculate the small integers for each text character.</p>
<p class="indent">Recall that the block integer in the previous <span class="literal">'Howdy'</span> example was <span class="literal">957285919</span>; the original message was five characters long, making the last character’s index 4; and the symbol set used for the message was 66 characters long. To determine the symbol set index of the last character, we calculate 957,285,919 / 66<sup class="calibre21">4</sup> and round down, which results in 50. We can use the integer division operator (<span class="literal">//</span>) to divide and round down. The character at index 50 in the symbol set (<span class="literal">SYMBOLS[50]</span>) is <span class="literal">'y'</span>, which is indeed the last character of the <span class="literal">'Howdy'</span> message.</p>
<p class="indent">In the interactive shell, we calculate this block integer using the following code:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">blockInteger = 957285919</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz123456</span><br class="calibre9" /><span class="codestrong">7890 !?.'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger // (66 ** 4)</span><br class="calibre9" />50<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[50]</span><br class="calibre9" />'y'</p>
<p class="indent">The next step is to mod the block integer by 66<sup class="calibre21">4</sup> to get the next block integer. Calculating 957,285,919 % (66<sup class="calibre21">4</sup>) results in 8,549,119, which happens to be the block integer value for the string <span class="literal">'Howd'</span>. We can determine the last character of this block by using floor division of (66<sup class="calibre21">3</sup>). Enter the following into the interactive shell to do this:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">blockInteger = 8549119</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[blockInteger // (len(SYMBOLS) ** 3)]</span><br class="calibre9" />'d'</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-140"></span>The last character of this block is <span class="literal">'d'</span>, making the converted string so far <span class="literal">'dy'</span>. We can remove this character from the block integer as we did before:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">blockInteger = blockInteger % (len(SYMBOLS) ** 3)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger</span><br class="calibre9" />211735</p>
<p class="indent">The integer <span class="literal">211735</span> is the block for the string <span class="literal">'How'</span>. By continuing the process, we can recover the full string from the block, like so:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">SYMBOLS[blockInteger // (len(SYMBOLS) ** 2)]</span><br class="calibre9" />'w'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger = blockInteger % (len(SYMBOLS) ** 2)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[blockInteger // (len(SYMBOLS) ** 1)]</span><br class="calibre9" />'o'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">blockInteger = blockInteger % (len(SYMBOLS) ** 1)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">SYMBOLS[blockInteger // (len(SYMBOLS) ** 0)]</span><br class="calibre9" />'H'</p>
<p class="indent">Now you know how the characters from the string <span class="literal">'Howdy'</span> are retrieved from the original block integer value <span class="literal">957285919</span>.</p>
<h4 class="h2" id="calibre_link-811"><strong class="calibre3"><em class="calibre12">Why We Can’t Hack the Public Key Cipher</em></strong></h4>
<p class="noindent">All the different types of cryptographic attacks we’ve used in this book are useless against the public key cipher when it’s implemented correctly. Here are a few reasons why:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">The brute-force attack won’t work because there are too many possible keys to check.</p></li>
<li value="2" class="calibre11"><p class="noindent">A dictionary attack won’t work because the keys are based on numbers, not words.</p></li>
<li value="3" class="calibre11"><p class="noindent">A word pattern attack won’t work because the same plaintext word can be encrypted differently depending on where in the block it appears.</p></li>
<li value="4" class="calibre11"><p class="noindent">Frequency analysis won’t work because a single encrypted block represents several characters; we can’t get a frequency count of the individual characters.</p></li></ol>
<p class="indent">Because the public key (<em class="calibre7">e</em>, <em class="calibre7">n</em>) is known to all, if a cryptanalyst can intercept the ciphertext, they would know <em class="calibre7">e</em>, <em class="calibre7">n</em>, and <em class="calibre7">C</em>. But without knowing <em class="calibre7">d</em>, it’s mathematically impossible to solve for <em class="calibre7">M</em>, the original message.</p>
<p class="indent">Recall from <a href="#calibre_link-53" class="calibre8">Chapter 23</a> that <em class="calibre7">e</em> is relatively prime with the number (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) and that <em class="calibre7">d</em> is the modular inverse of <em class="calibre7">e</em> and (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1). In <a href="#calibre_link-59" class="calibre8">Chapter 13</a>, you learned that the modular inverse of two numbers is calculated by finding <em class="calibre7">i</em> for the equation (<em class="calibre7">ai</em>) % <em class="calibre7">m</em> = 1, where <em class="calibre7">a</em> and <em class="calibre7">m</em> are two numbers in the modular problem <em class="calibre7">a</em> mod <em class="calibre7">m</em>. This means that the <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-293"></span>cryptanalyst knows that <em class="calibre7">d</em> is the inverse of <em class="calibre7">e</em> mod (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1), so we can find <em class="calibre7">d</em> to get the whole decryption key by solving the equation (<em class="calibre7">ed</em>) mod (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) = 1; however, there’s no way of knowing what (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) is.</p>
<p class="indent">We know the key sizes from the public key file, so the cryptanalyst knows that <em class="calibre7">p</em> and <em class="calibre7">q</em> are less than 2<sup class="calibre21">1024</sup> and that <em class="calibre7">e</em> is relatively prime with (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1). But <em class="calibre7">e</em> is relatively prime with <em class="calibre7">a lot</em> of numbers, and finding (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) from a range of 0 to 2<sup class="calibre21">1024</sup> possible numbers is too large a problem to brute-force.</p>
<p class="indent">Although it isn’t enough to crack the code, the cryptanalyst can glean another hint from the public key. The public key is made up of the two numbers (<em class="calibre7">e</em>, <em class="calibre7">n</em>), and we know <em class="calibre7">n</em> = <em class="calibre7">p</em> × <em class="calibre7">q</em> because that was how we calculated <em class="calibre7">n</em> when we created the public and private keys in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>. And because <em class="calibre7">p</em> and <em class="calibre7">q</em> are prime numbers, for a given number <em class="calibre7">n</em>, there can be exactly two numbers that can be <em class="calibre7">p</em> and <em class="calibre7">q</em>.</p>
<p class="indent">Recall that a prime number has no factors besides 1 and itself. Therefore, if you multiply two prime numbers, the product will have 1 and itself and the two prime numbers you started with as its only factors.</p>
<p class="indent">Therefore, to hack the public key cipher, all we need to do is figure out the factors of <em class="calibre7">n</em>. Because we know that two and only two numbers can be multiplied to get <em class="calibre7">n</em>, we won’t have too many different numbers to choose from. After we figure out which two prime numbers (<em class="calibre7">p</em> and <em class="calibre7">q</em>) when multiplied evaluate to <em class="calibre7">n</em>, we can calculate (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) and then use that result to calculate <em class="calibre7">d</em>. This calculation seems pretty easy to do. Let’s use the <span class="literal">isPrime()</span> function we wrote in the <em class="calibre7">primeNum.py</em> program in <a href="#calibre_link-65" class="calibre8">Chapter 22</a> to do the calculation.</p>
<p class="indent">We can modify <span class="literal">isPrime()</span> to return the first factors it finds, because we know that there can be only two factors of <em class="calibre7">n</em> besides 1 and <em class="calibre7">n</em>:</p>
<p class="programs1">def isPrime(num):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;# Returns (p,q) where p and q are factors of num.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;# See if num is divisible by any number up to the square root of num:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, int(math.sqrt(num)) + 1):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % i == 0:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (i, num / i)<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;return None # No factors exist for num; num must be prime.</p>
<p class="indent">If we wrote a public key cipher hacker program, we could just call this function, pass <em class="calibre7">n</em> to it (which we would get from the public key file), and wait for it to find the factors <em class="calibre7">p</em> and <em class="calibre7">q</em>. Then we could find what (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) is, which means that we could calculate the mod inverse of <em class="calibre7">e</em> mod (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) to get <em class="calibre7">d</em>, the decryption key. Then it would be easy to calculate <em class="calibre7">M</em>, the plaintext message.</p>
<p class="indent">But there’s a problem. Recall that <em class="calibre7">n</em> is a number that is approximately 600 digits long. Python’s <span class="literal">math.sqrt()</span> function can’t handle a number that big, so it gives you an error message. But even if it could process this number, Python would be executing that <span class="literal">for</span> loop for a very long time. For <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-230"></span>example, even if your computer continued to run 5 billion years from now, there’s still almost no chance that it would find the factors of <em class="calibre7">n</em>. That’s how big these numbers are.</p>
<p class="indent">And this is exactly the strength of the public key cipher: <em class="calibre7">mathematically, there is no shortcut to finding the factors of a number.</em> It’s easy to come up with two prime numbers <em class="calibre7">p</em> and <em class="calibre7">q</em> and multiply them together to get <em class="calibre7">n</em>. But it’s nearly impossible to take a number <em class="calibre7">n</em> and figure out what <em class="calibre7">p</em> and <em class="calibre7">q</em> would be. For example, when you look at a small number like 15, you can easily say that 5 and 3 are two numbers that when multiplied equal 15. But it’s another thing entirely to try to figure out the factors of a number like 178,565,887,643,607,245,654,502,737. This fact makes the public key cipher virtually impossible to break.</p>
<h3 class="h1" id="calibre_link-812"><strong class="calibre3">Source Code for the Public Key Cipher Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and save it as <em class="calibre7">publicKeyCipher.py</em>.</p>
<p class="noindentz"><em class="calibre7">publicKey<br class="calibre9" />Cipher.py</em></p>
<p class="programs1">&nbsp;&nbsp;1. # Public Key Cipher<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import sys, math<br class="calibre9" />&nbsp;&nbsp;5.<br class="calibre9" />&nbsp;&nbsp;6. # The public and private keys for this program are created by<br class="calibre9" />&nbsp;&nbsp;7. # the makePublicPrivateKeys.py program.<br class="calibre9" />&nbsp;&nbsp;8. # This program must be run in the same folder as the key files.<br class="calibre9" />&nbsp;&nbsp;9.<br class="calibre9" />&nbsp;10. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67890 !?.'<br class="calibre9" />&nbsp;11.<br class="calibre9" />&nbsp;12. def main():<br class="calibre9" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Runs a test that encrypts a message to a file or decrypts a message<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# from a file.<br class="calibre9" />&nbsp;15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename = 'encrypted_file.txt' # The file to write to/read from.<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.<br class="calibre9" />&nbsp;17.<br class="calibre9" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode == 'encrypt':<br class="calibre9" />&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'Journalists belong in the gutter because that is where<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the ruling classes throw their guilty secrets. Gerald Priestland.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Founding Fathers gave the free press the protection it must<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have to bare the secrets of government and inform the people.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hugo Black.'<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pubKeyFilename = 'al_sweigart_pubkey.txt'<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Encrypting and writing to %s...' % (filename))<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedText = encryptAndWriteToFile(filename, pubKeyFilename,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message)<br class="calibre9" />&nbsp;23.<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Encrypted text:')<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(encryptedText)<br class="calibre9" />&nbsp;26.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1000"></span>&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif mode == 'decrypt':<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privKeyFilename = 'al_sweigart_privkey.txt'<br class="calibre9" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Reading from %s and decrypting...' % (filename))<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)<br class="calibre9" />&nbsp;31.<br class="calibre9" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted text:')<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(decryptedText)<br class="calibre9" />&nbsp;34.<br class="calibre9" />&nbsp;35.<br class="calibre9" />&nbsp;36. def getBlocksFromText(message, blockSize):<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts a string message to a list of block integers.<br class="calibre9" />&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for character in message:<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if character not in SYMBOLS:<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('ERROR: The symbol set does not have the character %s' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(character))<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()<br class="calibre9" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInts = []<br class="calibre9" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for blockStart in range(0, len(message), blockSize):<br class="calibre9" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Calculate the block integer for this block of text:<br class="calibre9" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt = 0<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(blockStart, min(blockStart + blockSize,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(message))):<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt += (SYMBOLS.index(message[i])) * (len(SYMBOLS) **<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i % blockSize))<br class="calibre9" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInts.append(blockInt)<br class="calibre9" />&nbsp;49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return blockInts<br class="calibre9" />&nbsp;50.<br class="calibre9" />&nbsp;51.<br class="calibre9" />&nbsp;52. def getTextFromBlocks(blockInts, messageLength, blockSize):<br class="calibre9" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts a list of block integers to the original message string.<br class="calibre9" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The original message length is needed to properly convert the last<br class="calibre9" />&nbsp;55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# block integer.<br class="calibre9" />&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = []<br class="calibre9" />&nbsp;57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for blockInt in blockInts:<br class="calibre9" />&nbsp;58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMessage = []<br class="calibre9" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(blockSize - 1, -1, -1):<br class="calibre9" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(message) + i &lt; messageLength:<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decode the message string for the 128 (or whatever<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# blockSize is set to) characters from this block integer:<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charIndex = blockInt // (len(SYMBOLS) ** i)<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt = blockInt % (len(SYMBOLS) ** i)<br class="calibre9" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMessage.insert(0, SYMBOLS[charIndex])<br class="calibre9" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.extend(blockMessage)<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(message)<br class="calibre9" />&nbsp;68.<br class="calibre9" />&nbsp;69.<br class="calibre9" />&nbsp;70. def encryptMessage(message, key, blockSize):<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts the message string into a list of block integers, and then<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# encrypts each block integer. Pass the PUBLIC key to encrypt.<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = []<br class="calibre9" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, e = key<br class="calibre9" />&nbsp;75.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1001"></span>&nbsp;76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in getBlocksFromText(message, blockSize):<br class="calibre9" />&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ciphertext = plaintext ^ e mod n<br class="calibre9" />&nbsp;78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks.append(pow(block, e, n))<br class="calibre9" />&nbsp;79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return encryptedBlocks<br class="calibre9" />&nbsp;80.<br class="calibre9" />&nbsp;81.<br class="calibre9" />&nbsp;82. def decryptMessage(encryptedBlocks, messageLength, key, blockSize):<br class="calibre9" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypts a list of encrypted block ints into the original message<br class="calibre9" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# string. The original message length is required to properly decrypt<br class="calibre9" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the last block. Be sure to pass the PRIVATE key to decrypt.<br class="calibre9" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedBlocks = []<br class="calibre9" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, d = key<br class="calibre9" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in encryptedBlocks:<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# plaintext = ciphertext ^ d mod n<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedBlocks.append(pow(block, d, n))<br class="calibre9" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)<br class="calibre9" />&nbsp;92.<br class="calibre9" />&nbsp;93.<br class="calibre9" />&nbsp;94. def readKeyFile(keyFilename):<br class="calibre9" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given the filename of a file that contains a public or private key,<br class="calibre9" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# return the key as a (n,e) or (n,d) tuple value.<br class="calibre9" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(keyFilename)<br class="calibre9" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content = fo.read()<br class="calibre9" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, EorD = content.split(',')<br class="calibre9" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int(keySize), int(n), int(EorD))<br class="calibre9" />102.<br class="calibre9" />103.<br class="calibre9" />104. def encryptAndWriteToFile(messageFilename, keyFilename, message,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize=None):<br class="calibre9" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Using a key from a key file, encrypt the message and save it to a<br class="calibre9" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# file. Returns the encrypted message string.<br class="calibre9" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, e = readKeyFile(keyFilename)<br class="calibre9" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if blockSize == None:<br class="calibre9" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If blockSize isn't given, set it to the largest size allowed by<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the key size and symbol set size.<br class="calibre9" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize = int(math.log(2 ** keySize, len(SYMBOLS)))<br class="calibre9" />111.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check that key size is large enough for the block size:<br class="calibre9" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not (math.log(2 ** keySize, len(SYMBOLS)) &gt;= blockSize):<br class="calibre9" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('ERROR: Block size is too large for the key and symbol<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set size. Did you specify the correct key file and encrypted<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file?')<br class="calibre9" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt the message:<br class="calibre9" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = encryptMessage(message, (n, e), blockSize)<br class="calibre9" />116.<br class="calibre9" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the large int values to one string value:<br class="calibre9" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(encryptedBlocks)):<br class="calibre9" />119.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks[i] = str(encryptedBlocks[i])<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent = ','.join(encryptedBlocks)<br class="calibre9" />121.<br class="calibre9" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Write out the encrypted string to the output file:<br class="calibre9" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent = '%s_%s_%s' % (len(message), blockSize,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent)<br class="calibre9" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(messageFilename, 'w')<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-304"></span>125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write(encryptedContent)<br class="calibre9" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Also return the encrypted string:<br class="calibre9" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return encryptedContent<br class="calibre9" />129.<br class="calibre9" />130.<br class="calibre9" />131. def readFromFileAndDecrypt(messageFilename, keyFilename):<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Using a key from a key file, read an encrypted message from a file<br class="calibre9" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and then decrypt it. Returns the decrypted message string.<br class="calibre9" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, d = readKeyFile(keyFilename)<br class="calibre9" />135.<br class="calibre9" />136.<br class="calibre9" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Read in the message length and the encrypted message from the file:<br class="calibre9" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(messageFilename)<br class="calibre9" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content = fo.read()<br class="calibre9" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageLength, blockSize, encryptedMessage = content.split('_')<br class="calibre9" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageLength = int(messageLength)<br class="calibre9" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize = int(blockSize)<br class="calibre9" />143.<br class="calibre9" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check that key size is large enough for the block size:<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not (math.log(2 ** keySize, len(SYMBOLS)) &gt;= blockSize):<br class="calibre9" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('ERROR: Block size is too large for the key and symbol<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set size. Did you specify the correct key file and encrypted<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file?')<br class="calibre9" />147.<br class="calibre9" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the encrypted message into large int values:<br class="calibre9" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = []<br class="calibre9" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in encryptedMessage.split(','):<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks.append(int(block))<br class="calibre9" />152.<br class="calibre9" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypt the large int values:<br class="calibre9" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptMessage(encryptedBlocks, messageLength, (n, d),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize)<br class="calibre9" />155.<br class="calibre9" />156.<br class="calibre9" />157. # If publicKeyCipher.py is run (instead of imported as a module), call<br class="calibre9" />158. # the main() function.<br class="calibre9" />159. if __name__ == '__main__':<br class="calibre9" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-813"><strong class="calibre3">Sample Run of the Public Key Cipher Program</strong></h3>
<p class="noindent">Let’s try running the <em class="calibre7">publicKeyCipher.py</em> program to encrypt a secret message. To send a secret message to someone using this program, get that person’s public key file and place it in the same directory as the program file.</p>
<p class="indent">To encrypt a message, make sure the <span class="literal">mode</span> variable on line 16 is set to the string <span class="literal">'encrypt'</span>. Update the <span class="literal">message</span> variable on line 19 to the message string you want to encrypt. Then set the <span class="literal">pubKeyFilename</span> variable on line 20 to the public key file’s filename. The <span class="literal">filename</span> variable on line 21 holds a filename that the ciphertext is written to. The <span class="literal">filename</span>, <span class="literal">pubKeyFilename</span>, and <span class="literal">message</span> variables are all passed to <span class="literal">encryptAndWriteToFile()</span> to encrypt the message and save it to a file.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1002"></span>When you run the program, the output should look like this:</p>
<p class="programs1">Encrypting and writing to encrypted_file.txt...<br class="calibre9" />Encrypted text:<br class="calibre9" />258_169_45108451524907138236859816039483721219475907590237903918239237768643699<br class="calibre9" />4856660301323157253724978022861702098324427738284225530186213380188880577329634<br class="calibre9" />8339229890890464969556937797072434314916522839692277034579463594713843559898418<br class="calibre9" />9307234650088689850744361262707129971782407610450208047927129687841621734776965<br class="calibre9" />7018277918490297215785759257290855812221088907016904983025542174471606494779673<br class="calibre9" />6015310089155876234277883381345247353680624585629672939709557016107275469388284<br class="calibre9" />5124192568409483737233497304087969624043516158221689454148096020738754656357140<br class="calibre9" />74772465708958607695479122809498585662785064751254235489968738346795649<span class="back">,</span>1253384<br class="calibre9" />3336975115539761332250402699868835150623017582438116840049236083573741817645933<br class="calibre9" />3719456453133658476271176035248597021972316454526545069452838766387599839340542<br class="calibre9" />4066877721135511313454252589733971962219016066614978390378611175964456773669860<br class="calibre9" />9429545605901714339082542725015140530985685117232598778176545638141403657010435<br class="calibre9" />3859244660091910391099621028192177415196156469972977305212676293746827002983231<br class="calibre9" />4668240693230032141097312556400629961518635799478652196072316424918648787555631<br class="calibre9" />6339424948975804660923616682767242948296301678312041828934473786824809308122356<br class="calibre9" />133539825048880814063389057192492939651199537310635280371</p>
<p class="indent">The program writes this output to a file named <em class="calibre7">encrypted_file.txt</em>. This is the encryption of the string in the <span class="literal">message</span> variable on line 19. Because the public key you’re using is likely different from mine, the output you get may be different, but the output’s format should be the same. As you can see in this example, the encryption is divided into two blocks, or two large integers, separated by a comma.</p>
<p class="indent">The number <span class="literal">258</span> at the start of the encryption represents the original message length and is followed by an underscore and another number <span class="literal">169</span>, which represents the block size. To decrypt this message, change the <span class="literal">mode</span> variable to <span class="literal">'decrypt'</span> and run the program again. As with encryption, make sure <span class="literal">privKeyFilename</span> on line 28 is set to the private key filename and that this file is in the same folder as <em class="calibre7">publicKeyCipher.py</em>. In addition, make sure that the encrypted file, <em class="calibre7">encrypted_file.txt</em>, is in the same folder as <em class="calibre7">publicKeyCipher.py</em>. When you run the program, the encrypted message in <em class="calibre7">encrypted_file.txt</em> is decrypted, and the output should look like this:</p>
<p class="programs1">Reading from encrypted_file.txt and decrypting...<br class="calibre9" />Decrypted text:<br class="calibre9" />Journalists belong in the gutter because that is where the ruling classes throw<br class="calibre9" />their guilty secrets. Gerald Priestland. The Founding Fathers gave the free<br class="calibre9" />press the protection it must have to bare the secrets of government and inform<br class="calibre9" />the people. Hugo Black.</p>
<p class="indent">Note that the <em class="calibre7">publicKeyCipher.py</em> program can only encrypt and decrypt plain (simple) text files.</p>
<p class="indent">Let’s take a closer look at the source code of the <em class="calibre7">publicKeyCipher.py</em> program.</p>
<h3 class="h1" id="calibre_link-814"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1003" class="calibre1"></span><strong class="calibre3">Setting Up the Program</strong></h3>
<p class="noindent">The public key cipher works with numbers, so we’ll convert our string message into an integer. This integer is calculated based on indexes in the symbol set, which is stored in the <span class="literal">SYMBOLS</span> variable on line 10.</p>
<p class="programs1">&nbsp;&nbsp;1. # Public Key Cipher<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import sys, math<br class="calibre9" />&nbsp;&nbsp;5.<br class="calibre9" />&nbsp;&nbsp;6. # The public and private keys for this program are created by<br class="calibre9" />&nbsp;&nbsp;7. # the makePublicPrivateKeys.py program.<br class="calibre9" />&nbsp;&nbsp;8. # This program must be run in the same folder as the key files.<br class="calibre9" />&nbsp;&nbsp;9.<br class="calibre9" />&nbsp;10. SYMBOLS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;67890 !?.'</p>
<h3 class="h1" id="calibre_link-815"><strong class="calibre3">How the Program Determines Whether to Encrypt or Decrypt</strong></h3>
<p class="noindent">The <em class="calibre7">publicKeyCipher.py</em> program determines whether to encrypt or decrypt a file, and which key file to use, by storing values in variables. While we’re looking at how these variables work, we’ll also look at how the program prints the encryption and decryption output.</p>
<p class="indent">We tell the program whether it should encrypt or decrypt inside <span class="literal">main()</span>:</p>
<p class="programs1">&nbsp;12. def main():<br class="calibre9" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Runs a test that encrypts a message to a file or decrypts a message<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# from a file.<br class="calibre9" />&nbsp;15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filename = 'encrypted_file.txt' # The file to write to/read from.<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode = 'encrypt' # Set to either 'encrypt' or 'decrypt'.</p>
<p class="indent">If <span class="literal">mode</span> on line 16 is set to <span class="literal">'encrypt'</span>, the program encrypts a message by writing it to the file specified in <span class="literal">filename</span>. If <span class="literal">mode</span> is set to <span class="literal">'decrypt'</span>, the program reads the contents of an encrypted file (specified by <span class="literal">filename</span>) to decrypt it.</p>
<p class="indent">Lines 18 to 25 specify what the program should do if it confirms that the user wants to encrypt a file.</p>
<p class="programs1">&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mode == 'encrypt':<br class="calibre9" />&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'Journalists belong in the gutter because that is where<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the ruling classes throw their guilty secrets. Gerald Priestland.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Founding Fathers gave the free press the protection it must<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;have to bare the secrets of government and inform the people.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hugo Black.'<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pubKeyFilename = 'al_sweigart_pubkey.txt'<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Encrypting and writing to %s...' % (filename))<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedText = encryptAndWriteToFile(filename, pubKeyFilename,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message)<br class="calibre9" />&nbsp;23.<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Encrypted text:')<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(encryptedText)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-114"></span>The <span class="literal">message</span> variable on line 19 contains the text to be encrypted, and <span class="literal">pubKeyFilename</span> on line 20 contains the filename of the public key file, which is <em class="calibre7">al_sweigart_pubkey.txt</em> in this example. Keep in mind that the message can only contain characters in the <span class="literal">SYMBOLS</span> variable, the symbol set for this cipher. Line 22 calls the <span class="literal">encryptAndWriteToFile()</span> function, which encrypts <span class="literal">message</span> using the public key and writes the encrypted message to the file specified by <span class="literal">filename</span>.</p>
<p class="indent">Lines 27 to 28 tell the program what to do if <span class="literal">mode</span> is set to <span class="literal">'decrypt'</span>. Instead of encrypting, the program reads from the private key file in <span class="literal">privKeyFilename</span> on line 28.</p>
<p class="programs1">&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif mode == 'decrypt':<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privKeyFilename = 'al_sweigart_privkey.txt'<br class="calibre9" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Reading from %s and decrypting...' % (filename))<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = readFromFileAndDecrypt(filename, privKeyFilename)<br class="calibre9" />&nbsp;31.<br class="calibre9" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted text:')<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(decryptedText)</p>
<p class="indent">Then we pass the <span class="literal">filename</span> and <span class="literal">privKeyFilename</span> variables to the <span class="literal">readFromFileAndDecrypt</span><span class="literal">()</span> function (defined later in the program), which returns the decrypted message. Line 30 stores the return value from <span class="literal">readFromFileAndDecrypt</span><span class="literal">()</span> in <span class="literal">decryptedText</span>, and line 33 prints it to the screen. This is the end of the <span class="literal">main()</span> function.</p>
<p class="indent">Now let’s look at how to perform the other steps of the public key cipher, such as converting the message into blocks.</p>
<h3 class="h1" id="calibre_link-816"><strong class="calibre3">Converting Strings to Blocks with getBlocksFromText()</strong></h3>
<p class="noindent">Let’s look at how the program converts a message string into 128-byte blocks. The <span class="literal">getBlocksFromText()</span> function on line 36 takes a <span class="literal">message</span> and a block size as parameters to return a list of blocks, or a list of large integer values, that represents the message.</p>
<p class="programs1">&nbsp;36. def getBlocksFromText(message, blockSize):<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts a string message to a list of block integers.<br class="calibre9" />&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for character in message:<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if character not in SYMBOLS:<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('ERROR: The symbol set does not have the character %s' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(character))<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</p>
<p class="indent">Lines 38 to 41 ensure that the message parameter contains only text characters that are in the symbol set in the <span class="literal">SYMBOLS</span> variable. The <span class="literal">blockSize</span> parameter is optional and can take any block size. To create blocks, we first convert the string to bytes.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-294"></span>To make a block, we combine all the symbol set indexes into one large integer, as we did in “<a href="#calibre_link-371" class="calibre8">Converting a String into a Block</a>” on <a href="#calibre_link-371" class="calibre8">page 350</a>. We’ll use the <span class="literal">blockInts</span> empty list on line 42 to store the blocks when we create them.</p>
<p class="programs1">&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInts = []</p>
<p class="indent">We want the blocks to be <span class="literal">blockSize</span> bytes long, but when a message isn’t evenly divisible by <span class="literal">blockSize</span>, the last block will be less than <span class="literal">blockSize</span> characters long. To handle that situation, we use the <span class="literal">min()</span> function.</p>
<h4 class="h2" id="calibre_link-817"><strong class="calibre3"><em class="calibre12">The min() and max() Functions</em></strong></h4>
<p class="noindent">The <span class="literal">min()</span> function returns the smallest value of its arguments. Enter the following into the interactive shell to see how the <span class="literal">min()</span> function works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">min(13, 32, 13, 15, 17, 39)</span><br class="calibre9" />13</p>
<p class="indent">You can also pass a single list or tuple value as an argument to <span class="literal">min()</span>. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">min([31, 26, 20, 13, 12, 36])</span><br class="calibre9" />12<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam = (10, 37, 37, 43, 3)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">min(spam)</span><br class="calibre9" />3</p>
<p class="indent">In this case, <span class="literal">min(spam)</span> returns the smallest value in the list or tuple. The opposite of <span class="literal">min()</span> is <span class="literal">max()</span>, which returns the largest value of its arguments, like this:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">max(18, 15, 22, 30, 31, 34)</span><br class="calibre9" />34</p>
<p class="indent">Let’s return to our code to see how the <em class="calibre7">publicKeyCipher.py</em> program uses <span class="literal">min()</span> to make sure the last block of <span class="literal">message</span> is truncated to the appropriate size.</p>
<h4 class="h2" id="calibre_link-818"><strong class="calibre3"><em class="calibre12">Storing Blocks in blockInt</em></strong></h4>
<p class="noindent">The code inside the <span class="literal">for</span> loop on line 43 creates the integers for each block by setting the value in <span class="literal">blockStart</span> to the index of the block being created.</p>
<p class="programs1">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for blockStart in range(0, len(message), blockSize):<br class="calibre9" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Calculate the block integer for this block of text:<br class="calibre9" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt = 0<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(blockStart, min(blockStart + blockSize,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len(message))):</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1004"></span>We’ll store the block we create in <span class="literal">blockInt</span>, which we initially set to <span class="literal">0</span> on line 45. The <span class="literal">for</span> loop on line 46 sets <span class="literal">i</span> to be the indexes of all the characters that will be in the block from <span class="literal">message</span>. The indexes should start at <span class="literal">blockStart</span> and go up to <span class="literal">blockStart + blockSize</span> <em class="calibre7">or</em> <span class="literal">len(message)</span>, whichever is smaller. The <span class="literal">min()</span> call on line 46 returns the smaller of these two expressions.</p>
<p class="indent">The second argument to <span class="literal">range()</span> on line 46 should be the smaller of <span class="literal">blockStart + blockSize</span> and <span class="literal">len(message)</span> because each block is always made up of 128 (or whatever value is in <span class="literal">blockSize</span>) characters <em class="calibre7">except</em> for the last block. The last block might be exactly 128 characters, but it’s more likely that it will be less than the full 128 characters. In that case, we want <span class="literal">i</span> to stop at <span class="literal">len(message)</span> because that is the last index in <span class="literal">message</span>.</p>
<p class="indent">After we have the characters that make up the block, we use math to turn the characters into one large integer. Recall in “<a href="#calibre_link-371" class="calibre8">Converting a String into a Block</a>” on <a href="#calibre_link-371" class="calibre8">page 350</a> that we created a large integer by multiplying the symbol set index integer value of each character by 66<sup class="calibre21"><em class="calibre7">index-of-character</em></sup> (66 is the length of the <span class="literal">SYMBOLS</span> string). To do this in code, we calculate <span class="literal">SYMBOLS.index(message[i])</span> (the symbol set index integer value of the character) multiplied by <span class="literal">(len(SYMBOLS) ** (i % blockSize))</span> for each character and add each result to <span class="literal">blockInt</span>.</p>
<p class="programs1">&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt += (SYMBOLS.index(message[i])) * (len(SYMBOLS) **<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(i % blockSize))</p>
<p class="indent">We want the exponent to be the index relative to the <em class="calibre7">current iteration’s block</em>, which is always from <span class="literal">0</span> to <span class="literal">blockSize</span>. We can’t use the variable <span class="literal">i</span> directly as the index-of-character part of the equation, because it refers to the index in the entire <span class="literal">message</span> string, which has indexes from <span class="literal">0</span> up to <span class="literal">len(message)</span>. Using <span class="literal">i</span> would result in an integer much larger than 66. By modding <span class="literal">i</span> by <span class="literal">blockSize</span>, we can get the index relative to the block, which is why line 47 is <span class="literal">len(SYMBOLS) ** (i % blockSize)</span> instead of simply <span class="literal">len(SYMBOLS) ** i</span>.</p>
<p class="indent">After the <span class="literal">for</span> loop on line 46 completes, the integer for the block has been calculated. We use the code on line 48 to append this block integer to the <span class="literal">blockInts</span> list. The next iteration of the <span class="literal">for</span> loop on line 43 calculates the block integer for the next block of the message.</p>
<p class="programs1">&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInts.append(blockInt)<br class="calibre9" />&nbsp;49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return blockInts</p>
<p class="indent">After the <span class="literal">for</span> loop on line 43 finishes, all the block integers should have been calculated and stored in the <span class="literal">blockInts</span> list. Line 49 returns <span class="literal">blockInts</span> from <span class="literal">getBlocksFromText()</span>.</p>
<p class="indent">At this point, we’ve converted the entire <span class="literal">message</span> string into block integers, but we also need a way to turn block integers back into the original plaintext message for the decryption process, which is what we’ll do next.</p>
<h3 class="h1" id="calibre_link-819"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1005" class="calibre1"></span><strong class="calibre3">Using getTextFromBlocks() to Decrypt</strong></h3>
<p class="noindent">The <span class="literal">getTextFromBlocks()</span> function on line 52 does the opposite of <span class="literal">getBlocksFromText</span><span class="literal">()</span>. This function takes a list of block integers as the <span class="literal">blockInts</span> parameter, the message’s length, and the <span class="literal">blockSize</span> to return the string value that these blocks represent. We need the length of the encoded message in <span class="literal">messageLength</span>, because the <span class="literal">getTextFromBlocks()</span> function uses this information to get the string from the last block integer when it’s not <span class="literal">blockSize</span> characters in size. This process was described in “<a href="#calibre_link-372" class="calibre8">Converting a Block to a String</a>” on <a href="#calibre_link-372" class="calibre8">page 354</a>.</p>
<p class="programs1">&nbsp;52. def getTextFromBlocks(blockInts, messageLength, blockSize):<br class="calibre9" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts a list of block integers to the original message string.<br class="calibre9" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The original message length is needed to properly convert the last<br class="calibre9" />&nbsp;55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# block integer.<br class="calibre9" />&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = []</p>
<p class="indent">The <span class="literal">message</span> list, which is created as a blank list on line 56, stores a string value for each character, which we’ll compute from the block integers in <span class="literal">blockInts</span>.</p>
<p class="indent">The <span class="literal">for</span> loop on line 57 iterates over each block integer in the <span class="literal">blockInts</span> list. Inside the <span class="literal">for</span> loop, the code on lines 58 to 65 calculates the letters that are in the current iteration’s block.</p>
<p class="programs1">&nbsp;57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for blockInt in blockInts:<br class="calibre9" />&nbsp;58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMessage = []<br class="calibre9" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(blockSize - 1, -1, -1):</p>
<p class="indent">The code in <span class="literal">getTextFromBlocks()</span> splits each block integer into <span class="literal">blockSize</span> integers, where each represents the symbol set index for a character. We must work backward to extract the symbol set indexes from <span class="literal">blockInt</span> because when we encrypted the message, we started with the smaller exponents (66<sup class="calibre21">0</sup>, 66<sup class="calibre21">1</sup>, 66<sup class="calibre21">2</sup>, and so on), but when decrypting, we must divide and mod using the larger exponents first. This is why the <span class="literal">for</span> loop on line 59 starts at <span class="literal">blockSize - 1</span> and then subtracts <span class="literal">1</span> on each iteration down to, but not including, <span class="literal">-1</span>. This means the value of <span class="literal">i</span> on the last iteration is <span class="literal">0</span>.</p>
<p class="indent">Before we convert the symbol set index to a character, we need to make sure we aren’t decoding blocks past the length of the <span class="literal">message</span>. To do this, we check that the number of characters that have been translated from blocks so far, <span class="literal">len(message) + i</span>, is still less than <span class="literal">messageLength</span> on line 60.</p>
<p class="programs1">&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(message) + i &lt; messageLength:<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decode the message string for the 128 (or whatever<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# blockSize is set to) characters from this block integer.<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;charIndex = blockInt // (len(SYMBOLS) ** i)<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockInt = blockInt % (len(SYMBOLS) ** i)</p>
<p class="indent">To get the characters from the block, we follow the process described in “<a href="#calibre_link-372" class="calibre8">Converting a Block to a String</a>” on <a href="#calibre_link-372" class="calibre8">page 354</a>. We put each character into <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-211"></span>the <span class="literal">message</span> list. Encoding each block actually reverses the characters, which you saw earlier, so we can’t just append the decoded character to <span class="literal">message</span>. Instead, we insert the character at the front of <span class="literal">message</span>, which we’ll need to do with the <span class="literal">insert()</span> list method.</p>
<h4 class="h2" id="calibre_link-820"><strong class="calibre3"><em class="calibre12">Using the insert() List Method</em></strong></h4>
<p class="noindent">The <span class="literal">append()</span> list method only adds values to the end of a list, but the <span class="literal">insert()</span> list method can add a value <em class="calibre7">anywhere</em> in the list. The <span class="literal">insert()</span> method takes an integer index of where in the list to insert the value and the value to be inserted as its arguments. Enter the following into the interactive shell to see how the <span class="literal">insert()</span> method works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = [2, 4, 6, 8]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.insert(0, 'hello')</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['hello', 2, 4, 6, 8]<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.insert(2, 'world')</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['hello', 2, 'world', 4, 6, 8]</p>
<p class="indent">In this example, we create a <span class="literal">spam</span> list and then insert the string <span class="literal">'hello'</span> at the <span class="literal">0</span> index. As you can see, we can insert values at any existing index in the list, such as at index <span class="literal">2</span>.</p>
<h4 class="h2" id="calibre_link-821"><strong class="calibre3"><em class="calibre12">Merging the Message List into One String</em></strong></h4>
<p class="noindent">We can use the <span class="literal">SYMBOLS</span> string to convert the symbol set index in <span class="literal">charIndex</span> to its corresponding character and insert that character at the beginning of the list at index <span class="literal">0</span>.</p>
<p class="programs1">&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockMessage.insert(0, SYMBOLS[charIndex])<br class="calibre9" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.extend(blockMessage)<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(message)</p>
<p class="indent">This string is then returned from <span class="literal">getTextFromBlocks()</span>.</p>
<h3 class="h1" id="calibre_link-822"><strong class="calibre3">Writing the encryptMessage() Function</strong></h3>
<p class="noindent">The <span class="literal">encryptMessage()</span> function encrypts each block using the plaintext string in <span class="literal">message</span> along with the two-integer tuple of the public key stored in <span class="literal">key</span>, which is created with the <span class="literal">readKeyFile()</span> function we’ll write later in this chapter. The <span class="literal">encryptMessage()</span> function returns a list of encrypted blocks.</p>
<p class="programs1">&nbsp;70. def encryptMessage(message, key, blockSize):<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Converts the message string into a list of block integers, and then<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# encrypts each block integer. Pass the PUBLIC key to encrypt.<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = []<br class="calibre9" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, e = key</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-191"></span>Line 73 creates the <span class="literal">encryptedBlocks</span> variable, which starts as an empty list that will hold the integer blocks. Then line 74 assigns the two integers in <span class="literal">key</span> to the variables <span class="literal">n</span> and <span class="literal">e</span>. Now that we have the public key variables set up, we can perform math on each message block to encrypt.</p>
<p class="indent">To encrypt each block, we perform some math operations on it that result in a new integer, which is the encrypted block. We raise the block to the <span class="literal">e</span> power and then mod it by <span class="literal">n</span> using <span class="literal">pow(block, e, n)</span> on line 78.</p>
<p class="programs1">&nbsp;76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in getBlocksFromText(message, blockSize):<br class="calibre9" />&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# ciphertext = plaintext ^ e mod n<br class="calibre9" />&nbsp;78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks.append(pow(block, e, n))<br class="calibre9" />&nbsp;79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return encryptedBlocks</p>
<p class="indent">The encrypted block integer is then appended to <span class="literal">encryptedBlocks</span>.</p>
<h3 class="h1" id="calibre_link-823"><strong class="calibre3">Writing the decryptMessage() Function</strong></h3>
<p class="noindent">The <span class="literal">decryptMessage()</span> function on line 82 decrypts the blocks and returns the decrypted message string. It takes the list of encrypted blocks, the message length, the private key, and the block size as parameters.</p>
<p class="indent">The <span class="literal">decryptedBlocks</span> variable we set up on line 86 stores a list of the decrypted blocks, and using the multiple assignment trick, the two integers of the <span class="literal">key</span> tuple are placed in <span class="literal">n</span> and <span class="literal">d</span>, respectively.</p>
<p class="programs1">&nbsp;82. def decryptMessage(encryptedBlocks, messageLength, key, blockSize):<br class="calibre9" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypts a list of encrypted block ints into the original message<br class="calibre9" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# string. The original message length is required to properly decrypt<br class="calibre9" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the last block. Be sure to pass the PRIVATE key to decrypt.<br class="calibre9" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedBlocks = []<br class="calibre9" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, d = key</p>
<p class="indent">The math for decryption is the same as the encryption’s math except the integer block is being raised to <span class="literal">d</span> instead of <span class="literal">e</span>, as you can see on line 90.</p>
<p class="programs1">&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in encryptedBlocks:<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# plaintext = ciphertext ^ d mod n<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedBlocks.append(pow(block, d, n))</p>
<p class="indent">The decrypted blocks along with the <span class="literal">messageLength</span> and <span class="literal">blockSize</span> parameters are passed to <span class="literal">getTextFromBlocks()</span> so that <span class="literal">decryptMessage()</span> returns the decrypted plaintext as a string on line 91.</p>
<p class="programs1">&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getTextFromBlocks(decryptedBlocks, messageLength, blockSize)</p>
<p class="indent">Now that you’ve learned about the math that makes encryption and decryption possible, let’s look at how the <span class="literal">readKeyFile()</span> function reads in the public and private key files to create tuple values that we passed to <span class="literal">encryptMessage</span><span class="literal">()</span> and <span class="literal">decryptMessage()</span>.</p>
<h3 class="h1" id="calibre_link-824"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1006" class="calibre1"></span><strong class="calibre3">Reading in the Public and Private Keys from Their Key Files</strong></h3>
<p class="noindent">The <span class="literal">readKeyFile()</span> function is called to read values from key files created with the <em class="calibre7">makePublicPrivateKeys.py</em> program, which we created in <a href="#calibre_link-53" class="calibre8">Chapter 23</a>. The filename to open is passed to <span class="literal">keyFilename</span>, and the file must be in the same folder as the <em class="calibre7">publicKeyCipher.py</em> program.</p>
<p class="indent">Lines 97 to 99 open this file and read in the contents as a string into the <span class="literal">content</span> variable.</p>
<p class="programs1">&nbsp;94. def readKeyFile(keyFilename):<br class="calibre9" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given the filename of a file that contains a public or private key,<br class="calibre9" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# return the key as a (n,e) or (n,d) tuple value.<br class="calibre9" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(keyFilename)<br class="calibre9" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content = fo.read()<br class="calibre9" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, EorD = content.split(',')<br class="calibre9" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (int(keySize), int(n), int(EorD))</p>
<p class="indent">The key file stores the key size in bytes as <em class="calibre7">n</em>, and either <em class="calibre7">e</em> or <em class="calibre7">d</em>, depending on whether the key file is for an encryption key or decryption key. As you learned in the previous chapter, these values were stored as text and separated by commas, so we use the <span class="literal">split()</span> string method to split the string in <span class="literal">content</span> at the commas. The list that <span class="literal">split()</span> returns has three items in it, and the multiple assignment on line 100 places each of these items into the <span class="literal">keySize</span>, <span class="literal">n</span>, and <span class="literal">EorD</span> variables, respectively.</p>
<p class="indent">Recall that <span class="literal">content</span> was a string when it was read from the file, and the items in the list that <span class="literal">split()</span> returns will also be string values. To change these string values into integers, we pass the <span class="literal">keySize</span>, <span class="literal">n</span>, and <span class="literal">EorD</span> values to <span class="literal">int()</span>. The <span class="literal">readKeyFile()</span> function then returns three integers, <span class="literal">int(keySize)</span>, <span class="literal">int(n)</span>, and <span class="literal">int(EorD)</span>, which you’ll use for encryption or decryption.</p>
<h3 class="h1" id="calibre_link-825"><strong class="calibre3">Writing the Encryption to a File</strong></h3>
<p class="noindent">On line 104, the <span class="literal">encryptAndWriteToFile()</span> function calls <span class="literal">encryptMessage()</span> to encrypt the string with the key and creates the file that contains the encrypted contents.</p>
<p class="programs1">104. def encryptAndWriteToFile(messageFilename, keyFilename, message,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize=None):<br class="calibre9" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Using a key from a key file, encrypt the message and save it to a<br class="calibre9" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# file. Returns the encrypted message string.<br class="calibre9" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, e = readKeyFile(keyFilename)</p>
<p class="indent">The <span class="literal">encryptAndWriteToFile()</span> function takes three string arguments: a filename to write the encrypted message in (<span class="literal">messageFilename</span>), a filename of the public key to use (<span class="literal">keyFilename</span>), and a message to be encrypted (<span class="literal">message</span>). The <span class="literal">blockSize</span> parameter is specified as the fourth argument.</p>
<p class="indent">The first step of the encryption process is to read in the values for <span class="literal">keySize</span>, <span class="literal">n</span>, and <span class="literal">e</span> from the key file by calling <span class="literal">readKeyFile()</span> on line 107.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1007"></span>The <span class="literal">blockSize</span> parameter has a default argument of <span class="literal">None</span>:</p>
<p class="programs1">108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if blockSize == None:<br class="calibre9" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If blockSize isn't given, set it to the largest size allowed by<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the key size and symbol set size.<br class="calibre9" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize = int(math.log(2 ** keySize, len(SYMBOLS)))</p>
<p class="indent">If no argument is passed for the <span class="literal">blockSize</span> parameter, the <span class="literal">blockSize</span> will be set to the largest size that the symbol set and key size will allow. Keep in mind that the equation 2<sup class="calibre21"><em class="calibre7">key size</em></sup> &gt; <em class="calibre7">symbol set size</em> <sup class="calibre21"><em class="calibre7">block size</em></sup> must be true. To calculate the largest possible block size, Python’s <span class="literal">math.log()</span> function is called to calculate the logarithm of 2<sup class="calibre21"><em class="calibre7">key size</em></sup> with a base of <span class="literal">len(SYMBOLS)</span> on line 110.</p>
<p class="indent">The mathematics of the public key cipher work correctly only if the key size is equal to or greater than the block size, so it’s essential that we check this on line 112 before proceeding.</p>
<p class="programs1">111.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check that key size is large enough for the block size:<br class="calibre9" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not (math.log(2 ** keySize, len(SYMBOLS)) &gt;= blockSize):<br class="calibre9" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('ERROR: Block size is too large for the key and symbol<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set size. Did you specify the correct key file and encrypted<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file?')</p>
<p class="indent">If <span class="literal">keySize</span> is too small, the program exits with an error message. The user must either decrease the value passed for <span class="literal">blockSize</span> or use a larger key.</p>
<p class="indent">Now that we have the <span class="literal">n</span> and <span class="literal">e</span> values for the key, we call the function <span class="literal">encryptMessage()</span> on line 115, which returns a list of integer blocks.</p>
<p class="programs1">114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Encrypt the message<br class="calibre9" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = encryptMessage(message, (n, e), blockSize)</p>
<p class="indent">The <span class="literal">encryptMessage()</span> function expects a two-integer tuple for the key, which is why the <span class="literal">n</span> and <span class="literal">e</span> variables are placed inside a tuple that is then passed as the second argument for <span class="literal">encryptMessage()</span>.</p>
<p class="indent">Next, we convert the encrypted blocks into a string that we can write to a file. We do this by joining the blocks into a string with each block separated with a comma. Using <span class="literal">','.join(encryptedBlocks)</span> to do this won’t work because <span class="literal">join()</span> only works on lists with string values. Because <span class="literal">encryptedBlocks</span> is a list of integers, we have to first convert these integers to strings:</p>
<p class="programs1">117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the large int values to one string value:<br class="calibre9" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(encryptedBlocks)):<br class="calibre9" />119.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks[i] = str(encryptedBlocks[i])<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent = ','.join(encryptedBlocks)</p>
<p class="indent">The <span class="literal">for</span> loop on line 118 iterates through each index in <span class="literal">encryptedBlocks</span>, replacing the integer at <span class="literal">encryptedBlocks[i]</span> with a string form of the integer. When the loop completes, <span class="literal">encryptedBlocks</span> should contain a list of string values instead of a list of integer values.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1008"></span>Then we can pass the list of string values in <span class="literal">encryptedBlocks</span> to the <span class="literal">join()</span> method, which returns the list’s strings joined together into a single string with each block separated by commas. Line 120 stores this combined string in the <span class="literal">encryptedContent</span> variable.</p>
<p class="indent">We also write the length of the message and the block size to the file in addition to the encrypted integer blocks:</p>
<p class="programs1">122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Write out the encrypted string to the output file:<br class="calibre9" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent = '%s_%s_%s' % (len(message), blockSize,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedContent)</p>
<p class="indent">Line 123 changes the <span class="literal">encryptedContent</span> variable to include the size of the message as an integer, <span class="literal">len(message)</span>, followed by an underscore, the <span class="literal">blockSize</span>, another underscore, and finally, the encrypted integer blocks (<span class="literal">encryptedContent</span>).</p>
<p class="indent">The last step of the encryption process is to write the contents to the file. The filename provided by the <span class="literal">messageFilename</span> parameter is created with the call to <span class="literal">open()</span> on line 124. Note that if a file with this name already exists, the new file will overwrite it.</p>
<p class="programs1">124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(messageFilename, 'w')<br class="calibre9" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write(encryptedContent)<br class="calibre9" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Also return the encrypted string:<br class="calibre9" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return encryptedContent</p>
<p class="indent">The string in <span class="literal">encryptedContent</span> is written to the file by calling the <span class="literal">write()</span> method on line 125. After the program is done writing the file’s contents, line 126 closes the file object in <span class="literal">fo</span>.</p>
<p class="indent">Finally, the string in <span class="literal">encryptedContent</span> is returned from the function <span class="literal">encryptAndWriteToFile</span><span class="literal">()</span> on line 128. (This is so the code that calls the function can use this string to, for example, print it onscreen.)</p>
<p class="indent">Now you know how the <span class="literal">encryptAndWriteToFile()</span> function encrypts a message string and writes the results to a file. Let’s look at how the program uses the <span class="literal">readFromFileAndDecrypt()</span> function to decrypt an encrypted message.</p>
<h3 class="h1" id="calibre_link-826"><strong class="calibre3">Decrypting from a File</strong></h3>
<p class="noindent">Similar to <span class="literal">encryptAndWriteToFile()</span>, the <span class="literal">readFromFileAndDecrypt()</span> function has parameters for the encrypted message file’s filename and the key file’s filename. Be sure to pass the filename of the private key for <span class="literal">keyFilename</span>, not the public key.</p>
<p class="programs1">131. def readFromFileAndDecrypt(messageFilename, keyFilename):<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Using a key from a key file, read an encrypted message from a file<br class="calibre9" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and then decrypt it. Returns the decrypted message string.<br class="calibre9" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keySize, n, d = readKeyFile(keyFilename)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1009"></span>The first step is the same as <span class="literal">encryptAndWriteToFile()</span>: the <span class="literal">readKeyFile()</span> function is called to get the values for the <span class="literal">keySize</span>, <span class="literal">n</span>, and <span class="literal">d</span> variables.</p>
<p class="indent">The second step is to read in the contents of the file. Line 138 opens the <span class="literal">messageFilename</span> file for reading.</p>
<p class="programs1">137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Read in the message length and the encrypted message from the file:<br class="calibre9" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open(messageFilename)<br class="calibre9" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;content = fo.read()<br class="calibre9" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageLength, blockSize, encryptedMessage = content.split('_')<br class="calibre9" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;messageLength = int(messageLength)<br class="calibre9" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize = int(blockSize)</p>
<p class="indent">The <span class="literal">read()</span> method call on line 139 returns a string of the full contents of the file, which is what you would see if you opened the text file in a program like Notepad or TextEdit, copied the entire contents, and pasted it as a string value into your program.</p>
<p class="indent">Recall that the encrypted file’s format has three integers separated by underscores: an integer representing the message length, an integer for the block size used, and the encrypted integer blocks. Line 140 calls the <span class="literal">split()</span> method to return a list of these three values, and the multiple assignment trick places the three values into the <span class="literal">messageLength</span>, <span class="literal">blockSize</span>, and <span class="literal">encryptedMessage</span> variables, respectively.</p>
<p class="indent">Because the values returned by <span class="literal">split()</span> are strings, lines 141 and 142 use <span class="literal">int()</span> to change <span class="literal">messageLength</span> and <span class="literal">blockSize</span> to their integer form, respectively.</p>
<p class="indent">The <span class="literal">readFromFileAndDecrypt()</span> function also checks, on line 145, that the block size is equal to or less than the key size.</p>
<p class="programs1">144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check that key size is large enough for the block size:<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not (math.log(2 ** keySize, len(SYMBOLS)) &gt;= blockSize):<br class="calibre9" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('ERROR: Block size is too large for the key and symbol<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set size. Did you specify the correct key file and encrypted<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file?')</p>
<p class="indent">This check should always pass, because if the block size was too large, it would have been impossible to create the encrypted file in the first place. Most likely the wrong private key file was specified for the <span class="literal">keyFilename</span> parameter, which means that the key would not have decrypted the file correctly anyway.</p>
<p class="indent">The <span class="literal">encryptedMessage</span> string contains many blocks joined together with commas, which we convert back to integers and store in the variable <span class="literal">encryptedBlocks</span>.</p>
<p class="programs1">148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Convert the encrypted message into large int values:<br class="calibre9" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks = []<br class="calibre9" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block in encryptedMessage.split(','):<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryptedBlocks.append(int(block))</p>
<p class="indent">The <span class="literal">for</span> loop on line 150 iterates over the list created from calling the <span class="literal">split()</span> method on <span class="literal">encryptedMessage</span>. This list contains strings of individual <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-279"></span>blocks. The integer form of these strings is appended to the <span class="literal">encryptedBlocks</span> list (which was an empty list on line 149) each time line 151 is executed. After the <span class="literal">for</span> loop on line 150 completes, the <span class="literal">encryptedBlocks</span> list should contain integer values of the numbers that were in the <span class="literal">encryptedMessage</span> string.</p>
<p class="indent">On line 154, the list in <span class="literal">encryptedBlocks</span> is passed to the <span class="literal">decryptMessage()</span> function along with <span class="literal">messageLength</span>, the private key (a tuple value of two integers <span class="literal">n</span> and <span class="literal">d</span>), and the block size.</p>
<p class="programs1">153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Decrypt the large int values:<br class="calibre9" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptMessage(encryptedBlocks, messageLength, (n, d),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blockSize)</p>
<p class="indent">The <span class="literal">decryptMessage()</span> function on line 154 returns a single string value of the decrypted message, which itself is a value returned from <span class="literal">readFileAndDecrypt()</span>.</p>
<h3 class="h1" id="calibre_link-827"><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">Finally, lines 159 and 160 call the <span class="literal">main()</span> function if <em class="calibre7">publicKeyCipher.py</em> is being run as a program instead of being imported as a module by another program.</p>
<p class="programs1">157. # If publicKeyCipher.py is run (instead of imported as a module), call<br class="calibre9" />158. # the main() function.<br class="calibre9" />159. if __name__ == '__main__':<br class="calibre9" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">That completes our discussion of how the <em class="calibre7">publicKeyCipher.py</em> program performs encryption and decryption using the public key cipher.</p>
<h3 class="h1" id="calibre_link-828"><strong class="calibre3">Summary</strong></h3>
<p class="noindent">Congratulations, you’re done with the book! There’s no “Hacking the Public Key Cipher” chapter because there’s no simple attack against the public key cipher that wouldn’t take trillions of years.</p>
<p class="indent">In this chapter, the RSA algorithm was greatly simplified, but it’s still a real cipher used in professional encryption software. When you log into a website or buy something on the internet, for example, ciphers like this keep passwords and credit card numbers secret from anyone who might be intercepting your network traffic.</p>
<p class="indent">Although the basic mathematics used for professional encryption software is the same as that described in this chapter, you shouldn’t use this program to secure your secret files. The hacks against an encryption program like <em class="calibre7">publicKeyCipher.py</em> are very sophisticated, but they do exist. (For example, because the random numbers <span class="literal">random.randint()</span> created aren’t truly random and can be predicted, a hacker could figure out which numbers were used for the prime numbers of your private key.)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-1010"></span>All the previous ciphers discussed in this book can be hacked and rendered worthless. In general, avoid writing your own cryptography code to secure your secrets, because you’ll probably make subtle mistakes in the implementation of these programs. Hackers and spy agencies can exploit these mistakes to hack your encrypted messages.</p>
<p class="indent">A cipher is secure only if everything but the key can be revealed while still keeping the message a secret. You cannot rely on a cryptanalyst’s not having access to the same encryption software or not knowing which cipher you used. Always assume that the enemy knows the system!</p>
<p class="indent">Professional encryption software is written by cryptographers who have spent years studying the mathematics and potential weaknesses of various ciphers. Even then, the software they write is inspected by other cryptographers to check for mistakes or potential weaknesses. You’re perfectly capable of learning about these cipher systems and cryptographic mathematics. It’s not about being the smartest hacker, but spending the time to study to become the most knowledgeable hacker.</p>
<p class="indent">I hope this book gave you the foundations you need to become an elite hacker and programmer. There’s a lot more to programming and cryptography than what this book covers, so I encourage you explore and learn more! I highly recommend <em class="calibre7">The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography</em> by Simon Singh, which is a great book about the general history of cryptography. You can go to <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em> for a list of other books and websites to learn more about cryptography. Feel free to email me your programming or cryptography questions at <em class="calibre7"><a href="mailto:al@inventwithpython.com" class="calibre8">al@inventwithpython.com</a></em> or post them on <em class="calibre7"><a href="https://reddit.com/r/inventwithpython/" class="calibre8">https://reddit.com/r/inventwithpython/</a></em>.</p>
<p class="indent">Good luck!</p>
</div>



<a href="chapter23.html">Prev: Chapter 23 - Generating Keys for the Public Key Cipher</a> | <a href="appendixa.html">Next: Debugging Python Code</a>
</body></html>