<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 19 - Frequency Analysis</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter18.html">Prev: Chapter 18 - Programming the Vigenere Cipher</a> | <a href="chapter20.html">Next: Chapter 20 - Hacking the Vigenere Cipher</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter18.html">Previous Chapter - Programming the Vigenère Cipher</a> | <a href="chapter20.html">Next Chapter - Hacking the Vigenère Cipher</a></div>
<div id="calibre_link-336" class="calibre">
<h2 class="h2a1" id="calibre_link-42"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-244" class="calibre1"></span><span class="big">19</span><br class="calibre15" />FREQUENCY ANALYSIS</h2>
<p class="epigraph"><em class="calibre7">“The ineffable talent for finding patterns in chaos cannot do its thing unless he immerses himself in the chaos first. If they do contain patterns, he does not see them just now, in any rational way. But there may be some subrational part of his mind that can go to work . . .”<br class="calibre9" />&mdash;Neal Stephenson,</em> Cryptonomicon</p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In this chapter, you’ll learn how to determine the frequency of each English letter in a particular text. You’ll then compare these frequencies to the letter frequencies of your ciphertext to get information about the original plaintext, which will help you break the encryption. This process of determining how frequently a letter appears in plaintexts and in ciphertexts is called <em class="calibre7">frequency analysis</em>. Understanding frequency analysis is an important step in hacking the Vigenère cipher. We’ll use letter frequency analysis to break the Vigenère cipher in <a href="#calibre_link-64" class="calibre8">Chapter 20</a>.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-224"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">Letter frequency and ETAOIN</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">sort()</span> method’s <span class="literal">key</span> and <span class="literal">reverse</span> keyword arguments</p></li>
<li class="calibre11"><p class="noindent">Passing functions as values instead of calling functions</p></li>
<li class="calibre11"><p class="noindent">Converting dictionaries to lists using the <span class="literal">keys()</span>, <span class="literal">values()</span>, and <span class="literal">items()</span> methods</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-722"><strong class="calibre3">Analyzing the Frequency of Letters in Text</strong></h3>
<p class="noindent">When you flip a coin, about half the time it comes up heads and half the time it comes up tails. That is, the <em class="calibre7">frequency</em> of heads and tails should be about the same. We can represent the frequency as a percentage by dividing the total number of times an event occurs (how many times we flip a heads, for example) by the total number of attempts at an event (which is the total number of times we flipped the coin) and multiplying the quotient by 100. We can learn much about a coin from its frequency of heads or tails: whether the coin is fair or unfairly weighted or even if it’s a two-headed coin.</p>
<p class="indent">We can also learn much about a ciphertext from the frequency of its letters. Some letters in the English alphabet are used more often than others. For example, the letters E, T, A, and O appear most frequently in English words, whereas the letters J, X, Q, and Z appear less frequently in English. We’ll use this difference in letter frequencies in the English language to crack Vigenère-encrypted messages.</p>
<p class="indent"><a href="#calibre_link-337" class="calibre8">Figure 19-1</a> shows the letter frequencies found in standard English. The graph was compiled using text from books, newspapers, and other sources.</p>
<p class="indent">When we sort these letter frequencies in order of greatest frequency to least, E is the most frequent letter, followed by T, then A, and so on, as shown in <a href="#calibre_link-338" class="calibre8">Figure 19-2</a>.</p>
<p class="indent">The six most frequently occurring letters in English are ETAOIN. The full list of letters ordered by frequency is ETAOINSHRDLCUMWFGYPBVKJXQZ.</p>
<p class="indent">Recall that the transposition cipher encrypts messages by arranging the letters of the original English plaintext in a different order. This means that the letter frequencies in the ciphertext are no different from those in the original plaintext. For example, E, T, and A should appear more often than Q and Z in a transposition ciphertext.</p>
<p class="indent">Likewise, the letters that appear most often in a Caesar ciphertext and a simple substitution ciphertext are more likely to have been encrypted from the most commonly found English letters, such as E, T, or A. Similarly, the letters that appear least often in the ciphertext are more likely to have been encrypted from to X, Q, and Z in plaintext.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-243"></span><img src="images/00026.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-337" class="calibre8"></a><em class="calibre7">Figure 19-1: Frequency analysis of each letter in typical English text</em></p>
<div class="image"><img src="images/00027.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-338" class="calibre8"></a><em class="calibre7">Figure 19-2: Most frequent and least frequent letters in typical English text</em></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-247"></span>Frequency analysis is very useful when hacking the Vigenère cipher because it lets us brute-force each subkey one at a time. For example, if a message was encrypted with the key PIZZA, we would need to brute-force 26<sup class="calibre21">5</sup> or 11,881,376 keys to find the entire key at once. To brute-force only one of the five subkeys, however, we only need to try 26 possibilities. Doing this for each of the five subkeys means we only need to brute-force 26 × 5 or 130 subkeys.</p>
<p class="indent">Using the key PIZZA, every fifth letter in the message starting with the first letter would be encrypted with P, every fifth letter starting with the second letter with I, and so on. We can brute-force for the first subkey by decrypting every fifth letter in the ciphertext with all 26 possible subkeys. For the first subkey, we would find that P produced decrypted letters that matched the letter frequency of English more than the other 25 possible subkeys. This would be a strong indicator that P was the first subkey. We could then repeat this for the other subkeys until we had the entire key.</p>
<h3 class="h1" id="calibre_link-723">Matching Letter Frequencies</h3>
<p class="noindent">To find the letter frequencies in a message, we’ll use an algorithm that simply orders the letters in a string by highest frequency to lowest frequency. Then the algorithm uses this ordered string to calculate what this book calls a <em class="calibre7">frequency match score</em>, which we’ll use to determine how similar a string’s letter frequency is to that of standard English.</p>
<p class="indent">To calculate the frequency match score for a ciphertext, we start with 0 and then add a point each time one of the most frequent English letters (E, T, A, O, I, N) appears among the six most frequent letters of the ciphertext. We’ll also add a point to the score each time one of the least frequent letters (V, K, J, X, Q, or Z) appears among the six least frequent letters of the ciphertext.</p>
<p class="indent">The frequency match score for a string can range from 0 (the string’s letter frequency is completely unlike the English letter frequency) to 12 (the string’s letter frequency is identical to that of regular English). Knowing the frequency match score of a ciphertext can reveal important information about the original plaintext.</p>
<h4 class="h2" id="calibre_link-724"><strong class="calibre3"><em class="calibre12">Calculating the Frequency Match Score for the Simple Substitution Cipher</em></strong></h4>
<p class="noindent">We’ll use the following ciphertext to calculate the frequency match score of a message encrypted using the simple substitution cipher:</p>
<p class="programs1">Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm<br class="calibre9" />rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra<br class="calibre9" />jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor<br class="calibre9" />l calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax<br class="calibre9" />px jia rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh.<br class="calibre9" />-Facjclxo Ctrramm</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-963"></span>When we count the frequency of each letter in this ciphertext and sort from highest to lowest frequency, the result is ASRXJILPWMCYOUEQNTHBFZGKVD. A is the most frequent letter, S is the second most frequent letter, and so on to the letter D, which appears least frequently.</p>
<p class="indent">Of the six most frequent letters in this example (A, S, R, X, J, and I), two of these letters (A and I) are also among the six most frequently appearing letters in the English language, which are E, T, A, O, I, and N. So we add two points to the frequency match score.</p>
<p class="indent">The six least frequent letters in the ciphertext are F, Z, G, K, V, and D. Three of these letters (Z, K, and V) appear in the set of least frequently occurring letters, which are V, K, J, X, Q, and Z. So we add three more points to the score. Based on the frequency ordering derived from this ciphertext, ASRXJILPWMCYOUEQNTHBFZGKVD, the frequency match score is 5, as shown in <a href="#calibre_link-339" class="calibre8">Figure 19-3</a>.</p>
<div class="image"><img src="images/00029.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-339" class="calibre8"></a><em class="calibre7">Figure 19-3: Calculating the frequency match score of the simple substitution cipher</em></p>
<p class="indent"><em class="calibre7">The ciphertext encrypted using a simple substitution cipher won’t have a very high frequency match score.</em> The letter frequencies of a simple substitution ciphertext don’t match those of regular English because the plaintext letters are substituted one for one with cipherletters. For example, if the letter T is encrypted to the letter J, then J would be more likely to appear frequently in the ciphertext, even though it’s one of the least frequently appearing letters in English.</p>
<h4 class="h2" id="calibre_link-725"><strong class="calibre3"><em class="calibre12">Calculating the Frequency Match Score for the Transposition Cipher</em></strong></h4>
<p class="noindent">This time let’s calculate the frequency match score for a ciphertext encrypted using the transposition cipher:</p>
<p class="programs1">"I rc ascwuiluhnviwuetnh,osgaa ice tipeeeee slnatsfietgi tittynecenisl. e<br class="calibre9" />fo f fnc isltn sn o a yrs sd onisli ,l erglei trhfmwfrogotn,l&nbsp;&nbsp;stcofiit.<br class="calibre9" />aea&nbsp;&nbsp;wesn,lnc ee w,l eIh eeehoer ros&nbsp;&nbsp;iol er snh nl oahsts&nbsp;&nbsp;ilasvih&nbsp;&nbsp;tvfeh<br class="calibre9" />rtira id thatnie.im ei-dlmf i&nbsp;&nbsp;thszonsisehroe, aiehcdsanahiec&nbsp;&nbsp;gv gyedsB<br class="calibre9" />affcahiecesd d lee&nbsp;&nbsp;&nbsp;onsdihsoc nin cethiTitx&nbsp;&nbsp;eRneahgin r e teom fbiotd&nbsp;&nbsp;n<br class="calibre9" />ntacscwevhtdhnhpiwru"</p>
<p class="indent">The most frequent to least frequent letters in this ciphertext are EISNTHAOCLRFDGWVMUYBPZXQJK. E is the most frequent letter, I is the second most frequent letter, and so on.</p>
<p class="indent">The four most frequently appearing letters in this ciphertext (E, I, N, and T) also happen to be among the most frequent letters in standard <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-248"></span>English (ETAOIN). Similarly, the five least frequent letters in the ciphertext (Z, X, Q, J, and K) also appear in VKJXQZ, resulting in a total frequency match score of 9, as shown in <a href="#calibre_link-340" class="calibre8">Figure 19-4</a>.</p>
<div class="image"><img src="images/00030.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-340" class="calibre8"></a><em class="calibre7">Figure 19-4: Calculating the frequency match score of the transposition cipher</em></p>
<p class="indent"><em class="calibre7">The ciphertext encrypted using a transposition cipher should have a much higher frequency match score than a simple substitution ciphertext.</em> The reason is that unlike the simple substitution cipher, the transposition cipher uses the same letters found in the original plaintext but arranged in a different order. Therefore, the frequency of each letter remains the same.</p>
<h4 class="h2" id="calibre_link-726"><strong class="calibre3"><em class="calibre12">Using Frequency Analysis on the Vigenère Cipher</em></strong></h4>
<p class="noindent">To hack the Vigenère cipher, we need to decrypt the subkeys individually. That means we can’t rely on using English word detection, because we won’t be able to decrypt enough of the message using just one subkey.</p>
<p class="indent">Instead, we’ll decrypt the letters encrypted with one subkey and perform frequency analysis to determine which decrypted ciphertext produces a letter frequency that most closely matches that of regular English. In other words, we need to find which decryption has the highest frequency match score, which is a good indication that we’ve found the correct subkey.</p>
<p class="indent">We repeat this process for the second, third, fourth, and fifth subkey as well. For now, we’re just guessing that the key length is five letters. (In <a href="#calibre_link-64" class="calibre8">Chapter 20</a>, you’ll learn how to use Kasiski examination to determine the key length.) Because there are 26 decryptions for each subkey (the total number of letters in the alphabet) in the Vigenère cipher, the computer only has to perform 26 + 26 + 26 + 26 + 26, or 156, decryptions for a five-letter key. This is much easier than performing decryptions for every possible subkey combination, which would total 11,881,376 decryptions (26 × 26 × 26 × 26 × 26)!</p>
<p class="indentb">There are more steps to hack the Vigenère cipher, which you’ll learn in <a href="#calibre_link-64" class="calibre8">Chapter 20</a> when we write the hacking program. For now, let’s write a module that performs frequency analysis using the following helpful functions:</p>
<p class="list-plain"><span class="codestrong">getLetterCount()</span> Takes a string parameter and returns a dictionary that has the count of how often each letter appears in the string</p>
<p class="list-plain"><span class="codestrong">getFrequencyOrder()</span> Takes a string parameter and returns a string of the 26 letters ordered from most frequent to least frequent in the string parameter</p>
<p class="list-plain"><span class="codestrong">englishFreqMatchScore()</span> Takes a string parameter and returns an integer from 0 to 12, indicating a letter’s frequency match score</p>
<h3 class="h1" id="calibre_link-727"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-241" class="calibre1"></span>Source Code for Matching Letter Frequencies</h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor, save it as <em class="calibre7">freqAnalysis.py</em>, and make sure <em class="calibre7">pyperclip.py</em> is in the same directory. Press F5 to run the program.</p>
<p class="noindentz"><em class="calibre7">freqAnalysis.py</em></p>
<p class="programs1">&nbsp;&nbsp;1. # Frequency Finder<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'<br class="calibre9" />&nbsp;&nbsp;5. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br class="calibre9" />&nbsp;&nbsp;6.<br class="calibre9" />&nbsp;&nbsp;7. def getLetterCount(message):<br class="calibre9" />&nbsp;&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a dictionary with keys of single letters and values of the<br class="calibre9" />&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# count of how many times they appear in the message parameter:<br class="calibre9" />&nbsp;10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterCount = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'W': 0, 'X': 0, 'Y': 0, 'Z': 0}<br class="calibre9" />&nbsp;11.<br class="calibre9" />&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in message.upper():<br class="calibre9" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letter in LETTERS:<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterCount[letter] += 1<br class="calibre9" />&nbsp;15.<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return letterCount<br class="calibre9" />&nbsp;17.<br class="calibre9" />&nbsp;18.<br class="calibre9" />&nbsp;19. def getItemAtIndexZero(items):<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return items[0]<br class="calibre9" />&nbsp;21.<br class="calibre9" />&nbsp;22.<br class="calibre9" />&nbsp;23. def getFrequencyOrder(message):<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a string of the alphabet letters arranged in order of most<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# frequently occurring in the message parameter.<br class="calibre9" />&nbsp;26.<br class="calibre9" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, get a dictionary of each letter and its frequency count:<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterToFreq = getLetterCount(message)<br class="calibre9" />&nbsp;29.<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Second, make a dictionary of each frequency count to the letter(s)<br class="calibre9" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# with that frequency:<br class="calibre9" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter = {}<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in LETTERS:<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letterToFreq[letter] not in freqToLetter:<br class="calibre9" />&nbsp;35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[letterToFreq[letter]] = [letter]<br class="calibre9" />&nbsp;36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[letterToFreq[letter]].append(letter)<br class="calibre9" />&nbsp;38.<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Third, put each list of letters in reverse "ETAOIN" order, and then<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# convert it to a string:<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freq in freqToLetter:<br class="calibre9" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)<br class="calibre9" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[freq] = ''.join(freqToLetter[freq])<br class="calibre9" />&nbsp;44.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-242"></span>&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Fourth, convert the freqToLetter dictionary to a list of<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# tuple pairs (key, value), and then sort them:<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqPairs = list(freqToLetter.items())<br class="calibre9" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqPairs.sort(key=getItemAtIndexZero, reverse=True)<br class="calibre9" />&nbsp;49.<br class="calibre9" />&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Fifth, now that the letters are ordered by frequency, extract all<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the letters for the final string:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder = []<br class="calibre9" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freqPair in freqPairs:<br class="calibre9" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder.append(freqPair[1])<br class="calibre9" />&nbsp;55.<br class="calibre9" />&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(freqOrder)<br class="calibre9" />&nbsp;57.<br class="calibre9" />&nbsp;58.<br class="calibre9" />&nbsp;59. def englishFreqMatchScore(message):<br class="calibre9" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the number of matches that the string in the message<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# parameter has when its letter frequency is compared to English<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# letter frequency. A "match" is how many of its six most frequent<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and six least frequent letters are among the six most frequent and<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# six least frequent letters for English.<br class="calibre9" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder = getFrequencyOrder(message)<br class="calibre9" />&nbsp;66.<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore = 0<br class="calibre9" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find how many matches for the six most common letters there are:<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for commonLetter in ETAOIN[:6]:<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if commonLetter in freqOrder[:6]:<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore += 1<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find how many matches for the six least common letters there are:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for uncommonLetter in ETAOIN[-6:]:<br class="calibre9" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if uncommonLetter in freqOrder[-6:]:<br class="calibre9" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore += 1<br class="calibre9" />&nbsp;76.<br class="calibre9" />&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return matchScore</p>
<h3 class="h1" id="calibre_link-728">Storing the Letters in ETAOIN Order</h3>
<p class="noindent">Line 4 creates a variable named <span class="literal">ETAOIN</span>, which stores the 26 letters of the alphabet ordered from most to least frequent:</p>
<p class="programs1">&nbsp;&nbsp;1. # Frequency Finder<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'</p>
<p class="indent">Of course, not all English text reflects this exact frequency ordering. You could easily find a book that has a set of letter frequencies where Z is used more often than Q. For example, the novel <em class="calibre7">Gadsby</em> by Ernest Vincent Wright never uses the letter E, which gives it an odd set of letter frequencies. But in most cases, including in our module, the ETAOIN order should be accurate enough.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-964"></span>The module also needs a string of all the uppercase letters in alphabetical order for a few different functions, so we set the <span class="literal">LETTERS</span> constant variable on line 5.</p>
<p class="programs1">&nbsp;&nbsp;5. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>
<p class="indent"><span class="literal">LETTERS</span> serves the same purpose as the <span class="literal">SYMBOLS</span> variables did in our previous programs: providing a mapping between string letters and integer indexes.</p>
<p class="indent">Next, we’ll look at how the <span class="literal">getLettersCount()</span> function counts the frequency of each letter stored in the <span class="literal">message</span> string.</p>
<h3 class="h1" id="calibre_link-729">Counting the Letters in a Message</h3>
<p class="noindent">The <span class="literal">getLetterCount()</span> function takes the <span class="literal">message</span> string and returns a dictionary value whose keys are single uppercase letter strings and whose values are integers that store the number of times that letter occurs in the <span class="literal">message</span> parameter.</p>
<p class="indent">Line 10 creates the <span class="literal">letterCount</span> variable by assigning to it a dictionary that has all keys set to an initial value of <span class="literal">0</span>:</p>
<p class="programs1">&nbsp;&nbsp;7. def getLetterCount(message):<br class="calibre9" />&nbsp;&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a dictionary with keys of single letters and values of the<br class="calibre9" />&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# count of how many times they appear in the message parameter:<br class="calibre9" />&nbsp;10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterCount = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'G': 0, 'H': 0, 'I': 0, 'J': 0, 'K': 0, 'L': 0, 'M': 0, 'N': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'O': 0, 'P': 0, 'Q': 0, 'R': 0, 'S': 0, 'T': 0, 'U': 0, 'V': 0,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'W': 0, 'X': 0, 'Y': 0, 'Z': 0}</p>
<p class="indent">We increment the values associated with the keys until they represent the counts of each letter by checking each character in <span class="literal">message</span> using a <span class="literal">for</span> loop on line 12.</p>
<p class="programs1">&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in message.upper():<br class="calibre9" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letter in LETTERS:<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterCount[letter] += 1</p>
<p class="indent">The <span class="literal">for</span> loop iterates through each character in the uppercase version of <span class="literal">message</span> and assigns the character to the <span class="literal">letter</span> variable. On line 13, we check whether the character exists in the <span class="literal">LETTERS</span> string, because we don’t want to count the non-letter characters in <span class="literal">message</span>. When the <span class="literal">letter</span> is part of the <span class="literal">LETTERS</span> string, line 14 increments the value at <span class="literal">letterCount[letter]</span>.</p>
<p class="indent">After the <span class="literal">for</span> loop on line 12 finishes, the <span class="literal">letterCount</span> dictionary on line 16 should have a count showing how often each letter appeared in <span class="literal">message</span>. This dictionary is returned from <span class="literal">getLetterCount()</span>:</p>
<p class="programs1">&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return letterCount</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-181"></span>For example, in this chapter we’ll use the following string (from <a href="https://en.wikipedia.org/wiki/Alan_Turing" class="calibre8"><em class="calibre7">https://en.wikipedia.org/wiki/Alan_Turing</em></a>):</p>
<p class="programs1">"""Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and computer<br class="calibre9" />scientist. He was highly influential in the development of computer science, providing a<br class="calibre9" />formalisation of the concepts of "algorithm" and "computation" with the Turing machine. Turing<br class="calibre9" />is widely considered to be the father of computer science and artificial intelligence. During<br class="calibre9" />World War II, Turing worked for the Government Code and Cypher School (GCCS) at Bletchley Park,<br class="calibre9" />Britain's codebreaking centre. For a time he was head of Hut 8, the section responsible for<br class="calibre9" />German naval cryptanalysis. He devised a number of techniques for breaking German ciphers,<br class="calibre9" />including the method of the bombe, an electromechanical machine that could find settings<br class="calibre9" />for the Enigma machine. After the war he worked at the National Physical Laboratory, where<br class="calibre9" />he created one of the first designs for a stored-program computer, the ACE. In 1948 Turing<br class="calibre9" />joined Max Newman's Computing Laboratory at Manchester University, where he assisted in the<br class="calibre9" />development of the Manchester computers and became interested in mathematical biology. He wrote<br class="calibre9" />a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions<br class="calibre9" />such as the Belousov-Zhabotinsky reaction, which were first observed in the 1960s. Turing's<br class="calibre9" />homosexuality resulted in a criminal prosecution in 1952, when homosexual acts were still<br class="calibre9" />illegal in the United Kingdom. He accepted treatment with female hormones (chemical castration)<br class="calibre9" />as an alternative to prison. Turing died in 1954, just over two weeks before his 42nd birthday,<br class="calibre9" />from cyanide poisoning. An inquest determined that his death was suicide; his mother and some<br class="calibre9" />others believed his death was accidental. On 10 September 2009, following an Internet campaign,<br class="calibre9" />British Prime Minister Gordon Brown made an official public apology on behalf of the British<br class="calibre9" />government for "the appalling way he was treated." As of May 2012 a private member's bill was<br class="calibre9" />before the House of Lords which would grant Turing a statutory pardon if enacted."""</p>
<p class="indent">For this string value, which has 135 instances of A, 30 instances of B, and so on, <span class="literal">getLetterCount()</span> would return a dictionary that looks like this:</p>
<p class="programs1">{'A': 135, 'B': 30, 'C': 74, 'D': 58, 'E': 196, 'F': 37, 'G': 39, 'H': 87,<br class="calibre9" />'I': 139, 'J': 2, 'K': 8, 'L': 62, 'M': 58, 'N': 122, 'O': 113, 'P': 36,<br class="calibre9" />'Q': 2, 'R': 106, 'S': 89, 'T': 140, 'U': 37, 'V': 14, 'W': 30, 'X': 3,<br class="calibre9" />'Y': 21, 'Z': 1}</p>
<h3 class="h1" id="calibre_link-46">Getting the First Member of a Tuple</h3>
<p class="noindent">The <span class="literal">getItemAtIndexZero()</span> function on line 19 returns the items at index <span class="literal">0</span> when a tuple is passed to it:</p>
<p class="programs1">&nbsp;19. def getItemAtIndexZero(items):<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return items[0]</p>
<p class="indent">Later in the program, we’ll pass this function to the <span class="literal">sort()</span> method to sort the frequencies of the letters into numerical order. We’ll look at this in detail in “<a href="#calibre_link-341" class="calibre8">Converting the Dictionary Items to a Sortable List</a>” on <a href="#calibre_link-341" class="calibre8">page 275</a>.</p>
<h3 class="h1" id="calibre_link-730">Ordering the Letters in the Message by Frequency</h3>
<p class="noindent">The <span class="literal">getFrequencyOrder()</span> function takes a <span class="literal">message</span> string as an argument and returns a string with the 26 uppercase letters of the alphabet arranged by how frequently they appear in the <span class="literal">message</span> parameter. If <span class="literal">message</span> is readable <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-965"></span>English instead of random gibberish, it’s likely that this string will be similar, if not identical, to the string in the <span class="literal">ETAOIN</span> constant. The code in the <span class="literal">getFrequencyOrder()</span> function does most of the work of calculating a string’s frequency match score, which we’ll use in the Vigenère hacking program in <a href="#calibre_link-64" class="calibre8">Chapter 20</a>.</p>
<p class="indent">For example, if we pass the <span class="literal">"""Alan Mathison Turing..."""</span> string to <span class="literal">getFrequencyOrder</span><span class="literal">()</span>, the function would return the string <span class="literal">'</span><span class="literal">ETIANORSHCLMDGFUPBWYVKXQJZ'</span> because E is the most common letter in that string, followed by T, then I, then A, and so on.</p>
<p class="indent">The <span class="literal">getFrequencyOrder()</span> function consists of five steps:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">Counting the letters in the string</p></li>
<li value="2" class="calibre11"><p class="noindent">Creating a dictionary of frequency counts and letter lists</p></li>
<li value="3" class="calibre11"><p class="noindent">Sorting the letter lists in reverse ETAOIN order</p></li>
<li value="4" class="calibre11"><p class="noindent">Converting this data to a list of tuples</p></li>
<li value="5" class="calibre11"><p class="noindent">Converting the list into the final string to return from the function <span class="literal">getFrequencyOrder()</span></p></li></ol>
<p class="indent">Let’s look at each step in turn.</p>
<h4 class="h2" id="calibre_link-731"><strong class="calibre3"><em class="calibre12">Counting the Letters with getLetterCount()</em></strong></h4>
<p class="noindent">The first step of <span class="literal">getFrequencyOrder()</span> calls <span class="literal">getLetterCount()</span> on line 28 with the <span class="literal">message</span> parameter to get a dictionary, named <span class="literal">letterToFreq</span>, containing the count of every letter in <span class="literal">message</span>:</p>
<p class="programs1">&nbsp;23. def getFrequencyOrder(message):<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a string of the alphabet letters arranged in order of most<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# frequently occurring in the message parameter.<br class="calibre9" />&nbsp;26.<br class="calibre9" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, get a dictionary of each letter and its frequency count:<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterToFreq = getLetterCount(message)</p>
<p class="indent">If we pass the <span class="literal">"""Alan Mathison Turing..."""</span> string as the <span class="literal">message</span> parameter, line 28 assigns <span class="literal">letterToFreq</span> the following dictionary value:</p>
<p class="programs1">{'A': 135, 'C': 74, 'B': 30, 'E': 196, 'D': 58, 'G': 39, 'F': 37, 'I': 139,<br class="calibre9" />'H': 87, 'K': 8, 'J': 2, 'M': 58, 'L': 62, 'O': 113, 'N': 122, 'Q': 2,<br class="calibre9" />'P': 36, 'S': 89, 'R': 106, 'U': 37, 'T': 140, 'W': 30, 'V': 14, 'Y': 21,<br class="calibre9" />'X': 3, 'Z': 1}</p>
<h4 class="h2" id="calibre_link-732"><strong class="calibre3"><em class="calibre12">Creating a Dictionary of Frequency Counts and Letter Lists</em></strong></h4>
<p class="noindent">The second step of <span class="literal">getFrequencyOrder()</span> creates a dictionary, <span class="literal">freqToLetter</span>, whose keys are the frequency count and whose values are a list of letters with those frequency counts. Whereas the <span class="literal">letterToFreq</span> dictionary maps letter keys to frequency values, the <span class="literal">freqToLetter</span> dictionary maps frequency keys to the list of letter values, so we’ll need to flip the key and values in the <span class="literal">letterToFreq</span> dictionary. We flip the keys and values because multiple <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-966"></span>letters could have the same frequency count: <span class="literal">'B'</span> and <span class="literal">'W'</span> both have a frequency count of <span class="literal">30</span> in our example, so we need to put them in a dictionary that looks like <span class="literal">{30: ['B', 'W']}</span> because dictionary keys must be unique. Otherwise, a dictionary value that looks like <span class="literal">{30: 'B', 30: 'W'}</span> will simply overwrite one of these key-value pairs with the other.</p>
<p class="indent">To make the <span class="literal">freqToLetter</span> dictionary, line 32 first creates a blank dictionary:</p>
<p class="programs1">&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Second, make a dictionary of each frequency count to the letter(s)<br class="calibre9" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# with that frequency:<br class="calibre9" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter = {}<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in LETTERS:<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letterToFreq[letter] not in freqToLetter:<br class="calibre9" />&nbsp;35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[letterToFreq[letter]] = [letter]<br class="calibre9" />&nbsp;36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[letterToFreq[letter]].append(letter)</p>
<p class="indent">Line 33 loops over all the letters in <span class="literal">LETTERS</span>, and the <span class="literal">if</span> statement on line 34 checks whether the letter’s frequency, or <span class="literal">letterToFreq[letter]</span>, already exists as a key in <span class="literal">freqToLetter</span>. If not, then line 35 adds this key with a list of the letter as the value. If the letter’s frequency already exists as a key in <span class="literal">freqToLetter</span>, line 37 simply appends the letter to the end of the list already in <span class="literal">letterToFreq[letter]</span>.</p>
<p class="indent">Using the example value of <span class="literal">letterToFreq</span> created using the <span class="literal">"""Alan Mathison Turing..."""</span> string, <span class="literal">freqToLetter</span> should now return something like this:</p>
<p class="programs1">{1: ['Z'], 2: ['J', 'Q'], 3: ['X'], 135: ['A'], 8: ['K'], 139: ['I'],<br class="calibre9" />140: ['T'], 14: ['V'], 21: ['Y'], 30: ['B', 'W'], 36: ['P'], 37: ['F', 'U'],<br class="calibre9" />39: ['G'], 58: ['D', 'M'], 62: ['L'], 196: ['E'], 74: ['C'], 87: ['H'],<br class="calibre9" />89: ['S'], 106: ['R'], 113: ['O'], 122: ['N']}</p>
<p class="indent">Notice that the dictionary’s keys now contain the frequency counts and its values contain lists of letters that have those frequencies.</p>
<h4 class="h2" id="calibre_link-733"><strong class="calibre3"><em class="calibre12">Sorting the Letter Lists in Reverse ETAOIN Order</em></strong></h4>
<p class="noindent">The third step of <span class="literal">getFrequencyOrder()</span> involves sorting the letter strings in each list of <span class="literal">freqToLetter</span>. Recall that <span class="literal">freqToLetter[freq]</span> evaluates to a <em class="calibre7">list</em> of letters that has a frequency count of <span class="literal">freq</span>. We use a list because it’s possible for two or more letters to have the same frequency count, in which case the list would have strings made up of two or more letters.</p>
<p class="indent">When multiple letters have the same frequency counts, we want to sort those letters in reverse order compared to the order in which they appear in the <span class="literal">ETAOIN</span> string. This makes the ordering consistent and minimizes the likelihood of increasing the frequency match score by chance.</p>
<p class="indent">For example, let’s say the frequency counts for the letters V, I, N, and K are all the same for a string we’re trying to score. Let’s also say that four letters in the string have higher frequency counts than V, I, N, and K and <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-272"></span>eighteen letters have lower frequency counts. I’ll just use <em class="calibre7">x</em> as a placeholder for these letters in this example. <a href="#calibre_link-342" class="calibre8">Figure 19-5</a> shows what putting these four letters in ETAOIN order would look like.</p>
<div class="image"><img src="images/00031.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-342" class="calibre8"></a><em class="calibre7">Figure 19-5: The frequency match score will gain two points if the four letters are in ETAOIN order.</em></p>
<p class="indent">The I and N add two points to the frequency match score in this case because I and N are among the top six most frequent letters, even though they don’t appear more frequently than V and K in this example string. Because the frequency match scores only range from 0 to 12, these two points can make quite a difference! But by putting letters of identical frequency in reverse ETAOIN order, we minimize the chances of over-scoring a letter. <a href="#calibre_link-343" class="calibre8">Figure 19-6</a> shows these four letters in reverse ETAOIN order.</p>
<div class="image"><img src="images/00033.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-343" class="calibre8"></a><em class="calibre7">Figure 19-6: The frequency match score will not increase if the four letters are in reverse ETAOIN order.</em></p>
<p class="indent">By arranging the letters in reverse ETAOIN order, we avoid artificially increasing the frequency match score through a chance ordering of I, N, V, and K. This is also true if there are eighteen letters with higher frequency counts and four letters with lower frequency counts, as shown in <a href="#calibre_link-344" class="calibre8">Figure 19-7</a>.</p>
<div class="image"><img src="images/00034.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-344" class="calibre8"></a><em class="calibre7">Figure 19-7: Reversing ETAOIN order for less frequent letters also avoids increasing the match score.</em></p>
<p class="indent">The reverse sort order ensures that K and V don’t match any of the six least frequent letters in English and again avoids increasing the frequency match score by two points.</p>
<p class="indent">To sort each list value in the <span class="literal">freqToLetter</span> dictionary in reverse ETAOIN order, we’ll need to pass a method to Python’s <span class="literal">sort()</span> function. Let’s look at how to pass a function or method to another function.</p>
<h5 class="h3"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-250" class="calibre1"></span><strong class="calibre3">Passing Functions as Values</strong></h5>
<p class="noindent">On line 42, instead of calling the <span class="literal">find()</span> method, we pass <span class="literal">find</span> as a value to the <span class="literal">sort()</span> method call:</p>
<p class="programs1">&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)</p>
<p class="indent">We can do this because in Python, functions can be treated as values. In fact, defining a function named <span class="literal">spam</span> is the same as storing the function definition in a variable named <span class="literal">spam</span>. To see an example, enter the following code into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">def spam():</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Hello!')</span><br class="calibre9" />...<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam()</span><br class="calibre9" />Hello!<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs = spam</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs()</span><br class="calibre9" />Hello!</p>
<p class="indent">In this example code, we define a function named <span class="literal">spam()</span> that prints the string <span class="literal">'Hello!'</span>. This also means that the variable <span class="literal">spam</span> holds the function definition. Then we copy the function in the <span class="literal">spam</span> variable to the variable <span class="literal">eggs</span>. After doing so, we can call <span class="literal">eggs()</span> just like we can call <span class="literal">spam()</span>! Note that the assignment statement does <em class="calibre7">not</em> include parentheses after <span class="literal">spam</span>. If it did, it would instead <em class="calibre7">call</em> the <span class="literal">spam()</span> function and set the variable <span class="literal">eggs</span> to the return value that gets evaluated from the <span class="literal">spam()</span> function.</p>
<p class="indent">Since functions are values, we can pass them as arguments in function calls. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">def doMath(func):</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<span class="codestrong">return func(10, 5)</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">def adding(a, b):</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<span class="codestrong">return a + b</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">def subtracting(a, b):</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;<span class="codestrong">return a - b</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;...<br class="calibre9" /><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">doMath(adding)</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;15<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">doMath(subtracting)</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;5</p>
<p class="indent">Here we define three functions: <span class="literal">doMath()</span>, <span class="literal">adding()</span>, and <span class="literal">subtracting()</span>. When we pass the function in <span class="literal">adding</span> to the <span class="literal">doMath()</span> call <span class="ent">➊</span>, we are assigning <span class="literal">adding</span> to the variable <span class="literal">func</span>, and <span class="literal">func(10, 5)</span> is calling <span class="literal">adding()</span> and passing <span class="literal">10</span> and <span class="literal">5</span> to it. So the call <span class="literal">func(10, 5)</span> is effectively the same as the call <span class="literal">adding</span><span class="literal">(10, 5)</span>. This is why <span class="literal">doMath(adding)</span> returns <span class="literal">15</span>. Similarly, when we <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-127"></span>pass <span class="literal">subtracting</span> to the <span class="literal">doMath()</span> call, <span class="literal">doMath(subtracting)</span> returns <span class="literal">5</span> because <span class="literal">func(10, 5)</span> is the same as <span class="literal">subtracting(10, 5)</span>.</p>
<h5 class="h3"><strong class="calibre3">Passing a Function to the sort() Method</strong></h5>
<p class="noindent">Passing a function or method to the <span class="literal">sort()</span> method lets us implement different sorting behavior. Normally, <span class="literal">sort()</span> sorts the values in a list in alphabetical order:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = ['C', 'B', 'A']</span> <br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.sort()</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['A', 'B', 'C']</p>
<p class="indent">But if we pass a function (or method) for the <span class="literal">key</span> keyword argument, the values in the list are sorted <em class="calibre7">by the function’s return value</em> when each value in the list is passed to that function. For example, we can also pass the <span class="literal">ETAOIN.find()</span> string method as the <span class="literal">key</span> to a <span class="literal">sort()</span> call, as follows:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.sort(key=ETAOIN.find)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['A', 'C', 'B']</p>
<p class="indent">When we pass <span class="literal">ETAOIN.find</span> to the <span class="literal">sort()</span> method, instead of sorting the strings in alphabetical order, the <span class="literal">sort()</span> method first calls the <span class="literal">find()</span> method on each string so that <span class="literal">ETAOIN.find('A')</span>, <span class="literal">ETAOIN.find('B')</span>, and <span class="literal">ETAOIN.find('C')</span> return the indexes <span class="literal">2</span>, <span class="literal">19</span>, and <span class="literal">11</span>, respectively&mdash;each string’s position in the <span class="literal">ETAOIN</span> string. Then <span class="literal">sort()</span> uses these returned indexes, rather the original <span class="literal">'A'</span>, <span class="literal">'B'</span>, and <span class="literal">'C'</span> strings, to sort the items in the <span class="literal">spam</span> list. This is why the <span class="literal">'A'</span>, <span class="literal">'B'</span>, and <span class="literal">'C'</span> strings get sorted as <span class="literal">'A'</span>, <span class="literal">'C'</span>, and <span class="literal">'B'</span>, reflecting the order in which they appear in <span class="literal">ETAOIN</span>.</p>
<h5 class="h3"><strong class="calibre3">Reversing the Letter Lists with the sort() Method</strong></h5>
<p class="noindent">To sort letters in reverse <span class="literal">ETAOIN</span> order, we first need to sort them based on the <span class="literal">ETAOIN</span> string by assigning <span class="literal">ETAOIN.find</span> to <span class="literal">key</span>. After the method has been called on all the letters so that they’re all indexes, the <span class="literal">sort()</span> method sorts the letters based on their numerical index.</p>
<p class="indent">Usually, the <span class="literal">sort()</span> function sorts whatever list it’s called on in alphabetical or numerical order, which is known as <em class="calibre7">ascending order</em>. To sort items in <em class="calibre7">descending order,</em> which is in reverse alphabetical or reverse numerical order, we pass <span class="literal">True</span> for the <span class="literal">sort()</span> method’s <span class="literal">reverse</span> keyword argument.</p>
<p class="indent">We do all of this on line 42:</p>
<p class="programs1">&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Third, put each list of letters in reverse "ETAOIN" order, and then<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# convert it to a string:<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freq in freqToLetter:<br class="calibre9" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[freq].sort(key=ETAOIN.find, reverse=True)<br class="calibre9" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqToLetter[freq] = ''.join(freqToLetter[freq])</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-267"></span>Recall that at this point, <span class="literal">freqToLetter</span> is a dictionary that stores integer frequency counts as its keys and lists of letter strings as its values. The letter strings at key <span class="literal">freq</span> are being sorted, not the <span class="literal">freqToLetter</span> dictionary itself. Dictionaries cannot be sorted because they have no order: there is no “first” or “last” key-value pair as there is for list items.</p>
<p class="indent">Using the <span class="literal">"""Alan Mathison Turing..."""</span> example value for <span class="literal">freqToLetter</span> again, when the loop finishes, this would be the value stored in <span class="literal">freqToLetter</span>:</p>
<p class="programs1">{1: 'Z', 2: 'QJ', 3: 'X', 135: 'A', 8: 'K', 139: 'I', 140: 'T', 14: 'V',<br class="calibre9" />21: 'Y', 30: 'BW', 36: 'P', 37: 'FU', 39: 'G', 58: 'MD', 62: 'L', 196: 'E',<br class="calibre9" />74: 'C', 87: 'H', 89: 'S', 106: 'R', 113: 'O', 122: 'N'}</p>
<p class="indent">Notice that the strings for the <span class="literal">30</span>, <span class="literal">37</span>, and <span class="literal">58</span> keys are all sorted in reverse ETAOIN order. Before the loop executed, the key-value pairs looked like this: <span class="literal">{30: ['B', 'W'], 37: ['F', 'U'], 58: ['D', 'M'], ...}</span>. After the loop, they should look like this: <span class="literal">{30: 'BW', 37: 'FU', 58: 'MD', ...}</span>.</p>
<p class="indent">The <span class="literal">join()</span> method call on line 43 changes the list of strings into a single string. For example, the value in <span class="literal">freqToLetter[30]</span> is <span class="literal">['B', 'W']</span>, which is joined as <span class="literal">'BW'</span>.</p>
<h4 class="h2" id="calibre_link-734"><strong class="calibre3"><em class="calibre12">Sorting the Dictionary Lists by Frequency</em></strong></h4>
<p class="noindent">The fourth step of <span class="literal">getFrequencyOrder()</span> is to sort the strings from the <span class="literal">freqToLetter</span> dictionary by the frequency count and to convert the strings to a list. Keep in mind that because the key-value pairs in dictionaries are unordered, a list value of all the keys or values in a dictionary will be a list of items in random order. This means that we’ll also need to sort this list.</p>
<h5 class="h3"><strong class="calibre3">Using the keys(), values(), and items() Dictionary Methods</strong></h5>
<p class="noindent">The <span class="literal">keys()</span>, <span class="literal">values()</span>, and <span class="literal">items()</span> dictionary methods each convert parts of a dictionary into a non-dictionary data type. After a dictionary is converted to another data type, it can be converted into a list using the <span class="literal">list()</span> function.</p>
<p class="indent">Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = {'cats': 10, 'dogs': 3, 'mice': 3}</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.keys()</span><br class="calibre9" />dict_keys(['mice', 'cats', 'dogs'])<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">list(spam.keys())</span><br class="calibre9" />['mice', 'cats', 'dogs']<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">list(spam.values())</span><br class="calibre9" />[3, 10, 3]</p>
<p class="indent">To get a list value of all the keys in a dictionary, we can use the <span class="literal">keys()</span> method to return a <span class="literal">dict_keys</span> object that we can then pass to the <span class="literal">list()</span> function. A similar dictionary method named <span class="literal">values()</span> returns a <span class="literal">dict_values</span> object. These examples give us a list of the dictionary’s keys and a list of its values, respectively.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-129"></span>To get both the keys and the values, we can use the <span class="literal">items()</span> dictionary method to return a <span class="literal">dict_items</span> object, which makes the key-value pairs into tuples. We can then pass the tuples to <span class="literal">list()</span>. Enter the following into the interactive shell to see this in action:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = {'cats': 10, 'dogs': 3, 'mice': 3}</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">list(spam.items())</span><br class="calibre9" />[('mice', 3), ('cats', 10), ('dogs', 3)]</p>
<p class="indent">By calling <span class="literal">items()</span> and <span class="literal">list()</span>, we convert the <span class="literal">spam</span> dictionary’s key-value pairs into a list of tuples. This is exactly what we need to do with the <span class="literal">freqToLetter</span> dictionary so we can sort the letter strings in numerical order by frequency.</p>
<h5 class="h3" id="calibre_link-341"><strong class="calibre3">Converting the Dictionary Items to a Sortable List</strong></h5>
<p class="noindent">The <span class="literal">freqToLetter</span> dictionary has integer frequency counts as its keys and lists of single-letter strings as its values. To sort the strings in frequency order, we call the <span class="literal">items()</span> method and the <span class="literal">list()</span> function to create a list of tuples of the dictionary’s key-value pairs. Then we store this list of tuples in a variable named <span class="literal">freqPairs</span> on line 47:</p>
<p class="programs1">&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Fourth, convert the freqToLetter dictionary to a list of<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# tuple pairs (key, value), and then sort them:<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqPairs = list(freqToLetter.items())</p>
<p class="indent">On line 48, we pass the <span class="literal">getItemAtIndexZero</span> function value that we defined earlier in the program to the <span class="literal">sort()</span> method call:</p>
<p class="programs1">&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqPairs.sort(key=getItemAtIndexZero, reverse=True)</p>
<p class="indent">The <span class="literal">getItemAtIndexZero()</span> function gets the first item in a tuple, which in this case is the frequency count integer. This means that the items in <span class="literal">freqPairs</span> are sorted by the numeric order of the frequency count integers. Line 48 also passes <span class="literal">True</span> for the <span class="literal">reverse</span> keyword argument so the tuples are reverse ordered from largest frequency count to smallest.</p>
<p class="indent">Continuing with the <span class="literal">"</span><span class="literal">""Alan Mathison Turing..."""</span> example, after line 48 executes, this would be the value of <span class="literal">freqPairs</span>:</p>
<p class="programs1">[(196, 'E'), (140, 'T'), (139, 'I'), (135, 'A'), (122, 'N'), (113, 'O'),<br class="calibre9" />(106, 'R'), (89, 'S'), (87, 'H'), (74, 'C'), (62, 'L'), (58, 'MD'), (39, 'G'),<br class="calibre9" />(37, 'FU'), (36, 'P'), (30, 'BW'), (21, 'Y'), (14, 'V'), (8, 'K'), (3, 'X'),<br class="calibre9" />(2, 'QJ'), (1, 'Z')]</p>
<p class="indent">The <span class="literal">freqPairs</span> variable is now a list of tuples ordered from the most frequent to least frequent letters: the first value in each tuple is an integer representing the frequency count, and the second value is a string containing the letters associated with that frequency count.</p>
<h4 class="h2" id="calibre_link-735"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-967" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Creating a List of the Sorted Letters</em></strong></h4>
<p class="noindent">The fifth step of <span class="literal">getFrequencyOrder()</span> is to create a list of all the strings from the sorted list in <span class="literal">freqPairs</span>. We want to end up with a single string value whose letters are in the order of their frequency, so we don’t need the integer values in <span class="literal">freqPairs</span>. The variable <span class="literal">freqOrder</span> starts as a blank list on line 52, and the <span class="literal">for</span> loop on line 53 appends the string at index <span class="literal">1</span> of each tuple in <span class="literal">freqPairs</span> to the end of <span class="literal">freqOrder</span>:</p>
<p class="programs1">&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Fifth, now that the letters are ordered by frequency, extract all<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the letters for the final string:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder = []<br class="calibre9" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freqPair in freqPairs:<br class="calibre9" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder.append(freqPair[1])</p>
<p class="indent">Continuing with the example, after line 53’s loop has finished, <span class="literal">freqOrder</span> should contain <span class="literal">['E',</span> <span class="literal">'T',</span> <span class="literal">'</span><span class="literal">I',</span> <span class="literal">'A',</span> <span class="literal">'N',</span> <span class="literal">'O',</span> <span class="literal">'R',</span> <span class="literal">'S',</span> <span class="literal">'H',</span> <span class="literal">'C',</span> <span class="literal">'L',</span> <span class="literal">'MD',</span> <span class="literal">'</span><span class="literal">G',</span> <span class="literal">'FU',</span> <span class="literal">'P',</span> <span class="literal">'BW',</span> <span class="literal">'Y',</span> <span class="literal">'V',</span> <span class="literal">'K',</span> <span class="literal">'X',</span> <span class="literal">'QJ',</span> <span class="literal">'Z']</span> as its value.</p>
<p class="indent">Line 56 creates a string from the list of strings in <span class="literal">freqOrder</span> by joining them using the <span class="literal">join()</span> method:</p>
<p class="programs1">&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(freqOrder)</p>
<p class="indent">For the <span class="literal">"""Alan Mathison Turing..."""</span> example, <span class="literal">getFrequencyOrder()</span> returns the string <span class="literal">'ETIANORSHCLMDGFUPBWYVKXQJZ'</span>. According to this ordering, E is the most frequent letter in the example string, T is the second most frequent letter, I is the third most frequent, and so on.</p>
<p class="indent">Now that we have the letter frequency of the message as a string value, we can compare it to the string value of English’s letter frequency (<span class="literal">'ETAOINSHRDLCUMWFGYPBVKJXQZ'</span>) to see how closely they match.</p>
<h3 class="h1" id="calibre_link-736"><strong class="calibre3">Calculating the Frequency Match Score of the Message</strong></h3>
<p class="noindent">The <span class="literal">englishFreqMatchScore()</span> function takes a string for <span class="literal">message</span> and then returns an integer between <span class="literal">0</span> and <span class="literal">12</span> representing the string’s frequency match score. The higher the score, the more closely the letter frequency in <span class="literal">message</span> matches the frequency of normal English text.</p>
<p class="programs1">&nbsp;59. def englishFreqMatchScore(message):<br class="calibre9" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return the number of matches that the string in the message<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# parameter has when its letter frequency is compared to English<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# letter frequency. A "match" is how many of its six most frequent<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and six least frequent letters are among the six most frequent and<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# six least frequent letters for English.<br class="calibre9" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqOrder = getFrequencyOrder(message)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-968"></span>The first step in calculating the frequency match score is to get the letter frequency ordering of <span class="literal">message</span> by calling the <span class="literal">getFrequencyOrder()</span> function, which we do on line 65. We store the ordered string in the variable <span class="literal">freqOrder</span>.</p>
<p class="indent">The <span class="literal">matchScore</span> variable starts at <span class="literal">0</span> on line 67 and is incremented by the <span class="literal">for</span> loop beginning on line 69, which compares the first six letters of the <span class="literal">ETAOIN</span> string and the first six letters of <span class="literal">freqOrder</span>, giving a point for each letter they have in common:</p>
<p class="programs1">&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore = 0<br class="calibre9" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find how many matches for the six most common letters there are:<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for commonLetter in ETAOIN[:6]:<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if commonLetter in freqOrder[:6]:<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore += 1</p>
<p class="indent">Recall that the <span class="literal">[:6]</span> slice is the same as <span class="literal">[0:6]</span>, so lines 69 and 70 slice the first six letters of the <span class="literal">ETAOIN</span> and <span class="literal">freqOrder</span> strings, respectively. If any of the letters E, T, A, O, I, or N is also in the first six letters in the <span class="literal">freqOrder</span> string, the condition on line 70 is <span class="literal">True</span>, and line 71 increments <span class="literal">matchScore</span>.</p>
<p class="indent">Lines 73 to 75 are similar to lines 69 to 71, except in this case they check whether the <em class="calibre7">last</em> six letters in the <span class="literal">ETAOIN</span> string (V, K, J, X, Q, and Z) are in the <em class="calibre7">last</em> six letters in the <span class="literal">freqOrder</span> string. If they are, <span class="literal">matchScore</span> is incremented.</p>
<p class="programs1">&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find how many matches for the six least common letters there are:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for uncommonLetter in ETAOIN[-6:]:<br class="calibre9" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if uncommonLetter in freqOrder[-6:]:<br class="calibre9" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;matchScore += 1</p>
<p class="indent">Line 77 returns the integer in <span class="literal">matchScore</span>:</p>
<p class="programs1">&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return matchScore</p>
<p class="indent">We ignore the 14 letters in the middle of the frequency order when calculating the frequency match score. The frequencies of these middle letters are too similar to each other to give meaningful information.</p>
<h3 class="h1" id="calibre_link-737"><strong class="calibre3">Summary</strong></h3>
<p class="noindent">In this chapter, you learned how to use the <span class="literal">sort()</span> function to sort list values in alphabetical or numerical order and how to use the <span class="literal">reverse</span> and <span class="literal">key</span> keyword arguments to sort list values in different ways. You learned how to convert dictionaries to lists using the <span class="literal">keys()</span>, <span class="literal">values()</span>, and <span class="literal">items()</span> dictionary methods. You also learned that you can pass functions as values in function calls.</p>
<p class="indent">In <a href="#calibre_link-64" class="calibre8">Chapter 20</a>, we’ll use the frequency analysis module we wrote in this chapter to hack the Vigenère cipher!</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-738"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-969"></span><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What is frequency analysis?</p>
</li>
<li value="2" class="calibre11"><p class="noindent">What are the six most commonly used letters in English?</p>
</li>
<li value="3" class="calibre11"><p class="noindent">What does the <span class="literal">spam</span> variable contain after you run the following code?</p>
<p class="programs1">spam = [4, 6, 2, 8]<br class="calibre9" />spam.sort(reverse=True)</p>
</li>
<li value="4" class="calibre11"><p class="noindent">If the <span class="literal">spam</span> variable contains a dictionary, how can you get a list value of the keys in the dictionary?</p></li>
</ol>
</div>
</div>



<a href="chapter18.html">Prev: Chapter 18 - Programming the Vigenere Cipher</a> | <a href="chapter20.html">Next: Chapter 20 - Hacking the Vigenere Cipher</a>
</body></html>