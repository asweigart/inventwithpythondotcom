<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Cracking Codes with Python</title></head><body style="background-color: #fffeee;">


<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter16.html">Previous Chapter - Programming the Simple Substitution Cipher</a> | <a href="chapter18.html">Next Chapter - Programming the Vigenère Cipher</a></div>
<div id="calibre_link-383" class="calibre">
<h2 class="h2a1" id="calibre_link-63"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-949" class="calibre1"></span><span class="big">17</span><br class="calibre15" />HACKING THE SIMPLE SUBSTITUTION CIPHER</h2>
<p class="epigraph"><em class="calibre7">“Encryption is fundamentally a private act. <br class="calibre9" />The act of encryption, in fact, removes information from the public realm. Even laws against cryptography reach only so far as a nation’s border and the arm of its violence.”<br class="calibre9" />&mdash;Eric Hughes, “A Cypherpunk’s Manifesto” (1993)</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In <a href="#calibre_link-62" class="calibre8">Chapter 16</a>, you learned that the simple substitution cipher is impossible to crack using brute force because it has too many possible keys. To hack the simple substitution cipher, we need to create a more sophisticated program that uses dictionary values to map the potential decryption letters of a ciphertext. In this chapter, we’ll write such a program to narrow down the list of potential decryption outputs to the right one.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-161"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">Word patterns, candidates, potential decryption letters, and cipherletter mappings</p></li>
<li class="calibre11"><p class="noindent">Regular expressions</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">sub()</span> regex method</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-691"><strong class="calibre3">Using Word Patterns to Decrypt</strong></h3>
<p class="noindent">In brute-force attacks, we try each possible key to check whether it can decrypt the ciphertext. If the key is correct, the decryption results in readable English. But by analyzing the ciphertext first, we can reduce the number of possible keys to try and maybe even find a full or partial key.</p>
<p class="indent">Let’s assume the original plaintext consists mostly of words in an English dictionary file, like the one we used in <a href="#calibre_link-28" class="calibre8">Chapter 11</a>. Although a ciphertext won’t be made of real English words, it will still contain groups of letters broken up by spaces, just like words in regular sentences. We’ll call these <em class="calibre7">cipherwords</em> in this book. In a substitution cipher, every letter of the alphabet has exactly one unique corresponding encryption letter. We’ll call the letters in the ciphertext <em class="calibre7">cipherletters</em>. Because each plaintext letter can encrypt to only one cipherletter, and we’re not encrypting spaces in this version of the cipher, the plaintext and ciphertext will share the same <em class="calibre7">word patterns</em>.</p>
<p class="indent">For example, if we had the plaintext MISSISSIPPI SPILL, the corresponding ciphertext might be RJBBJBBJXXJ BXJHH. The number of letters in the first word of the plaintext and the first cipherword are the same. The same is true for the second plaintext word and the second cipher&shy;word. The plaintext and ciphertext share the same pattern of letters and spaces. Also notice that letters that repeat in the plaintext repeat the same number of times and in the same places as the ciphertext.</p>
<p class="indent">We could therefore assume that a cipherword corresponds to a word in the English dictionary file and that their word patterns would match. Then, if we can find which word in the dictionary the cipherword decrypts to, we can figure out the decryption of each cipherletter in that word. And if we figure out enough cipherletter decryptions using this technique, we may be able to decrypt the entire message.</p>
<h4 class="h2" id="calibre_link-692"><strong class="calibre3"><em class="calibre12">Finding Word Patterns</em></strong></h4>
<p class="noindent">Let’s examine the word pattern of the cipherword HGHHU. You can see that the cipherword has certain characteristics, which the original plaintext word must share. Both words must have the following in common.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-154"></span>They should be five letters long.</p></li>
<li value="2" class="calibre11"><p class="noindent">The first, third, and fourth letters should be the same.</p></li>
<li value="3" class="calibre11"><p class="noindent">They should have exactly three different letters; the first, second, and fifth letters should all be different.</p></li>
</ol>
<p class="indent">Let’s think of words in the English language that fit this pattern. <em class="calibre7">Puppy</em> is one such word, which is five letters long (P, U, P, P, Y) and uses three different letters (P, U, Y) arranged in that same pattern (P for the first, third, and fourth letter; U for the second letter; and Y for the fifth letter). <em class="calibre7">Mommy</em>, <em class="calibre7">bobby</em>, <em class="calibre7">lulls</em>, and <em class="calibre7">nanny</em> fit the pattern, too. These words, along with any other word in the English dictionary file that matches the criteria, are all possible decryptions of HGHHU.</p>
<p class="indent">To represent a word pattern in a way the program can understand, we’ll make each pattern into a set of numbers separated by periods that indicates the pattern of letters.</p>
<p class="indent">Creating word patterns is easy: the first letter gets the number 0, and the first occurrence of each different letter thereafter gets the next number. For example, the word pattern for <em class="calibre7">cat</em> is 0.1.2, and the word pattern for <em class="calibre7">classification</em> is 0.1.2.3.3.4.5.4.0.2.6.4.7.8.</p>
<p class="indent">In simple substitution ciphers, no matter which key is used to encrypt, a plaintext word and its cipherword <em class="calibre7">always</em> have the same word pattern. The word pattern for the cipherword HGHHU is 0.1.0.0.2, which means the word pattern of the plaintext corresponding to HGHHU is also 0.1.0.0.2.</p>
<h4 class="h2" id="calibre_link-693"><strong class="calibre3"><em class="calibre12">Finding Potential Decryption Letters</em></strong></h4>
<p class="noindent">To decrypt HGHHU, we need to find all the words in an English dictionary file whose word pattern is also 0.1.0.0.2. In this book, we’ll call the plaintext words that have the same word pattern as the cipherword the <em class="calibre7">candidates</em> for that cipherword. Here is a list of candidates for HGHHU:</p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">puppy</p></li>
<li class="calibre11"><p class="noindent">mommy</p></li>
<li class="calibre11"><p class="noindent">bobby</p></li>
<li class="calibre11"><p class="noindent">lulls</p></li>
<li class="calibre11"><p class="noindent">nanny</p></li>
</ul>
<p class="indent">Using word patterns, we can guess which plaintext letters cipherletters might decrypt to, which we’ll call the cipherletter’s <em class="calibre7">potential decryption letters</em>. To crack a message encrypted with the simple substitution cipher, we need to find all the potential decryption letters of each word in the message and determine the actual decryption letters through the process of elimination. <a href="#calibre_link-384" class="calibre8">Table 17-1</a> lists the potential decryption letters for HGHHU.</p>
<p class="tabcap"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-162"></span><a id="calibre_link-384" class="calibre8"></a><strong class="calibre5">Table 17-1:</strong> Potential Decryption Letters of the Cipherletters in HGHHU</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"><p class="table"><strong class="calibre5">Cipherletters</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">H</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">G</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">H</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">H</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">U</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18"><p class="table"><strong class="calibre5">Potential decryption letters</strong></p></td>
<td class="calibre18"><p class="table">P</p></td>
<td class="calibre18"><p class="table">U</p></td>
<td class="calibre18"><p class="table">P</p></td>
<td class="calibre18"><p class="table">P</p></td>
<td class="calibre18"><p class="table">Y</p></td>
</tr>
<tr class="table_w">
<td class="calibre19"></td>
<td class="calibre18"><p class="table">M</p></td>
<td class="calibre18"><p class="table">O</p></td>
<td class="calibre18"><p class="table">M</p></td>
<td class="calibre18"><p class="table">M</p></td>
<td class="calibre18"><p class="table">Y</p></td>
</tr>
<tr class="table_w">
<td class="calibre19"></td><td class="calibre18"><p class="table">B</p></td>
<td class="calibre18"><p class="table">O</p></td>
<td class="calibre18"><p class="table">B</p></td>
<td class="calibre18"><p class="table">B</p></td>
<td class="calibre18"><p class="table">Y</p></td>
</tr>
<tr class="table_w">
<td class="calibre19"></td><td class="calibre18"><p class="table">L</p></td>
<td class="calibre18"><p class="table">U</p></td>
<td class="calibre18"><p class="table">L</p></td>
<td class="calibre18"><p class="table">L</p></td>
<td class="calibre18"><p class="table">S</p></td>
</tr>
<tr class="table_w">
<td class="calibre19"></td><td class="calibre18"><p class="table">N</p></td>
<td class="calibre18"><p class="table">A</p></td>
<td class="calibre18"><p class="table">N</p></td>
<td class="calibre18"><p class="table">N</p></td>
<td class="calibre18"><p class="table">Y</p></td>
</tr>
</tbody>
</table>
<p class="indent">The following is a <em class="calibre7">cipherletter mapping</em> created using <a href="#calibre_link-384" class="calibre8">Table 17-1</a>:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">H has the potential decryption letters P, M, B, L, and N.</p></li>
<li value="2" class="calibre11"><p class="noindent">G has the potential decryption letters U, O, and A.</p></li>
<li value="3" class="calibre11"><p class="noindent">U has the potential decryption letters Y and S.</p></li>
<li value="4" class="calibre11"><p class="noindent">All of the other cipherletters besides H, G, and U have no potential decryption letters in this example.</p></li></ol>
<p class="indent">A cipherletter mapping shows all the letters of the alphabet and their potential decryption letters. As we start to gather encrypted messages, we’ll find potential decryption letters for every letter in the alphabet, but because only the cipherletters H, G, and U were part of our example ciphertext, we don’t have the potential decryption letters of other cipherletters.</p>
<p class="indent">Notice also that U has only two potential decryption letters (Y and S) because there are overlaps between the candidates, many of which end in the letter Y. <em class="calibre7">The more overlaps there are, the fewer potential decryption letters there will be, and the easier it will be to figure out what that cipherletter decrypts to.</em></p>
<p class="indent">To represent <a href="#calibre_link-384" class="calibre8">Table 17-1</a> in Python code, we’ll use a dictionary value to represent cipherletter mappings as follows (the key-value pairs for <span class="literal">'H'</span>, <span class="literal">'G'</span>, and <span class="literal">'U'</span> are in bold):</p>
<p class="programs1">{'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], <span class="codestrong">'G': ['U', 'O', 'A']</span>,<br class="calibre9" /><span class="codestrong">'H': ['P', 'M', 'B', 'L', 'N']</span>, 'I': [], 'J': [], 'K': [], 'L': [], 'M': [],<br class="calibre9" />'N': [], 'O': [], 'P': [], 'Q': [], 'R': [], 'S': [], 'T': [], <span class="codestrong">'U': ['Y',<br class="calibre9" />'S']</span>, 'V': [], 'W': [], 'X': [], 'Y': [], 'Z': []}</p>
<p class="indent">This dictionary has 26 key-value pairs, one key for each letter of the alphabet and a list of potential decryption letters for each letter. It shows potential decryption letters for keys <span class="literal">'H'</span>, <span class="literal">'G'</span>, and <span class="literal">'</span><span class="literal">U'</span>. The other keys have empty lists, <span class="literal">[]</span>, for values, because they have no potential decryption letters so far.</p>
<p class="indent">If we can reduce the number of potential decryption letters for a cipherletter to just one letter by cross-referencing cipherletter mappings of other encrypted words, we can find what that cipherletter decrypts to. Even if we can’t solve all 26 cipherletters, we might be able to hack most of the cipherletter mappings to decrypt most of the ciphertext.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-254"></span>Now that we’ve covered some of the basic concepts and terminology we’ll be using in this chapter, let’s look at the steps involved in the hacking process.</p>
<h3 class="h1" id="calibre_link-694">Overview of the Hacking Process</h3>
<p class="noindent">Hacking the simple substitution cipher is pretty easy using word patterns. We can summarize the major steps of the hacking process as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">Find the word pattern for each cipherword in the ciphertext.</p></li>
<li value="2" class="calibre11"><p class="noindent">Find the English word candidates that each cipherword could decrypt to.</p></li>
<li value="3" class="calibre11"><p class="noindent">Create a dictionary showing potential decryption letters for each cipherletter to act as the cipherletter mapping for each cipherword.</p></li>
<li value="4" class="calibre11"><p class="noindent">Combine the cipherletter mappings into a single mapping, which we’ll call an <em class="calibre7">intersected mapping</em>.</p></li>
<li value="5" class="calibre11"><p class="noindent">Remove any solved cipherletters from the combined mapping.</p></li>
<li value="6" class="calibre11"><p class="noindent">Decrypt the ciphertext with the solved cipherletters.</p></li></ol>
<p class="indent">The more cipherwords in a ciphertext, the more likely it is for the mappings to overlap with one another and the fewer the potential decryption letters for each cipherletter. This means that in the simple substitution cipher, <em class="calibre7">the longer the ciphertext message, the easier it is to hack</em>.</p>
<p class="indent">Before diving into the source code, let’s look at how we can make the first two steps of the hacking process easier. We’ll use the dictionary file we used in <a href="#calibre_link-28" class="calibre8">Chapter 11</a> and a module called <em class="calibre7">wordPatterns.py</em> to get the word pattern for every word in the dictionary file and sort them in a list.</p>
<h3 class="h1" id="calibre_link-695">The Word Pattern Modules</h3>
<p class="noindent">To calculate word patterns for every word in the <em class="calibre7">dictionary.txt</em> dictionary file, download <em class="calibre7">makeWordPatterns.py</em> from <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>. Make sure this program and <em class="calibre7">dictionary.txt</em> are both in the folder where you’ll be saving this chapter’s <em class="calibre7">simpleSubHacker.py</em> program.</p>
<p class="indent">The <em class="calibre7">makeWordPatterns.py</em> program has a <span class="literal">getWordPattern()</span> function that takes a string (such as <span class="literal">'puppy'</span>) and returns its word pattern (such as <span class="literal">'0.1.0.0.2'</span>). When you run <em class="calibre7">makeWordPatterns.py</em>, it should create the Python module <em class="calibre7">wordPatterns.py</em>. The module contains a single variable assignment statement, as shown here, and is more than 43,000 lines long:</p>
<p class="programs1">allPatterns = {'0.0.1': ['EEL'],<br class="calibre9" />&nbsp;'0.0.1.2': ['EELS', 'OOZE'],<br class="calibre9" />&nbsp;'0.0.1.2.0': ['EERIE'],<br class="calibre9" />&nbsp;'0.0.1.2.3': ['AARON', 'LLOYD', 'OOZED'],<br class="calibre9" />--<span class="codeitalic">snip</span>--</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-222"></span>The <span class="literal">allPatterns</span> variable contains a dictionary value with the word pattern strings as keys and a list of English words that match the pattern as its values. For example, to find all the English words with the pattern 0.1.2.1.3.4.5.4.6.7.8, enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import wordPatterns</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">wordPatterns.allPatterns['0.1.2.1.3.4.5.4.6.7.8']</span><br class="calibre9" />['BENEFICIARY', 'HOMOGENEITY', 'MOTORCYCLES']</p>
<p class="indent">In the <span class="literal">allPatterns</span> dictionary, the key <span class="literal">'0.1.2.1.3.4.5.4.6.7.8'</span> has the list value <span class="literal">['BENEFICIARY', 'HOMOGENEITY', 'MOTORCYCLES']</span>, which contains three English words with this particular word pattern.</p>
<p class="indent">Now let’s import the <em class="calibre7">wordPatterns.py</em> module to start building the simple substitution hacking program!</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">If you get a <span class="codeitalic">ModuleNotFoundError</span> error message when importing <span class="codeitalic">wordPatterns</span> into the interactive shell, enter the following into the interactive shell first:</em></p>
</div>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import sys</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">sys.path.append('</span><span class="codestrongitalic">name_of_folder</span><span class="codestrong">')</span></p>
<p class="indent"><em class="calibre7">Replace <span class="codeitalic">name_of_folder</span> with the location where</em> wordPatterns.py <em class="calibre7">is saved. This tells the interactive shell to look for modules in the folder you specify.</em></p>
<h3 class="h1" id="calibre_link-696">Source Code for the Simple Substitution Hacking Program</h3>
<p class="noindent">Open a file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and save it as <em class="calibre7">simpleSubHacker.py</em>. Be sure to place the <em class="calibre7">pyperclip.py</em>, <em class="calibre7">simpleSubCipher.py</em>, and <em class="calibre7">wordPatterns.py</em> files in the same directory as <em class="calibre7">simpleSubHacker.py</em>. Press F5 to run the program.</p>
<p class="noindentz"><em class="calibre7">simpleSub<br class="calibre9" />Hacker.py</em></p>
<p class="programs1">&nbsp;&nbsp;1. # Simple Substitution Cipher Hacker<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import os, re, copy, pyperclip, simpleSubCipher, wordPatterns,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeWordPatterns<br class="calibre9" />&nbsp;&nbsp;5.<br class="calibre9" />&nbsp;&nbsp;6.<br class="calibre9" />&nbsp;&nbsp;7.<br class="calibre9" />&nbsp;&nbsp;8.<br class="calibre9" />&nbsp;&nbsp;9.<br class="calibre9" />&nbsp;10. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br class="calibre9" />&nbsp;11. nonLettersOrSpacePattern = re.compile('[^A-Z\s]')<br class="calibre9" />&nbsp;12.<br class="calibre9" />&nbsp;13. def main():<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sxrjsxwjr, ia esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sr pqaceiamnsxu, ia esmm caytra jp famsaqa sj. Sy, px jia pjiac<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l calrpx ypc lwjsxu sx<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-950"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Facjclxo Ctrramm'<br class="calibre9" />&nbsp;15.<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the possible valid ciphertext translations:<br class="calibre9" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hacking...')<br class="calibre9" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping = hackSimpleSub(message)<br class="calibre9" />&nbsp;19.<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display the results to the user:<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Mapping:')<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(letterMapping)<br class="calibre9" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Original ciphertext:')<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(message)<br class="calibre9" />&nbsp;26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = decryptWithCipherletterMapping(message, letterMapping)<br class="calibre9" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />&nbsp;31.<br class="calibre9" />&nbsp;32.<br class="calibre9" />&nbsp;33. def getBlankCipherletterMapping():<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a dictionary value that is a blank cipherletter mapping:<br class="calibre9" />&nbsp;35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], 'G': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'H': [], 'I': [], 'J': [], 'K': [], 'L': [], 'M': [], 'N': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'O': [], 'P': [], 'Q': [], 'R': [], 'S': [], 'T': [], 'U': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'V': [], 'W': [], 'X': [], 'Y': [], 'Z': []}<br class="calibre9" />&nbsp;36.<br class="calibre9" />&nbsp;37.<br class="calibre9" />&nbsp;38. def addLettersToMapping(letterMapping, cipherword, candidate):<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The letterMapping parameter takes a dictionary value that<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# stores a cipherletter mapping, which is copied by the function.<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The cipherword parameter is a string value of the ciphertext word.<br class="calibre9" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The candidate parameter is a possible English word that the<br class="calibre9" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# cipherword could decrypt to.<br class="calibre9" />&nbsp;44.<br class="calibre9" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# This function adds the letters in the candidate as potential<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# decryption letters for the cipherletters in the cipherletter<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# mapping.<br class="calibre9" />&nbsp;48.<br class="calibre9" />&nbsp;49.<br class="calibre9" />&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(cipherword)):<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if candidate[i] not in letterMapping[cipherword[i]]:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherword[i]].append(candidate[i])<br class="calibre9" />&nbsp;53.<br class="calibre9" />&nbsp;54.<br class="calibre9" />&nbsp;55.<br class="calibre9" />&nbsp;56. def intersectMappings(mapA, mapB):<br class="calibre9" />&nbsp;57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# To intersect two maps, create a blank map and then add only the<br class="calibre9" />&nbsp;58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# potential decryption letters if they exist in BOTH maps:<br class="calibre9" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping = getBlankCipherletterMapping()<br class="calibre9" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in LETTERS:<br class="calibre9" />&nbsp;61.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-951"></span>&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# An empty list means "any letter is possible". In this case just<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# copy the other map entirely:<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mapA[letter] == []:<br class="calibre9" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter] = copy.deepcopy(mapB[letter])<br class="calibre9" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif mapB[letter] == []:<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter] = copy.deepcopy(mapA[letter])<br class="calibre9" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If a letter in mapA[letter] exists in mapB[letter],<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# add that letter to intersectedMapping[letter]:<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for mappedLetter in mapA[letter]:<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mappedLetter in mapB[letter]:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter].append(mappedLetter)<br class="calibre9" />&nbsp;74.<br class="calibre9" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return intersectedMapping<br class="calibre9" />&nbsp;76.<br class="calibre9" />&nbsp;77.<br class="calibre9" />&nbsp;78. def removeSolvedLettersFromMapping(letterMapping):<br class="calibre9" />&nbsp;79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Cipherletters in the mapping that map to only one letter are<br class="calibre9" />&nbsp;80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# "solved" and can be removed from the other letters.<br class="calibre9" />&nbsp;81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# For example, if 'A' maps to potential letters ['M', 'N'], and 'B'<br class="calibre9" />&nbsp;82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# maps to ['N'], then we know that 'B' must map to 'N', so we can<br class="calibre9" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# remove 'N' from the list of what 'A' could map to. So 'A' then maps<br class="calibre9" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# to ['M']. Note that now that 'A' maps to only one letter, we can<br class="calibre9" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# remove 'M' from the list of letters for every other letter.<br class="calibre9" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# (This is why there is a loop that keeps reducing the map.)<br class="calibre9" />&nbsp;87.<br class="calibre9" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = True<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while loopAgain:<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First assume that we will not loop again:<br class="calibre9" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = False<br class="calibre9" />&nbsp;92.<br class="calibre9" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# solvedLetters will be a list of uppercase letters that have one<br class="calibre9" />&nbsp;94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and only one possible mapping in letterMapping:<br class="calibre9" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solvedLetters = []<br class="calibre9" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solvedLetters.append(letterMapping[cipherletter][0])<br class="calibre9" />&nbsp;99.<br class="calibre9" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If a letter is solved, then it cannot possibly be a potential<br class="calibre9" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# decryption letter for a different ciphertext letter, so we<br class="calibre9" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# should remove it from those other lists:<br class="calibre9" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for s in solvedLetters:<br class="calibre9" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) != 1 and s in<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherletter]:<br class="calibre9" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherletter].remove(s)<br class="calibre9" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# A new letter is now solved, so loop again:<br class="calibre9" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = True<br class="calibre9" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return letterMapping<br class="calibre9" />111.<br class="calibre9" />112.<br class="calibre9" />113. def hackSimpleSub(message):<br class="calibre9" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMap = getBlankCipherletterMapping()<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-314"></span>115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipherwordList = nonLettersOrSpacePattern.sub('',<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.upper()).split()<br class="calibre9" />116.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherword in cipherwordList:<br class="calibre9" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get a new cipherletter mapping for each ciphertext word:<br class="calibre9" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidateMap = getBlankCipherletterMapping()<br class="calibre9" />119.<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wordPattern = makeWordPatterns.getWordPattern(cipherword)<br class="calibre9" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if wordPattern not in wordPatterns.allPatterns:<br class="calibre9" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue # This word was not in our dictionary, so continue.<br class="calibre9" />123.<br class="calibre9" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add the letters of each candidate to the mapping:<br class="calibre9" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for candidate in wordPatterns.allPatterns[wordPattern]:<br class="calibre9" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addLettersToMapping(candidateMap, cipherword, candidate)<br class="calibre9" />127.<br class="calibre9" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Intersect the new mapping with the existing intersected mapping:<br class="calibre9" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMap = intersectMappings(intersectedMap, candidateMap)<br class="calibre9" />130.<br class="calibre9" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Remove any solved letters from the other lists:<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return removeSolvedLettersFromMapping(intersectedMap)<br class="calibre9" />133.<br class="calibre9" />134.<br class="calibre9" />135. def decryptWithCipherletterMapping(ciphertext, letterMapping):<br class="calibre9" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a string of the ciphertext decrypted with the letter mapping,<br class="calibre9" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# with any ambiguous decrypted letters replaced with an underscore.<br class="calibre9" />138.<br class="calibre9" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First create a simple sub key from the letterMapping mapping:<br class="calibre9" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = ['x'] * len(LETTERS)<br class="calibre9" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" />143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If there's only one letter, add it to the key:<br class="calibre9" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyIndex = LETTERS.find(letterMapping[cipherletter][0])<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key[keyIndex] = cipherletter<br class="calibre9" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ciphertext.replace(cipherletter.lower(), '_')<br class="calibre9" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ciphertext.replace(cipherletter.upper(), '_')<br class="calibre9" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = ''.join(key)<br class="calibre9" />150.<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# With the key we've created, decrypt the ciphertext:<br class="calibre9" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return simpleSubCipher.decryptMessage(key, ciphertext)<br class="calibre9" />153.<br class="calibre9" />154.<br class="calibre9" />155. if __name__ == '__main__':<br class="calibre9" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-697">Sample Run of the Simple Substitution Hacking Program</h3>
<p class="noindent">When you run this program, it attempts to hack the ciphertext in the <span class="literal">message</span> variable. Its output should look like this:</p>
<p class="programs1">Hacking...<br class="calibre9" />Mapping:<br class="calibre9" />{'A': ['E'], 'B': ['Y', 'P', 'B'], 'C': ['R'], 'D': [], 'E': ['W'], 'F':<br class="calibre9" />['B', 'P'], 'G': ['B', 'Q', 'X', 'P', 'Y'], 'H': ['P', 'Y', 'K', 'X', 'B'],<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-307"></span>'I': ['H'], 'J': ['T'], 'K': [], 'L': ['A'], 'M': ['L'], 'N': ['M'], 'O':<br class="calibre9" />['D'], 'P': ['O'], 'Q': ['V'], 'R': ['S'], 'S': ['I'], 'T': ['U'], 'U': ['G'],<br class="calibre9" />'V': [], 'W': ['C'], 'X': ['N'], 'Y': ['F'], 'Z': ['Z']}<br class="calibre9" /><br class="calibre9" />Original ciphertext:<br class="calibre9" />Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr sxrjsxwjr, ia esmm<br class="calibre9" />rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa sr pqaceiamnsxu, ia esmm caytra<br class="calibre9" />jp famsaqa sj. Sy, px jia pjiac ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor<br class="calibre9" />l calrpx ypc lwjsxu sx lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax<br class="calibre9" />px jia rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh.<br class="calibre9" />-Facjclxo Ctrramm<br class="calibre9" /><br class="calibre9" />Copying hacked message to clipboard:<br class="calibre9" />If a man is offered a fact which goes against his instincts, he will<br class="calibre9" />scrutinize it closel_, and unless the evidence is overwhelming, he will refuse<br class="calibre9" />to _elieve it. If, on the other hand, he is offered something which affords<br class="calibre9" />a reason for acting in accordance to his instincts, he will acce_t it even<br class="calibre9" />on the slightest evidence. The origin of m_ths is e__lained in this wa_.<br class="calibre9" />-_ertrand Russell</p>
<p class="indent">Now let’s explore the source code in detail.</p>
<h3 class="h1" id="calibre_link-698">Setting Up Modules and Constants</h3>
<p class="noindent">Let’s look at the first few lines of the simple substitution hacking program. Line 4 imports seven different modules, more than any other program so far. The global variable <span class="literal">LETTERS</span> on line 10 stores the symbol set, which consists of the uppercase letters of the alphabet.</p>
<p class="programs1">&nbsp;&nbsp;1. # Simple Substitution Cipher Hacker<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import os, re, copy, pyperclip, simpleSubCipher, wordPatterns,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeWordPatterns<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;10. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</p>
<p class="indent">The <span class="literal">re</span> module is the regular expression module, which allows for sophisticated string manipulation using regular expressions. Let’s look at how regular expressions work.</p>
<h3 class="h1" id="calibre_link-49">Finding Characters with Regular Expressions</h3>
<p class="noindent"><em class="calibre7">Regular expressions</em> are strings that define a specific pattern that matches certain strings. For example, the string <span class="literal">'[^A-Z\s]'</span> on line 11 is a regular expression that tells Python to find any character that is not an uppercase letter from A to Z or a whitespace character (such as a space, tab, or newline character).</p>
<p class="programs1">&nbsp;11. nonLettersOrSpacePattern = re.compile('[^A-Z\s]')</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-282"></span>The <span class="literal">re.compile()</span> function creates a regular expression pattern object (abbreviated as <em class="calibre7">regex object</em> or <em class="calibre7">pattern object</em>) that the <span class="literal">re</span> module can use. We’ll use this object to remove any non-letter characters from the ciphertext in “<a href="#calibre_link-385" class="calibre8">The <span class="literal">hackSimpleSub()</span> Function</a>” on <a href="#calibre_link-385" class="calibre8">page 241</a>.</p>
<p class="indent">You can perform many sophisticated string manipulations with regular expressions. To learn more about regular expressions, go to <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<h3 class="h1" id="calibre_link-699">Setting Up the main() Function</h3>
<p class="noindent">As with the previous hacking programs in this book, the <span class="literal">main()</span> function stores the ciphertext in the <span class="literal">message</span> variable, and line 18 passes this variable to the <span class="literal">hackSimpleSub()</span> function:</p>
<p class="programs1">&nbsp;13. def main():<br class="calibre9" />&nbsp;14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = 'Sy l nlx sr pyyacao l ylwj eiswi upar lulsxrj isr<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sxrjsxwjr, ia esmm rwctjsxsza sj wmpramh, lxo txmarr jia aqsoaxwa<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sr pqaceiamnsxu, ia esmm caytra jp famsaqa sj. Sy, px jia pjiac<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ilxo, ia sr pyyacao rpnajisxu eiswi lyypcor l calrpx ypc lwjsxu sx<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lwwpcolxwa jp isr sxrjsxwjr, ia esmm lwwabj sj aqax px jia<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rmsuijarj aqsoaxwa. Jia pcsusx py nhjir sr agbmlsxao sx jisr elh.<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Facjclxo Ctrramm'<br class="calibre9" />&nbsp;15.<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the possible valid ciphertext translations:<br class="calibre9" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hacking...')<br class="calibre9" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping = hackSimpleSub(message)</p>
<p class="indent">Instead of returning the decrypted message or <span class="literal">None</span> if unable to decrypt it, <span class="literal">hackSimpleSub()</span> returns an intersected cipherletter mapping with the decrypted letters removed. (We’ll look at how to create an intersected mapping in “<a href="#calibre_link-386" class="calibre8">Intersecting Two Mappings</a>” on <a href="#calibre_link-386" class="calibre8">page 234</a>.) This intersected cipherletter mapping then gets passed to <span class="literal">decryptWithCipherletterMapping()</span> to decrypt the ciphertext stored in <span class="literal">message</span> into a readable format, as you’ll see in more detail in “<a href="#calibre_link-387" class="calibre8">Decrypting the Message</a>” on <a href="#calibre_link-387" class="calibre8">page 243</a>.</p>
<p class="indent">The cipherletter mapping stored in <span class="literal">letterMapping</span> is a dictionary value that has 26 uppercase single-letter strings as keys that represent the cipherletters. It also lists the uppercase letters of potential decryption letters for each cipherletter as the dictionary’s values. When every cipherletter has just one potential decryption letter associated with it, we have a fully solved mapping and can decrypt any ciphertext using the same cipher and key.</p>
<p class="indent">Each cipherletter mapping generated depends on the ciphertext used. In some cases, we’ll have only a partially solved mapping in which some cipherletters have no potential decryptions and other cipherletters have multiple potential decryptions. Shorter ciphertexts that don’t contain every letter of the alphabet are more likely to result in incomplete mappings.</p>
<h3 class="h1" id="calibre_link-700"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-163" class="calibre1"></span>Displaying Hacking Results to the User</h3>
<p class="noindent">The program then calls the <span class="literal">print()</span> function to display <span class="literal">letterMapping</span>, the original message, and the decrypted message on the screen:</p>
<p class="programs1">&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Display the results to the user:<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Mapping:')<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(letterMapping)<br class="calibre9" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Original ciphertext:')<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(message)<br class="calibre9" />&nbsp;26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = decryptWithCipherletterMapping(message, letterMapping)<br class="calibre9" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)</p>
<p class="indent">Line 28 stores the decrypted message in the variable <span class="literal">hackedMessage</span>, which is copied to the clipboard and printed to the screen so the user can compare it to the original message. We use <span class="literal">decryptWithCipherletterMapping()</span> to find the decrypted message, which is defined later in the program.</p>
<p class="indent">Next, let’s look at all the functions that create the cipherletter mappings.</p>
<h3 class="h1" id="calibre_link-701">Creating a Cipherletter Mapping</h3>
<p class="noindent">The program needs a cipherletter mapping for each cipherword in the ciphertext. To create a complete mapping, we’ll need several helper functions. One of those helper functions will set up a new cipherletter mapping so we can call it for every cipherword.</p>
<p class="indent">Another function will take a cipherword, its current letter mapping, and a candidate decryption word to find all the candidate decryption words. We’ll call this function for each cipherword and each candidate. The function will then add all the potential decryption letters from the candidate word to the cipherword’s letter mapping and return the letter mapping.</p>
<p class="indent">When we have letter mappings for several words from the ciphertext, we’ll use a function to merge them together. Then, we’ll use one final helper function to solve as many cipherletters’ decryptions as we can by matching one decryption letter to each cipherletter. As noted, we won’t always be able to solve all the cipherletters, but you’ll find out how to deal with this issue in “<a href="#calibre_link-387" class="calibre8">Decrypting the Message</a>” on <a href="#calibre_link-387" class="calibre8">page 243</a>.</p>
<h4 class="h2" id="calibre_link-702"><strong class="calibre3"><em class="calibre12">Creating a Blank Mapping</em></strong></h4>
<p class="noindent">First, we’ll need to create a blank cipherletter mapping.</p>
<p class="programs1">&nbsp;33. def getBlankCipherletterMapping():<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a dictionary value that is a blank cipherletter mapping:<br class="calibre9" />&nbsp;35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {'A': [], 'B': [], 'C': [], 'D': [], 'E': [], 'F': [], 'G': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'H': [], 'I': [], 'J': [], 'K': [], 'L': [], 'M': [], 'N': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'O': [], 'P': [], 'Q': [], 'R': [], 'S': [], 'T': [], 'U': [],<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'V': [], 'W': [], 'X': [], 'Y': [], 'Z': []}</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-165"></span>When called, the <span class="literal">getBlankCipherletterMapping()</span> function returns a dictionary with the keys set to one-character strings of the 26 letters of the alphabet.</p>
<h4 class="h2" id="calibre_link-703"><strong class="calibre3"><em class="calibre12">Adding Letters to a Mapping</em></strong></h4>
<p class="noindent">To add letters to a mapping, we define the <span class="literal">addLettersToMapping()</span> function on line 38.</p>
<p class="programs1">&nbsp;38. def addLettersToMapping(letterMapping, cipherword, candidate):</p>
<p class="indent">This function takes three parameters: a cipherletter mapping (<span class="literal">letterMapping</span>), a cipherword to map (<span class="literal">cipherword</span>), and a candidate decryption word the cipherword could decrypt to (<span class="literal">candidate</span>). The function maps every letter in <span class="literal">candidate</span> to the cipherletter at the corresponding index position in the <span class="literal">cipherword</span> and adds that letter to <span class="literal">letterMapping</span> if it isn’t already there.</p>
<p class="indent">For example, if <span class="literal">'PUPPY'</span> is the <span class="literal">candidate</span> for the <span class="literal">cipherword 'HGHHU'</span>, the <span class="literal">addLettersToMapping()</span> function adds the value <span class="literal">'P'</span> to the key <span class="literal">'H'</span> in <span class="literal">letterMapping</span>. Then the function moves to the next letter and appends <span class="literal">'U'</span> to the list value paired with the key <span class="literal">'G'</span>, and so on.</p>
<p class="indent">If the letter is already in the list of potential decryption letters, then <span class="literal">addLettersToMapping</span><span class="literal">()</span> doesn’t add that letter to the list again. For example, in <span class="literal">'PUPPY'</span> it would skip adding <span class="literal">'P'</span> to the <span class="literal">'H'</span> key for the next two instances of <span class="literal">'P'</span> because it’s already there. Finally, the function changes the value for key <span class="literal">'U'</span> so it has <span class="literal">'Y'</span> in its list of potential decryption letters.</p>
<p class="indent">The code in <span class="literal">addLettersToMapping()</span> assumes that <span class="literal">len(cipherword)</span> is the same as <span class="literal">len(candidate)</span> because we should only pass a <span class="literal">cipherword</span> and <span class="literal">candidate</span> pair with matching word patterns.</p>
<p class="indent">Then the program iterates over each index in the string in <span class="literal">cipherword</span> to check if a letter has already been added to the list of potential decryption letters:</p>
<p class="programs1">&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(cipherword)):<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if candidate[i] not in letterMapping[cipherword[i]]:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherword[i]].append(candidate[i])</p>
<p class="indent">We’ll use the variable <span class="literal">i</span> to iterate through each letter of <span class="literal">cipherword</span> and its corresponding potential decryption letter in <span class="literal">candidate</span> through indexing. We can do this because the potential decryption letter to be added is <span class="literal">candidate[i]</span> for the cipherletter <span class="literal">cipherword[i]</span>. For example, if the <span class="literal">cipherword</span> was <span class="literal">'HGHHU'</span> and the <span class="literal">candidate</span> was <span class="literal">'PUPPY'</span>, <span class="literal">i</span> would start at index <span class="literal">0</span>, and we would use <span class="literal">cipherword[0]</span> and <span class="literal">candidate[0]</span> to access the first letters in each string. Then the execution would move on to the <span class="literal">if</span> statement on line 51.</p>
<p class="indent">The <span class="literal">if</span> statement checks that the potential decryption letter, <span class="literal">candidate[i]</span>, is not already in the list of potential decryption letters for the cipherletter <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-132"></span>and doesn’t add it if it’s already in the list. It does this by accessing the cipherletter in the mapping with <span class="literal">letterMapping[cipherword[i]]</span>, because <span class="literal">cipherword[i]</span> is the key in <span class="literal">letterMapping</span> that needs to be accessed. This check prevents duplicate letters in the list of potential decryption letters.</p>
<p class="indent">For example, the first <span class="literal">'P'</span> in <span class="literal">'PUPPY'</span> might be added to the <span class="literal">letterMapping</span> at the first iteration of the loop, but when <span class="literal">i</span> is equal to <span class="literal">2</span> in the third iteration, the <span class="literal">'P'</span> from <span class="literal">candidate[2]</span> wouldn’t be added to the mapping because it was already added at the first iteration.</p>
<p class="indent">If the potential decryption letter isn’t already in the mapping, line 52 adds the new letter, <span class="literal">candidate[i]</span>, to the list of potential decryption letters in the cipherletter mapping at <span class="literal">letterMapping[cipherword[i]]</span>.</p>
<p class="indent">Recall that because Python passes a copy of the reference to a dictionary passed for the parameter, instead of a copy of the dictionary itself, any changes made to <span class="literal">letterMapping</span> in this function will be done outside the <span class="literal">addLettersToMapping()</span> function as well. This is because both copies of the reference still refer to the same dictionary passed for the <span class="literal">letterMapping</span> parameter in the call to <span class="literal">addLettersToMapping()</span> on line 126.</p>
<p class="indent">After looping through all the indexes in <span class="literal">cipherword</span>, the function is done adding letters to the mapping in the <span class="literal">letterMapping</span> variable. Now let’s look at how the program compares this mapping to that of other cipherwords to check for overlaps.</p>
<h4 class="h2" id="calibre_link-386"><strong class="calibre3"><em class="calibre12">Intersecting Two Mappings</em></strong></h4>
<p class="noindent">The <span class="literal">hackSimpleSub()</span> function uses the <span class="literal">intersectMappings()</span> function to take two cipherletter mappings passed as its <span class="literal">mapA</span> and <span class="literal">mapB</span> parameters and return a merged mapping of <span class="literal">mapA</span> and <span class="literal">mapB</span>. The <span class="literal">intersectMappings()</span> function instructs the program to combine <span class="literal">mapA</span> and <span class="literal">mapB</span>, create a blank map, and then add the potential decryption letters to the blank map only if they exist in <em class="calibre7">both</em> maps to prevent duplicates.</p>
<p class="programs1">&nbsp;56. def intersectMappings(mapA, mapB):<br class="calibre9" />&nbsp;57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# To intersect two maps, create a blank map and then add only the<br class="calibre9" />&nbsp;58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# potential decryption letters if they exist in BOTH maps:<br class="calibre9" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping = getBlankCipherletterMapping()</p>
<p class="indent">First, line 59 creates a cipherletter mapping to store the merged mapping by calling <span class="literal">getBlankCipherletterMapping()</span> and storing the returned value in the <span class="literal">intersectedMapping</span> variable.</p>
<p class="indent">The <span class="literal">for</span> loop on line 60 loops through the uppercase letters in the <span class="literal">LETTERS</span> constant variable and uses the <span class="literal">letter</span> variable as the keys of the <span class="literal">mapA</span> and <span class="literal">mapB</span> dictionaries:</p>
<p class="programs1">&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for letter in LETTERS:<br class="calibre9" />&nbsp;61.<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# An empty list means "any letter is possible". In this case just<br class="calibre9" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# copy the other map entirely:<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mapA[letter] == []:<br class="calibre9" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter] = copy.deepcopy(mapB[letter])<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-166"></span>&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif mapB[letter] == []:<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter] = copy.deepcopy(mapA[letter])</p>
<p class="indent">Line 64 checks whether the list of potential decryption letters for <span class="literal">mapA</span> is blank. A blank list means that this cipherletter could potentially decrypt to <em class="calibre7">any</em> letter. In this case, the intersected cipherletter mapping just copies the <em class="calibre7">other</em> mapping’s list of potential decryption letters. For example, if the list of potential decryption letters in <span class="literal">mapA</span> is blank, then line 65 sets the intersected mapping’s list to be a copy of the list in <span class="literal">mapB</span>, and vice versa on line 67. Note that if both mappings’ lists are blank, the condition on line 64 is still <span class="literal">True</span>, and then line 65 simply copies the blank list in <span class="literal">mapB</span> to the intersected mapping.</p>
<p class="indent">The <span class="literal">else</span> block on line 68 handles the case in which neither <span class="literal">mapA</span> nor <span class="literal">mapB</span> is blank:</p>
<p class="programs1">&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If a letter in mapA[letter] exists in mapB[letter],<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# add that letter to intersectedMapping[letter]:<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for mappedLetter in mapA[letter]:<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if mappedLetter in mapB[letter]:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMapping[letter].append(mappedLetter)<br class="calibre9" />&nbsp;74.<br class="calibre9" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return intersectedMapping</p>
<p class="indent">When the maps are not blank, line 71 loops through the uppercase letter strings in the list at <span class="literal">mapA[letter]</span>. Line 72 checks whether the uppercase letter in <span class="literal">mapA[letter]</span> also exists in the list of uppercase letter strings in <span class="literal">mapB[letter]</span>. If it does, then <span class="literal">intersectedMapping[letter]</span> on line 73 adds this common letter to the list of potential decryption letters.</p>
<p class="indent">After the <span class="literal">for</span> loop that started on line 60 has finished, the cipherletter mapping in <span class="literal">intersectedMapping</span> should only have the potential decryption letters that exist in the lists of potential decryption letters of both <span class="literal">mapA</span> and <span class="literal">mapB</span>. Line 75 returns this completely intersected cipherletter mapping. Next, let’s look at an example output of an intersected mapping.</p>
<h4 class="h2" id="calibre_link-388"><strong class="calibre3"><em class="calibre12">How the Letter-Mapping Helper Functions Work</em></strong></h4>
<p class="noindent">Now that we’ve defined the letter-mapping helper functions, let’s try using them in the interactive shell to better understand how they work together. Let’s create an intersected cipherletter map for the ciphertext <span class="literal">'OLQIHXIRCKGNZ&nbsp;&nbsp;PLQRZKBZB&nbsp;&nbsp;MPBKSSIPLC'</span>, which contains just three cipherwords. We’ll do this by creating a mapping for each word and then combining the mappings.</p>
<p class="indent">Import <em class="calibre7">simpleSubHacker.py</em> into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import simpleSubHacker</span></p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-952"></span>Next, we call <span class="literal">getBlankCipherletterMapping()</span> to create a blank letter mapping and store this mapping in a variable named <span class="literal">letterMapping1</span>:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping1 = simpleSubHacker.getBlankCipherletterMapping()</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">letterMapping1</span><br class="calibre9" />{'A': [], 'C': [], 'B': [], 'E': [], 'D': [], 'G': [], 'F': [], 'I': [],<br class="calibre9" />'H': [], 'K': [], 'J': [], 'M': [], 'L': [], 'O': [], 'N': [], 'Q': [],<br class="calibre9" />'P': [], 'S': [], 'R': [], 'U': [], 'T': [], 'W': [], 'V': [], 'Y': [],<br class="calibre9" />'X': [], 'Z': []}</p>
<p class="indent">Let’s start hacking the first cipherword, <span class="literal">'OLQIHXIRCKGNZ'</span>. First, we need to get the word pattern for this cipherword by calling the <span class="literal">makeWordPattern</span> module’s <span class="literal">getWordPattern()</span> function, as shown here:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import makeWordPatterns</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">makeWordPatterns.getWordPattern('OLQIHXIRCKGNZ')</span><br class="calibre9" />0.1.2.3.4.5.3.6.7.8.9.10.11</p>
<p class="indent">To figure out which English words in the dictionary have the word pattern 0.1.2.3.4.5.3.6.7.8.9.10.11 (that is, to figure out the candidates for the cipherword <span class="literal">'OLQIHXIRCKGNZ')</span>, we import the <span class="literal">wordPatterns</span> module and look up this pattern:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import wordPatterns</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">candidates = wordPatterns.allPatterns['0.1.2.3.4.5.3.6.7.8.9.10.11']</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">candidates</span><br class="calibre9" />['UNCOMFORTABLE', 'UNCOMFORTABLY']</p>
<p class="indent">Two English words match the word pattern for <span class="literal">'OLQIHXIRCKGNZ'</span>; therefore, the only two words the first cipherword could decrypt to are <span class="literal">'UNCOMFORTABLE'</span> and <span class="literal">'UNCOMFORTABLY'</span>. These words are our candidates, so we’ll store them in the <span class="literal">candidates</span> variable (not to be confused with the <span class="literal">candidate</span> parameter in the <span class="literal">addLettersToMapping()</span> function) as a list.</p>
<p class="indent">Next, we need to map their letters to the <span class="literal">cipherword</span>’s letters using <span class="literal">addLettersToMapping()</span>. First, we’ll map <span class="literal">'UNCOMFORTABLE'</span> by accessing the first member of the <span class="literal">candidates</span> list, like so:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping1 = simpleSubHacker.addLettersToMapping(letterMapping1,<br class="calibre9" />'OLQIHXIRCKGNZ', candidates[0])</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">letterMapping1</span><br class="calibre9" />{'A': [], 'C': ['T'], 'B': [], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I':<br class="calibre9" />['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'], 'N':<br class="calibre9" />['L'], 'Q': ['C'], 'P': [], 'S': [], 'R': ['R'], 'U': [], 'T': [], 'W': [],<br class="calibre9" />'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>
<p class="indent">From the <span class="literal">letterMapping1</span> value, you can see that the letters in <span class="literal">'OLQIHXIRCKGNZ'</span> map to the letters in <span class="literal">'UNCOMFORTABLE'</span>: <span class="literal">'O'</span> maps to <span class="literal">['U']</span>, <span class="literal">'L'</span> maps to <span class="literal">['N']</span>, <span class="literal">'Q'</span> maps to <span class="literal">['C']</span>, and so on.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-953"></span>But because the letters in <span class="literal">'OLQIHXIRCKGNZ'</span> could also possibly decrypt to <span class="literal">'</span><span class="literal">UNCOMFORTABLY'</span>, we also need to add it to the cipherletter mapping. Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping1 = simpleSubHacker.addLettersToMapping(letterMapping1,<br class="calibre9" />'OLQIHXIRCKGNZ', candidates[1])</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">letterMapping1</span><br class="calibre9" />{'A': [], 'C': ['T'], 'B': [], 'E': [], 'D': [], 'G': ['B'], 'F': [],<br class="calibre9" />'I': ['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'],<br class="calibre9" />'N': ['L'], 'Q': ['C'], 'P': [], 'S': [], 'R': ['R'], 'U': [], 'T': [],<br class="calibre9" />'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E', 'Y']}</p>
<p class="indent">Notice that not much has changed in <span class="literal">letterMapping1</span> except the cipherletter mapping in <span class="literal">letterMapping1</span> now has <span class="literal">'Z'</span> map to <span class="literal">'Y'</span> in addition to <span class="literal">'E'</span>. That’s because <span class="literal">addLettersToMapping()</span> adds the letter to the list only if the letter is not already there.</p>
<p class="indent">Now we have a cipherletter mapping for the first of the three cipher&shy;words. We need to get a new mapping for the second cipherword, <span class="literal">'PLQRZKBZB</span>’, and repeat the process:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping2 = simpleSubHacker.getBlankCipherletterMapping()</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">wordPat = makeWordPatterns.getWordPattern('PLQRZKBZB')</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">candidates = wordPatterns.allPatterns[wordPat]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">candidates</span><br class="calibre9" />['CONVERSES', 'INCREASES', 'PORTENDED', 'UNIVERSES']<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">for candidate in candidates:</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">letterMapping2 = simpleSubHacker.addLettersToMapping(letterMapping2,<br class="calibre9" />'PLQRZKBZB', candidate)</span><br class="calibre9" />...<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">letterMapping2</span><br class="calibre9" />{'A': [], 'C': [], 'B': ['S', 'D'], 'E': [], 'D': [], 'G': [], 'F': [], 'I':<br class="calibre9" />[], 'H': [], 'K': ['R', 'A', 'N'], 'J': [], 'M': [], 'L': ['O', 'N'], 'O': [],<br class="calibre9" />'N': [], 'Q': ['N', 'C', 'R', 'I'], 'P': ['C', 'I', 'P', 'U'], 'S': [], 'R':<br class="calibre9" />['V', 'R', 'T'], 'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': [], 'Z':<br class="calibre9" />['E']}</p>
<p class="indent">Instead of entering four calls to <span class="literal">addLettersToMapping()</span> for each of these four candidate words, we can write a <span class="literal">for</span> loop that goes through the list in <span class="literal">candidates</span> and calls <span class="literal">addLettersToMapping()</span> on each of them. This finishes the cipherletter mapping for the second cipherword.</p>
<p class="indent">Next, we need to get the intersection of the cipherletter mappings in <span class="literal">letterMapping1</span> and <span class="literal">letterMapping2</span> by passing them to <span class="literal">intersectMappings()</span>. Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">intersectedMapping = simpleSubHacker.intersectMappings(letterMapping1,<br class="calibre9" />letterMapping2)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">intersectedMapping</span><br class="calibre9" />{'A': [], 'C': ['T'], 'B': ['S', 'D'], 'E': [], 'D': [], 'G': ['B'], 'F': [],<br class="calibre9" />'I': ['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': [], 'L': ['N'], 'O': ['U'],<br class="calibre9" />'N': ['L'], 'Q': ['C'], 'P': ['C', 'I', 'P', 'U'], 'S': [], 'R': ['R'],<br class="calibre9" />'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-954"></span>Now the list of potential decryption letters for any cipherletter in the intersected mapping should be only the potential decryption letters that are in <em class="calibre7">both</em> <span class="literal">letterMapping1</span> and <span class="literal">letterMapping2</span>.</p>
<p class="indent">For example, the list in <span class="literal">intersectedMapping</span> for the <span class="literal">'Z'</span> key is just <span class="literal">['E']</span> because <span class="literal">letterMapping1</span> had <span class="literal">['E',</span> <span class="literal">'Y']</span> but <span class="literal">letterMapping2</span> had only <span class="literal">['E']</span>.</p>
<p class="indent">Next, we repeat all the preceding steps for the third cipherword, <span class="literal">'MPBKSSIPLC'</span>, as follows:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping3 = simpleSubHacker.getBlankCipherletterMapping()</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">wordPat = makeWordPatterns.getWordPattern('MPBKSSIPLC')</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">candidates = wordPatterns.allPatterns[wordPat]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">for i in range(len(candidates)):</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">letterMapping3 = simpleSubHacker.addLettersToMapping(letterMapping3,<br class="calibre9" />'MPBKSSIPLC', candidates[i])</span><br class="calibre9" />...<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">letterMapping3</span><br class="calibre9" />{'A': [], 'C': ['Y', 'T'], 'B': ['M', 'S'], 'E': [], 'D': [], 'G': [],<br class="calibre9" />'F': [], 'I': ['E', 'O'], 'H': [], 'K': ['I', 'A'], 'J': [], 'M': ['A', 'D'],<br class="calibre9" />'L': ['L', 'N'], 'O': [], 'N': [], 'Q': [], 'P': ['D', 'I'], 'S': ['T', 'P'],<br class="calibre9" />'R': [], 'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': [], 'Z': []}</p>
<p class="indent">Enter the following into the interactive shell to intersect <span class="literal">letterMapping3</span> with <span class="literal">intersectedMapping</span>, which is the intersected mapping of <span class="literal">letterMapping1</span> and <span class="literal">letterMapping2</span>:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">intersectedMapping = simpleSubHacker.intersectMappings(intersectedMapping,<br class="calibre9" />letterMapping3)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">intersectedMapping</span><br class="calibre9" />{'A': [], 'C': ['T'], 'B': ['S'], 'E': [], 'D': [], 'G': ['B'], 'F': [],<br class="calibre9" />'I': ['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': ['A', 'D'], 'L': ['N'],<br class="calibre9" />'O': ['U'], 'N': ['L'], 'Q': ['C'], 'P': ['I'], 'S': ['T', 'P'], 'R': ['R'],<br class="calibre9" />'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>
<p class="indent">In this example, we’re able to find solutions for the keys that have only one value in their list. For example, <span class="literal">'K'</span> decrypts to <span class="literal">'A'</span>. But notice that key <span class="literal">'M'</span> could decrypt to <span class="literal">'A'</span> or <span class="literal">'</span><span class="literal">D'</span>. Because we know that <span class="literal">'K'</span> decrypts to <span class="literal">'A'</span>, we can deduce that key <span class="literal">'M'</span> must decrypt to <span class="literal">'D'</span>, not <span class="literal">'A'</span>. After all, if the solved letter is used by one cipherletter, it can’t be used by another cipherletter, because the simple substitution cipher encrypts a plaintext letter to exactly one cipherletter.</p>
<p class="indent">Let’s look at how the <span class="literal">removeSolvedLettersFromMapping()</span> function finds these solved letters and removes them from the list of potential decryption letters. We’ll need the <span class="literal">intersectedMapping</span> we just created, so don’t close the IDLE window just yet.</p>
<h4 class="h2" id="calibre_link-704"><strong class="calibre3"><em class="calibre12">Identifying Solved Letters in Mappings</em></strong></h4>
<p class="noindent">The <span class="literal">removeSolvedLettersFromMapping()</span> function searches for any cipher&shy;letters in the <span class="literal">letterMapping</span> parameter that have only one potential decryption letter. These cipherletters are considered solved, which means that any other cipherletters with this solved letter in their list of potential decryption <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-955"></span>letters can’t possibly decrypt to this letter. This could cause a chain reaction, because when one potential decryption letter is removed from other lists of potential decryption letters holding just two letters, the result could be a new solved cipherletter. The program handles this situation by looping and removing the newly solved letter from the entire cipherletter mapping.</p>
<p class="programs1">&nbsp;78. def removeSolvedLettersFromMapping(letterMapping):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = True<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while loopAgain:<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First assume that we will not loop again:<br class="calibre9" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = False</p>
<p class="indent">Because a reference to a dictionary is passed for the <span class="literal">letterMapping</span> parameter, that dictionary will contain the changes made in the function <span class="literal">removeSolvedLettersFromMapping()</span> even after the function returns. Line 88 creates <span class="literal">loopAgain</span>, a variable that holds a Boolean value, which determines whether the code needs to loop again when it finds another solved letter.</p>
<p class="indent">If the <span class="literal">loopAgain</span> variable is set to <span class="literal">True</span> on line 88, the program execution enters the <span class="literal">while</span> loop on line 89. At the beginning of the loop, line 91 sets <span class="literal">loopAgain</span> to <span class="literal">False</span>. The code assumes that this is the last iteration through the <span class="literal">while</span> loop on line 89. The <span class="literal">loopAgain</span> variable is only set to <span class="literal">True</span> if the program finds a new solved cipherletter during this iteration.</p>
<p class="indent">The next part of the code creates a list of cipherletters that have exactly one potential decryption letter. These are the solved letters that will be removed from the mapping.</p>
<p class="programs1">&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# solvedLetters will be a list of uppercase letters that have one<br class="calibre9" />&nbsp;94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# and only one possible mapping in letterMapping:<br class="calibre9" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solvedLetters = []<br class="calibre9" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solvedLetters.append(letterMapping[cipherletter][0])</p>
<p class="indent">The <span class="literal">for</span> loop on line 96 goes through all 26 possible cipherletters and looks at the cipherletter mapping’s list of potential decryption letters for that cipherletter (that is, the list at <span class="literal">letterMapping[cipherletter]</span>).</p>
<p class="indent">Line 97 checks whether the length of this list is <span class="literal">1</span>. If it is, we know there’s only one letter that the cipherletter could decrypt to and the cipherletter is solved. Line 98 adds the solved decryption letter to the <span class="literal">solvedLetters</span> list. The solved letter is always at <span class="literal">letterMapping[cipherletter][0]</span> because <span class="literal">letterMapping[cipherletter]</span> is a list of potential decryption letters that has only one string value in it at index <span class="literal">0</span> of the list.</p>
<p class="indent">After the previous <span class="literal">for</span> loop that started on line 96 has finished, the <span class="literal">solvedLetters</span> variable should contain a list of all the decryptions of a cipherletter. Line 98 stores these decrypted strings in <span class="literal">solvedLetters</span> as a list.</p>
<p class="indent">At this point, the program is done identifying all the solved letters. Then it checks whether they’re listed as potential decryption letters for other cipherletters and removes them.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-956"></span>To do this, the <span class="literal">for</span> loop on line 103 loops through all 26 possible cipherletters and looks at the cipherletter mapping’s list of potential decryption letters.</p>
<p class="programs1">103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for s in solvedLetters:<br class="calibre9" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) != 1 and s in<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherletter]:<br class="calibre9" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letterMapping[cipherletter].remove(s)<br class="calibre9" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# A new letter is now solved, so loop again:<br class="calibre9" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopAgain = True<br class="calibre9" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return letterMapping</p>
<p class="indent">For each cipherletter examined, line 104 loops through the letters in <span class="literal">solvedLetters</span> to check whether any of them exists in the list of potential decryption letters for <span class="literal">letterMapping[cipherletter]</span>.</p>
<p class="indent">Line 105 checks whether a list of potential decryption letters isn’t solved by checking whether <span class="literal">len(letterMapping[cipherletter]) != 1</span> <em class="calibre7">and</em> by checking whether the solved letter exists in the list of potential decryption letters. If both criteria are met, this condition returns <span class="literal">True</span>, and line 106 removes the solved letter in <span class="literal">s</span> from the list of potential decryption letters.</p>
<p class="indent">If this removal leaves only one letter in the list of potential decryption letters, line 109 sets the <span class="literal">loopAgain</span> variable to <span class="literal">True</span> so the code can remove this newly solved letter from the cipherletter mapping on the next iteration of the loop.</p>
<p class="indent">After the <span class="literal">while</span> loop on line 89 has gone through a full iteration without <span class="literal">loopAgain</span> being set to <span class="literal">True</span>, the program moves beyond the loop and line 110 returns the cipherletter mapping stored in <span class="literal">letterMapping</span>.</p>
<p class="indent">The variable <span class="literal">letterMapping</span> should now contain a partially or potentially fully solved cipherletter mapping.</p>
<h4 class="h2" id="calibre_link-705"><strong class="calibre3"><em class="calibre12">Testing the removeSolvedLetterFromMapping() Function</em></strong></h4>
<p class="noindent">Let’s see <span class="literal">removeSolvedLetterFromMapping()</span> in action by testing it in the inter&shy;active shell. Return to the interactive shell window you had open when you created <span class="literal">intersectedMapping</span>. (If you closed the window, don’t worry; you can just reenter the instructions in “<a href="#calibre_link-388" class="calibre8">How the Letter-Mapping Helper Functions Work</a>” on <a href="#calibre_link-388" class="calibre8">page 235</a> and then follow along with this example.)</p>
<p class="indent">To remove the solved letters from <span class="literal">intersectedMapping</span>, enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">letterMapping = simpleSubHacker.removeSolvedLettersFromMapping(<br class="calibre9" />intersectedMapping)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">intersectedMapping</span><br class="calibre9" />{'A': [], 'C': ['T'], 'B': ['S'], 'E': [], 'D': [], 'G': ['B'], 'F': [],<br class="calibre9" />'I': ['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': ['D'], 'L': ['N'], 'O':<br class="calibre9" />['U'], 'N': ['L'], 'Q': ['C'], 'P': ['I'], 'S': ['P'], 'R': ['R'], 'U': [],<br class="calibre9" />'T': [], 'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-164"></span>When you remove the solved letters from <span class="literal">intersectedMapping</span>, notice that <span class="literal">'M'</span> now has just one potential decryption letter, <span class="literal">'D'</span>, which is what we predicted would be the case. Now each cipherletter has just one potential decryption letter, so we can use the cipherletter mapping to start decrypting. We’ll need to return to this interactive shell example one more time, so keep its window open.</p>
<h3 class="h1" id="calibre_link-385">The hackSimpleSub() Function</h3>
<p class="noindent">Now that you’ve seen how the functions <span class="literal">getBlankCipherletterMapping()</span>, <span class="literal">addLettersToMapping</span><span class="literal">()</span>, <span class="literal">intersectMappings()</span>, and <span class="literal">removeSolvedLettersFromMapping()</span> manipulate the cipherletter mappings you pass them, let’s use them in our <em class="calibre7">simpleSubHacker.py</em> program to decrypt a message.</p>
<p class="indent">Line 113 defines the <span class="literal">hackSimpleSub()</span> function, which takes a ciphertext message and uses the letter-mapping helper functions to return a partially or fully solved cipherletter mapping:</p>
<p class="programs1">113. def hackSimpleSub(message):<br class="calibre9" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMap = getBlankCipherletterMapping()<br class="calibre9" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cipherwordList = nonLettersOrSpacePattern.sub('', <br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message.upper()).split()</p>
<p class="indent">On line 114, we create a new cipher&shy;letter mapping that we store in the <span class="literal">intersectedMap</span> variable. This variable will eventually hold the intersected mappings of each of the cipherwords.</p>
<p class="indent">On line 115, we remove any non-letter characters from <span class="literal">message</span>. The regex object in <span class="literal">nonLettersOrSpacePattern</span> matches any string that isn’t a letter or whitespace character. The <span class="literal">sub()</span> method is called on a regular expression and takes two arguments. The function searches the string in the second argument for matches, and it replaces those matches with the string in the first argument. Then it returns a string with all these replacements. In this example, the <span class="literal">sub()</span> method tells the program to go through the uppercased <span class="literal">message</span> string and replace all the non-letter characters with a blank string (<span class="literal">''</span>). This makes <span class="literal">sub()</span> return a string with all punctuation and number characters removed, and this string is stored in the <span class="literal">cipherwordList</span> variable.</p>
<p class="indent">After line 115 executes, the <span class="literal">cipherwordList</span> variable should contain a list of uppercase strings of the individual cipherwords previously in <span class="literal">message</span>.</p>
<p class="indent">The <span class="literal">for</span> loop on line 116 assigns each string in the <span class="literal">message</span> list to the <span class="literal">cipherword</span> variable. Inside this loop, the code creates a blank map, gets the cipherword’s candidates, adds the candidates’ letters to a cipherletter mapping, and then intersects this mapping with <span class="literal">intersectedMap</span>.</p>
<p class="programs1">116.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherword in cipherwordList:<br class="calibre9" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Get a new cipherletter mapping for each ciphertext word:<br class="calibre9" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;candidateMap = getBlankCipherletterMapping()<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wordPattern = makeWordPatterns.getWordPattern(cipherword)<br class="calibre9" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if wordPattern not in wordPatterns.allPatterns:<br class="calibre9" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue # This word was not in our dictionary, so continue.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-957"></span>124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add the letters of each candidate to the mapping:<br class="calibre9" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for candidate in wordPatterns.allPatterns[wordPattern]:<br class="calibre9" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addLettersToMapping(candidateMap, cipherword, candidate)<br class="calibre9" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Intersect the new mapping with the existing intersected mapping:<br class="calibre9" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intersectedMap = intersectMappings(intersectedMap, candidateMap)</p>
<p class="indent">Line 118 gets a new, blank cipherletter mapping from the function <span class="literal">getBlankCipherletterMapping</span><span class="literal">()</span> and stores it in the <span class="literal">candidateMap</span> variable.</p>
<p class="indent">To find the candidates for the current cipherword, line 120 calls <span class="literal">getWordPattern</span><span class="literal">()</span> in the <span class="literal">makeWordPatterns</span> module. In some cases, the cipherword may be a name or a very uncommon word that doesn’t exist in the dictionary, in which case, its word pattern likely won’t exist in <span class="literal">wordPatterns</span> either. If the word pattern of the cipherword doesn’t exist in the keys of the <span class="literal">wordPatterns.allPatterns</span> dictionary, the original plaintext word doesn’t exist in the dictionary file. In that case, the cipherword doesn’t get a mapping, and the <span class="literal">continue</span> statement on line 122 returns to the next cipherword in the list on line 116.</p>
<p class="indent">If the execution reaches line 125, we know the word pattern exists in <span class="literal">wordPatterns.allPatterns</span>. The values in the <span class="literal">allPatterns</span> dictionary are lists of strings of the English words with the pattern in <span class="literal">wordPattern</span>. Because the values are in the form of a list, we use a <span class="literal">for</span> loop to iterate over them. The variable <span class="literal">candidate</span> is set to each of these English word strings on each iteration of the loop.</p>
<p class="indent">The <span class="literal">for</span> loop on line 125 calls <span class="literal">addLettersToMapping()</span> on line 126 to update the cipherletter mapping in <span class="literal">candidateMap</span> using the letters in each of the candidates. The <span class="literal">addLettersToMapping()</span> function modifies the list directly, so <span class="literal">candidateMap</span> is modified by the time the function call returns.</p>
<p class="indent">After all the letters in the candidates are added to the cipherletter mapping in <span class="literal">candidateMap</span>, line 129 intersects <span class="literal">candidateMap</span> with <span class="literal">intersectedMap</span> and returns the new value of <span class="literal">intersectedMap</span>.</p>
<p class="indent">At this point, the program execution returns to the beginning of the <span class="literal">for</span> loop on line 116 to create a new mapping for the next cipherword in the <span class="literal">cipherwordList</span> list, and the mapping for the next cipherword is also intersected with <span class="literal">intersectedMap</span>. The loop continues mapping cipherwords until it reaches the last word in <span class="literal">cipherWordList</span>.</p>
<p class="indent">When we have the final intersected cipherletter mapping that contains the mappings of all the cipherwords in the ciphertext, we pass it to <span class="literal">removeSolvedLettersFromMapping</span><span class="literal">()</span> on line 132 to remove any solved letters.</p>
<p class="programs1">131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Remove any solved letters from the other lists:<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return removeSolvedLettersFromMapping(intersectedMap)</p>
<p class="indent">The cipherletter mapping returned from <span class="literal">removeSolvedLettersFromMapping</span><span class="literal">()</span> is then returned for the <span class="literal">hackSimpleSub()</span> function. Now we have part of the cipher’s solution, so we can start decrypting the message.</p>
<h4 class="h2" id="calibre_link-706"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-308" class="calibre1"></span><strong class="calibre3"><em class="calibre12">The replace() String Method</em></strong></h4>
<p class="noindent">The <span class="literal">replace()</span> string method returns a new string with replaced characters. The first argument is the substring to look for, and the second argument is the string to replace those substrings with. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">'mississippi'.replace('s', 'X')</span><br class="calibre9" />'miXXiXXippi'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">'dog'.replace('d', 'bl')</span><br class="calibre9" />'blog'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">'jogger'.replace('ger', 's')</span><br class="calibre9" />'jogs'</p>
<p class="indent">We’ll use the <span class="literal">replace()</span> string method in <span class="literal">decryptMessage()</span> in the <em class="calibre7">simpleSubHacker.py</em> program.</p>
<h4 class="h2" id="calibre_link-387"><strong class="calibre3"><em class="calibre12">Decrypting the Message</em></strong></h4>
<p class="noindent">To decrypt our message, we’ll use the function <span class="literal">simpleSubstitutionCipher</span><span class="literal">.decryptMessage()</span> that we already programmed in <em class="calibre7">simpleSubstitutionCipher.py</em>. But <span class="literal">simpleSubstitutionCipher.decryptMessage()</span> decrypts using keys only, not letter mappings, so we can’t use the function directly. To address this issue, we’ll create a <span class="literal">decryptWithCipherletterMapping()</span> function that takes a letter mapping, converts the mapping into a key, and then passes the key and message to <span class="literal">simpleSubstitutionCipher.decryptMessage()</span>. The function <span class="literal">decryptWithCipherletterMapping()</span> will return a decrypted string. Recall that the simple substitution keys are strings of 26 characters and the character at index <span class="literal">0</span> in the key string is the encrypted character for A, the character at index <span class="literal">1</span> is the encrypted character for B, and so on.</p>
<p class="indent">To convert a mapping into a decryption output we can read easily, we’ll need to first create a placeholder key, which will look like this: <span class="literal">['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x']</span>. The lowercase <span class="literal">'x'</span> can be used in the placeholder key because the actual key uses only uppercase letters. (You can use any character that isn’t an uppercase letter as a placeholder.) Because not all the letters will have a decryption, we need to be able to distinguish between parts of the key list that have been filled with the decryption letters and those where the decryption hasn’t been solved. The <span class="literal">'</span><span class="literal">x'</span> indicates letters that haven’t been solved.</p>
<p class="indent">Let’s see how this all comes together in the source code:</p>
<p class="programs1">135. def decryptWithCipherletterMapping(ciphertext, letterMapping):<br class="calibre9" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return a string of the ciphertext decrypted with the letter mapping,<br class="calibre9" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# with any ambiguous decrypted letters replaced with an underscore.<br class="calibre9" />138.<br class="calibre9" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First create a simple sub key from the letterMapping mapping:<br class="calibre9" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = ['x'] * len(LETTERS)<br class="calibre9" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for cipherletter in LETTERS:<br class="calibre9" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(letterMapping[cipherletter]) == 1:<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-958"></span>143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If there's only one letter, add it to the key:<br class="calibre9" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyIndex = LETTERS.find(letterMapping[cipherletter][0])<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key[keyIndex] = cipherletter</p>
<p class="indent">Line 140 creates the placeholder list by replicating the single-item list <span class="literal">['x']</span> 26 times. Because <span class="literal">LETTERS</span> is a string of the letters of the alphabet, <span class="literal">len(LETTERS)</span> evaluates to <span class="literal">26</span>. When used on a list and integer, the multiplication operator (<span class="literal">*</span>) performs list replication.</p>
<p class="indent">The <span class="literal">for</span> loop on line 141 checks each of the letters in <span class="literal">LETTERS</span> for the <span class="literal">cipherletter</span> variable, and if the cipherletter is solved (that is, <span class="literal">letterMapping[cipherletter]</span> has only one letter in it), it replaces the <span class="literal">'x'</span> placeholder with that letter.</p>
<p class="indent">The <span class="literal">letterMapping[cipherletter][0]</span> on line 144 is the decryption letter, and <span class="literal">keyIndex</span> is the index of the decryption letter in <span class="literal">LETTERS</span>, which is returned from the <span class="literal">find()</span> call. Line 145 sets this index in the key list to the decryption letter.</p>
<p class="indent">However, if the cipherletter doesn’t have a solution, the function inserts an underscore for that cipherletter to indicate which characters remain unsolved. Line 147 replaces the lowercase letters in <span class="literal">cipherletter</span> with an underscore, and line 148 replaces the uppercase letters with an underscore:</p>
<p class="programs1">146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ciphertext.replace(cipherletter.lower(), '_')<br class="calibre9" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = ciphertext.replace(cipherletter.upper(), '_')</p>
<p class="indent">After replacing all the parts in the list in <span class="literal">key</span> with the solved letters, the function combines the list of strings into a single string using the <span class="literal">join()</span> method to create a simple substitution key. This string is passed to the <span class="literal">decryptMessage()</span> function in the <em class="calibre7">simpleSubCipher.py</em> program.</p>
<p class="programs1">149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key = ''.join(key)<br class="calibre9" />150.<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# With the key we've created, decrypt the ciphertext:<br class="calibre9" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return simpleSubCipher.decryptMessage(key, ciphertext)</p>
<p class="indent">Finally, line 152 returns the decrypted message string from the <span class="literal">decryptMessage</span><span class="literal">()</span> function. We now have all the functions we need to find an intersected letter mapping, hack a key, and decrypt a message. Let’s look at a quick example of how these functions work in the interactive shell.</p>
<h4 class="h2" id="calibre_link-707"><strong class="calibre3"><em class="calibre12">Decrypting in the Interactive Shell</em></strong></h4>
<p class="noindent">Let’s return to the example we used in “<a href="#calibre_link-388" class="calibre8">How the Letter-Mapping Helper Functions Work</a>” on <a href="#calibre_link-388" class="calibre8">page 235</a>. We’ll use the <span class="literal">intersectedMapping</span> variable we created in our earlier shell examples to decrypt the ciphertext message <span class="literal">'OLQIHXIRCKGNZ PLQRZKBZB MPBKSSIPLC'</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-255"></span>Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">simpleSubHacker.decryptWithCipherletterMapping('OLQIHXIRCKGNZ PLQRZKBZB</span><br class="calibre9" /><span class="codestrong">MPBKSSIPLC', intersectedMapping)</span><br class="calibre9" />UNCOMFORTABLE INCREASES DISAPPOINT</p>
<p class="indent">The ciphertext decrypts to the message “Uncomfortable increases disappoint”. As you can see, the <span class="literal">decryptWithCipherletterMapping()</span> function worked perfectly and returned the fully decrypted string. But this example doesn’t show what happens when we don’t have all the letters that appear in the ciphertext solved. To see what happens when we’re missing a cipher&shy;letter’s decryption, let’s remove the solution for the cipherletters <span class="literal">'M'</span> and <span class="literal">'S'</span> from <span class="literal">intersectedMapping</span> by using the following instructions:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">intersectedMapping['M'] = []</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">intersectedMapping['S'] = []</span></p>
<p class="indent">Then try to decrypt the ciphertext with <span class="literal">intersectedMapping</span> again:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">simpleSubHacker.decryptWithCipherletterMapping('OLQIHXIRCKGNZ PLQRZKBZB</span><br class="calibre9" /><span class="codestrong">MPBKSSIPLC', intersectedMapping)</span><br class="calibre9" />UNCOMFORTABLE INCREASES _ISA__OINT</p>
<p class="indent">This time, part of the ciphertext wasn’t decrypted. The cipherletters without a decryption letter were replaced with underscores.</p>
<p class="indent">This is a rather short ciphertext to hack. Normally, encrypted messages would be much longer. (This example was specifically chosen to be hackable. Messages as short as this example usually cannot be hacked using the word pattern method.) To hack longer encryptions, you’ll need to create a cipherletter mapping for each cipherword in the longer messages and then intersect them all together. The <span class="literal">hackSimpleSub()</span> function calls the other functions in our program to do exactly this.</p>
<h3 class="h1" id="calibre_link-708">Calling the main() Function</h3>
<p class="noindent">Lines 155 and 156 call the <span class="literal">main()</span> function to run <em class="calibre7">simpleSubHacker.py</em> if it’s being run directly instead of being imported as a module by another Python program:</p>
<p class="programs1">155. if __name__ == '__main__':<br class="calibre9" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">That completes our discussion of all the functions the <em class="calibre7">simpleSubHacker.py</em> program uses.</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">NOTE</span></strong></p>
<p class="notep"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-959"></span><em class="calibre7">Our hacking approach works only if the spaces are not encrypted. You can expand the symbol set so the cipher program encrypts spaces, numbers, and punctuation characters as well as letters, making your encrypted messages even harder (but not impossible) to hack. Hacking such messages would involve updating the frequencies of not just letters, but all the symbols in the symbol set. This makes hacking more complicated, which is the reason this book encrypted letters only.</em></p>
</div>
<h3 class="h1" id="calibre_link-709">Summary</h3>
<p class="noindent">Whew! The <em class="calibre7">simpleSubHacker.py</em> program is fairly complicated. You learned how to use cipherletter mapping to model the possible decryption letters for each ciphertext letter. You also learned how to narrow down the number of possible keys by adding potential letters to the mapping, intersecting them, and removing solved letters from other lists of potential decryption letters. Instead of brute-forcing 403,291,461,126,605,635,584,000,000 possible keys, you can use some sophisticated Python code to figure out most (if not all) of the original simple substitution key.</p>
<p class="indent">The main advantage of the simple substitution cipher is its large number of possible keys. The disadvantage is that it’s relatively easy to compare cipherwords to words in a dictionary file to determine which cipherletters decrypt to which letters. In <a href="#calibre_link-31" class="calibre8">Chapter 18</a>, we’ll explore a more powerful polyalphabetic substitution cipher called the Vigenère cipher, which was considered impossible to break for several hundred years.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-710"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What is the word pattern for the word <em class="calibre7">hello</em>?</p>
</li>
<li value="2" class="calibre11"><p class="noindent">Do <em class="calibre7">mammoth</em> and <em class="calibre7">goggles</em> have the same word pattern?</p></li>
<li value="3" class="calibre11"><p class="noindent">Which word could be the possible plaintext word for the cipherword PYYACAO? <em class="calibre7">Alleged</em>, <em class="calibre7">efficiently</em>, or <em class="calibre7">poodle</em>?</p></li>
</ol>
</div>
</div>
<div><a href="chapter16.html">Previous Chapter - Programming the Simple Substitution Cipher</a> | <a href="chapter18.html">Next Chapter - Programming the Vigenère Cipher</a></div>
<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>