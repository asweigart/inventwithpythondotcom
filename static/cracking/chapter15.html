<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Cracking Codes with Python</title></head><body style="background-color: #fffeee;">


<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter14.html">Previous Chapter - Programming The Affine Cipher</a> | <a href="chapter16.html">Next Chapter - Programming the Simple Substitution Cipher</a></div>
<div id="calibre_link-401" class="calibre">
<h2 class="h2a1" id="calibre_link-61"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-943" class="calibre1"></span><span class="big">15</span><br class="calibre15" />HACKING THE AFFINE CIPHER</h2>
<p class="epigraph"><em class="calibre7">“Cryptanalysis could not be invented until a civilization had reached a sufficiently sophisticated level of scholarship in several disciplines, including mathematics, statistics, and linguistics.”<br class="calibre9" />&mdash;Simon Singh,</em> The Code Book</p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">In <a href="#calibre_link-60" class="calibre8">Chapter 14</a>, you learned that the affine cipher is limited to only a few thousand keys, which means we can easily perform a brute-force attack against it. In this chapter, you’ll learn how to write a program that can break affine cipher&ndash;encrypted messages.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">The exponent operator (<span class="literal">**</span>)</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">continue</span> statement</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-667"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-108" class="calibre1"></span><strong class="calibre3">Source Code for the Affine Cipher Hacker Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor and then save it as <em class="calibre7">affineHacker.py</em>. Entering the string for the <span class="literal">myMessage</span> variable by hand might be tricky, so you can copy and paste it from the <em class="calibre7">affineHacker.py</em> file available at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a> to save time. Make sure <em class="calibre7">dictionary.txt</em> as well as <em class="calibre7">pyperclip.py</em>, <em class="calibre7">affineCipher.py</em>, <em class="calibre7">detectEnglish.py</em>, and <em class="calibre7">cryptomath.py</em> are in the same directory as <em class="calibre7">affineHacker.py</em>.</p>
<p class="noindentz"><em class="calibre7">affineHacker.py</em></p>
<p class="programs1">&nbsp;1. # Affine Cipher Hacker<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import pyperclip, affineCipher, detectEnglish, cryptomath<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6. SILENT_MODE = False<br class="calibre9" />&nbsp;7.<br class="calibre9" />&nbsp;8. def main():<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# You might want to copy &amp; paste this text from the source code at<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# https://www.nostarch.com/crackingcodes/.<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = """5QG9ol3La6QI93!xQxaia6faQL9QdaQG1!!axQARLa!!A<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uaRLQADQALQG93!xQxaGaAfaQ1QX3o1RQARL9Qda!AafARuQLX1LQALQI1<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iQX3o1RN"Q-5!1RQP36ARu"""<br class="calibre9" />12.<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = hackAffine(myMessage)<br class="calibre9" />14.<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The plaintext is displayed on the screen. For the convenience of<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the user, we copy the text of the code to the clipboard:<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Failed to hack encryption.')<br class="calibre9" />23.<br class="calibre9" />24.<br class="calibre9" />25. def hackAffine(message):<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hacking...')<br class="calibre9" />27.<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Python programs can be stopped at any time by pressing Ctrl-C (on<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Windows) or Ctrl-D (on macOS and Linux):<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('(Press Ctrl-C or Ctrl-D to quit at any time.)')<br class="calibre9" />31.<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Brute-force by looping through every possible key:<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for key in range(len(affineCipher.SYMBOLS) ** 2):<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = affineCipher.getKeyParts(key)[0]<br class="calibre9" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) != 1:<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre9" />37.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-109"></span>38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = affineCipher.decryptMessage(key, message)<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Tried Key %s... (%s)' % (key, decryptedText[:40]))<br class="calibre9" />41.<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if detectEnglish.isEnglish(decryptedText):<br class="calibre9" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check with the user if the decrypted key has been found:<br class="calibre9" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible encryption hack:')<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key: %s' % (key))<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted message: ' + decryptedText[:200])<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter D for done, or just press Enter to continue<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hacking:')<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = input('&gt; ')<br class="calibre9" />51.<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if response.strip().upper().startswith('D'):<br class="calibre9" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptedText<br class="calibre9" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None<br class="calibre9" />55.<br class="calibre9" />56.<br class="calibre9" />57. # If affineHacker.py is run (instead of imported as a module), call<br class="calibre9" />58. # the main() function:<br class="calibre9" />59. if __name__ == '__main__':<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-668"><strong class="calibre3">Sample Run of the Affine Cipher Hacker Program</strong></h3>
<p class="noindent">Press F5 from the file editor to run the <em class="calibre7">affineHacker.py</em> program; the output should look like this:</p>
<p class="programs1">Hacking...<br class="calibre9" />(Press Ctrl-C or Ctrl-D to quit at any time.)<br class="calibre9" />Tried Key 95... (U&amp;'&lt;3dJ^Gjx'-3^MS'Sj0jxuj'G3'%j'&lt;mMMjS'g)<br class="calibre9" />Tried Key 96... (T%&amp;;2cI]Fiw&amp;,2]LR&amp;Ri/iwti&amp;F2&amp;$i&amp;;lLLiR&amp;f)<br class="calibre9" />Tried Key 97... (S$%:1bH\Ehv%+1\KQ%Qh.hvsh%E1%#h%:kKKhQ%e)<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />Tried Key 2190... (?^=!-+.32#0=5-3*"="#1#04#=2-= #=!~**#"=')<br class="calibre9" />Tried Key 2191... (' ^BNLOTSDQ^VNTKC^CDRDQUD^SN^AD^B@KKDC^H)<br class="calibre9" />Tried Key 2192... ("A computer would deserve to be called i)<br class="calibre9" />Possible encryption hack:<br class="calibre9" />Key: 2192<br class="calibre9" />Decrypted message: "A computer would deserve to be called intelligent if it<br class="calibre9" />could deceive a human into believing that it was human." -Alan Turing<br class="calibre9" />Enter D for done, or just press Enter to continue hacking:<br class="calibre9" />&gt; <span class="codestrong">d</span><br class="calibre9" />Copying hacked message to clipboard:<br class="calibre9" />"A computer would deserve to be called intelligent if it could deceive a human<br class="calibre9" />into believing that it was human." &ndash;Alan Turing</p>
<p class="indent">Let’s take a closer look at how the affine cipher hacker program works.</p>
<h3 class="h1" id="calibre_link-669"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-278" class="calibre1"></span><strong class="calibre3">Setting Up Modules, Constants, and the main() Function</strong></h3>
<p class="noindent">The affine cipher hacker program is 60 lines long because we’ve already written much of the code it uses. Line 4 imports the modules we created in previous chapters:</p>
<p class="programs1">&nbsp;1. # Affine Cipher Hacker<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import pyperclip, affineCipher, detectEnglish, cryptomath<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6. SILENT_MODE = False</p>
<p class="indent">When you run the affine cipher hacker program, you’ll see that it produces lots of output as it works its way through all the possible decryptions. However, printing all this output slows down the program. If you want to speed up the program, set the <span class="literal">SILENT_MODE</span> variable on line 6 to <span class="literal">True</span> to stop it from printing all these messages.</p>
<p class="indent">Next, we set up the <span class="literal">main()</span> function:</p>
<p class="programs1">&nbsp;8. def main():<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# You might want to copy &amp; paste this text from the source code at<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# https://www.nostarch.com/crackingcodes/.<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMessage = """5QG9ol3La6QI93!xQxaia6faQL9QdaQG1!!axQARLa!!A<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uaRLQADQALQG93!xQxaGaAfaQ1QX3o1RQARL9Qda!AafARuQLX1LQALQI1<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iQX3o1RN"Q-5!1RQP36ARu"""<br class="calibre9" />12.<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = hackAffine(myMessage)</p>
<p class="indent">The ciphertext to be hacked is stored as a string in <span class="literal">myMessage</span> on line 11, and this string is passed to the <span class="literal">hackAffine()</span> function, which we’ll look at in the next section. The return value from this call is either a string of the original message if the ciphertext was hacked or the <span class="literal">None</span> value if the hack failed.</p>
<p class="indent">The code on lines 15 to 22 checks whether <span class="literal">hackedMessage</span> was set to <span class="literal">None</span>:</p>
<p class="programs1">15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The plaintext is displayed on the screen. For the convenience of<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# the user, we copy the text of the code to the clipboard:<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Failed to hack encryption.')</p>
<p class="indent">If <span class="literal">hackedMessage</span> is not equal to <span class="literal">None</span>, the message is printed to the screen on line 19 and copied to the clipboard on line 20. Otherwise, the program simply prints feedback to the user that it was unable to hack the ciphertext. Let’s take a closer look at how the <span class="literal">hackAffine()</span> function works.</p>
<h3 class="h1" id="calibre_link-670"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-86" class="calibre1"></span><strong class="calibre3">The Affine Cipher Hacking Function</strong></h3>
<p class="noindent">The <span class="literal">hackAffine()</span> function begins on line 25 and contains the code for decryption. It starts by printing some instructions for the user:</p>
<p class="programs1">25. def hackAffine(message):<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hacking...')<br class="calibre9" />27.<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Python programs can be stopped at any time by pressing Ctrl-C (on<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Windows) or Ctrl-D (on macOS and Linux):<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('(Press Ctrl-C or Ctrl-D to quit at any time.)')</p>
<p class="indent">The decryption process can take a while, so if the user wants to exit the program early, they can press <small class="calibre14">ctrl</small>-C (on Windows) or <small class="calibre14">ctrl</small>-D (on macOS and Linux).</p>
<p class="indent">Before we continue with the rest of the code, you need to learn about the exponent operator.</p>
<h4 class="h2" id="calibre_link-671"><strong class="calibre3"><em class="calibre12">The Exponent Operator</em></strong></h4>
<p class="noindent">A useful math operator you need to know to understand the affine cipher hacker program (besides the basic <span class="literal">+</span>, <span class="literal">-</span>, <span class="literal">*</span>, <span class="literal">/</span>, and <span class="literal">//</span> operators) is the <em class="calibre7">exponent operator</em> (<span class="literal">**</span>). The exponent operator raises a number to the power of another number. For example, two to the power of five would be <span class="literal">2 ** 5</span> in Python. This is equivalent to two multiplied by itself five times: <span class="literal">2 * 2 * 2 * 2 * 2</span>. Both expressions, <span class="literal">2 ** 5</span> and <span class="literal">2 * 2 * 2 * 2 * 2</span>, evaluate to the integer <span class="literal">32</span>.</p>
<p class="indent">Enter the following into the interactive shell to see how the <span class="literal">**</span> operator works:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">5 ** 2</span><br class="calibre9" />25<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">2 ** 5</span><br class="calibre9" />32<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">123 ** 10</span><br class="calibre9" />792594609605189126649</p>
<p class="indent">The expression <span class="literal">5 ** 2</span> evaluates to <span class="literal">25</span> because <span class="literal">5</span> multiplied by itself is equivalent to <span class="literal">25</span>. Likewise, <span class="literal">2 ** 5</span> returns <span class="literal">32</span> because <span class="literal">2</span> multiplied by itself five times evaluates to <span class="literal">32</span>.</p>
<p class="indent">Let’s return to the source code to see what the <span class="literal">**</span> operator does in the program.</p>
<h4 class="h2" id="calibre_link-672"><strong class="calibre3"><em class="calibre12">Calculating the Total Number of Possible Keys</em></strong></h4>
<p class="noindent">Line 33 uses the <span class="literal">**</span> operator to calculate the total number of possible keys:</p>
<p class="programs1">32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Brute-force by looping through every possible key:<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for key in range(len(affineCipher.SYMBOLS) ** 2):<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyA = affineCipher.getKeyParts(key)[0]</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-178"></span>We know there are at most <span class="literal">len(affineCipher.SYMBOLS)</span> possible integers for Key A and <span class="literal">len(affineCipher.SYMBOLS)</span> possible integers for Key B. To get the entire range of possible keys, we multiply these values together. Because we’re multiplying the same value by itself, we can use the <span class="literal">**</span> operator in the expression <span class="literal">len(affineCipher.SYMBOLS) ** 2</span>.</p>
<p class="indent">Line 34 calls the <span class="literal">getKeyParts()</span> function that we used in <em class="calibre7">affineCipher.py</em> to split a single integer key into two integers. In this example, we’re using the function to get the Key A part of the key we’re testing. Recall that the return value of this function call is a tuple of two integers: one for Key A and one for Key B. Line 34 stores the tuple’s first integer in <span class="literal">keyA</span> by placing the <span class="literal">[0]</span> after the <span class="literal">hackAffine()</span> function call.</p>
<p class="indent">For example, <span class="literal">affineCipher.getKeyParts(key)[0]</span> evaluates to the tuple and the index <span class="literal">(42, 22)[0]</span>, which then evaluates to <span class="literal">42</span>, the value at index <span class="literal">0</span> of the tuple. This gets just the Key A part of the return value and stores it in the variable <span class="literal">keyA</span>. The Key B part (the second value in the returned tuple) is ignored because we don’t need Key B to calculate whether Key A is valid. Lines 35 and 36 check whether <span class="literal">keyA</span> is a valid Key A for the affine cipher, and if not, the program continues to the next key to try. To understand how the execution moves back to the start of the loop, you need to learn about the <span class="literal">continue</span> statement.</p>
<h4 class="h2" id="calibre_link-673"><strong class="calibre3"><em class="calibre12">The continue Statement</em></strong></h4>
<p class="noindent">The <span class="literal">continue</span> statement uses the <span class="literal">continue</span> keyword by itself and takes no parameters. We use a <span class="literal">continue</span> statement inside a <span class="literal">while</span> or <span class="literal">for</span> loop. When a <span class="literal">continue</span> statement executes, the program execution immediately jumps to the start of the loop for the next iteration. This also happens when the program execution reaches the end of the loop’s block. But a <span class="literal">continue</span> statement makes the program execution jump back to the start of the loop before it reaches the end of the loop.</p>
<p class="indent">Enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">for i in range(3):</span><br class="calibre9" />...<span class="codestrong">&nbsp;&nbsp;&nbsp;print(i)</span><br class="calibre9" />...<span class="codestrong">&nbsp;&nbsp;&nbsp;print('Hello!')</span><br class="calibre9" />...<br class="calibre9" />0<br class="calibre9" />Hello!<br class="calibre9" />1<br class="calibre9" />Hello!<br class="calibre9" />2<br class="calibre9" />Hello!</p>
<p class="indent">The <span class="literal">for</span> loop loops through the <span class="literal">range</span> object, and the value in <span class="literal">i</span> becomes each integer from <span class="literal">0</span> up to, but not including, <span class="literal">3</span>. On each iteration, the <span class="literal">print('Hello!')</span> function call displays <span class="literal">Hello!</span> on the screen.</p>
<p class="indent">Now contrast that <span class="literal">for</span> loop with the next example, which is the same as the previous example except it has a <span class="literal">continue</span> statement before the <span class="literal">print('Hello!')</span> line.</p>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-944"></span>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">for i in range(3):</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">print(i)</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">continue</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Hello!')</span><br class="calibre9" />...<br class="calibre9" />0<br class="calibre9" />1<br class="calibre9" />2</p>
<p class="indent">Notice that <span class="literal">Hello!</span> never gets printed, because the <span class="literal">continue</span> statement causes the program execution to jump back to the start of the <span class="literal">for</span> loop for the next iteration and the execution never reaches the <span class="literal">print('Hello!')</span> line.</p>
<p class="indent">A <span class="literal">continue</span> statement is often placed inside an <span class="literal">if</span> statement’s block so that execution continues at the beginning of the loop under certain conditions. Let’s return to our code to see how it uses the <span class="literal">continue</span> statement to skip execution depending on the key used.</p>
<h4 class="h2" id="calibre_link-674"><strong class="calibre3"><em class="calibre12">Using continue to Skip Code</em></strong></h4>
<p class="noindent">In the source code, line 35 uses the <span class="literal">gcd()</span> function in the <span class="literal">cryptomath</span> module to determine whether Key A is relatively prime to the symbol set size:</p>
<p class="programs1">35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) != 1:<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue</p>
<p class="indent">Recall that two numbers are relatively prime if their greatest common divisor (GCD) is 1. If Key A and the symbol set size are not relatively prime, the condition on line 35 is <span class="literal">True</span> and the <span class="literal">continue</span> statement on line 36 executes. This causes the program execution to jump back to the start of the loop for the next iteration. As a result, the program skips the call to <span class="literal">decryptMessage</span><span class="literal">()</span> on line 38 if the key is invalid and continues to try other keys until it finds the right one.</p>
<p class="indent">When the program finds the right key, the message is decrypted by calling <span class="literal">decryptMessage()</span> with the key on line 38:</p>
<p class="programs1">38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = affineCipher.decryptMessage(key, message)<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Tried Key %s... (%s)' % (key, decryptedText[:40]))</p>
<p class="indent">If <span class="literal">SILENT_MODE</span> was set to <span class="literal">False</span>, the <span class="literal">Tried Key</span> message is printed on the screen, but if it was set to <span class="literal">True</span>, the <span class="literal">print()</span> call on line 40 is skipped.</p>
<p class="indent">Next, line 42 uses the <span class="literal">isEnglish()</span> function from the <span class="literal">detectEnglish</span> module to check whether the decrypted message is recognized as English:</p>
<p class="programs1">42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if detectEnglish.isEnglish(decryptedText):<br class="calibre9" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check with the user if the decrypted key has been found:<br class="calibre9" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible encryption hack:')<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key: %s' % (key))<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-105"></span>47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Decrypted message: ' + decryptedText[:200])<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()</p>
<p class="indent">If the wrong decryption key was used, the decrypted message would look like random characters and <span class="literal">isEnglish()</span> would return <span class="literal">False</span>. But if the decrypted message is recognized as readable English (by the <span class="literal">isEnglish()</span> function’s standards), the program displays it to the user.</p>
<p class="indent">We display a snippet of the decrypted message that is recognized as English, because the <span class="literal">isEnglish()</span> function might mistakenly identify text as English even though it hasn’t found the correct key. If the user decides that this is indeed the correct decryption, they can type <span class="codestrong">D</span> and then press <small class="calibre14">enter</small>.</p>
<p class="programs1">49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter D for done, or just press Enter to continue<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hacking:')<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = input('&gt; ')<br class="calibre9" />51.<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if response.strip().upper().startswith('D'):<br class="calibre9" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptedText</p>
<p class="indent">Otherwise, the user can just press <small class="calibre14">enter</small> to return a blank string from the <span class="literal">input()</span> call, and the <span class="literal">hackAffine()</span> function would continue trying more keys.</p>
<p class="indent">From the indentation at the beginning of line 54, you can see that this line executes after the <span class="literal">for</span> loop on line 33 has completed:</p>
<p class="programs1">54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None</p>
<p class="indent">If the <span class="literal">for</span> loop finishes and reaches line 54, then it has gone through every possible decryption key without finding the correct one. At this point, the <span class="literal">hackAffine()</span> function returns the <span class="literal">None</span> value to signal that it was unsuccessful at hacking the ciphertext.</p>
<p class="indent">If the program had found the correct key, the execution would have previously returned from the function on line 53 and never reached line 54.</p>
<h3 class="h1" id="calibre_link-675"><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">If we run <em class="calibre7">affineHacker.py</em> as a program, the special <span class="literal">__name__</span> variable will be set to the string <span class="literal">'__main__'</span> instead of <span class="literal">'affineHacker'</span>. In this case, we call the <span class="literal">main()</span> function.</p>
<p class="programs1">57. # If affineHacker.py is run (instead of imported as a module), call<br class="calibre9" />58. # the main() function:<br class="calibre9" />59. if __name__ == '__main__':<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">That concludes the affine cipher hacking program.</p>
<h3 class="h1" id="calibre_link-676"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-945" class="calibre1"></span><strong class="calibre3">Summary</strong></h3>
<p class="noindent">This chapter is fairly short because it doesn’t introduce any new hacking techniques. As you’ve seen, as long as the number of possible keys is only a few thousand, it won’t take long for computers to brute-force through every possible key and use the <span class="literal">isEnglish()</span> function to search for the right key.</p>
<p class="indent">You learned about the exponent operator (<span class="literal">**</span>), which raises a number to the power of another number. You also learned how to use the <span class="literal">continue</span> statement to send the program execution back to the beginning of the loop instead of waiting until the execution reaches the end of the block.</p>
<p class="indent">Conveniently, we already wrote much of the code used for the affine cipher hacker in <em class="calibre7">affineCipher.py</em>, <em class="calibre7">detectEnglish.py</em>, and <em class="calibre7">cryptomath.py</em>. The <span class="literal">main()</span> function trick helps us reuse the code in our programs.</p>
<p class="indent">In <a href="#calibre_link-62" class="calibre8">Chapter 16</a>, you’ll learn about the simple substitution cipher, which computers can’t brute-force. The number of possible keys for this cipher is more than trillions of trillions! A single laptop couldn’t possibly go through a fraction of those keys in our lifetime, which makes the cipher immune to a brute-force attack.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-677"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What does <span class="literal">2 ** 5</span> evaluate to?</p></li>
<li value="2" class="calibre11"><p class="noindent">What does <span class="literal">6 ** 2</span> evaluate to?</p></li>
<li value="3" class="calibre11"><p class="noindent">What does the following code print?</p>
<p class="programs1">for i in range(5):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;if i == 2:<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;print(i)</p></li>
<li value="4" class="calibre11"><p class="noindent">Does the <span class="literal">main()</span> function of <em class="calibre7">affineHacker.py</em> get called if another program runs <span class="literal">import affineHacker</span>?</p></li>
</ol>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-946"></span>
</div>
</div>
<div><a href="chapter14.html">Previous Chapter - Programming The Affine Cipher</a> | <a href="chapter16.html">Next Chapter - Programming the Simple Substitution Cipher</a></div>
<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>