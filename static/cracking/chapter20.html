<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 20 - Hacking the Vigenere Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.png" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.png" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.jpg" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter19.html">Prev: Chapter 19 - Frequency Analysis</a> | <a href="chapter21.html">Next: Chapter 21 - The One-Time Pad Cipher</a>





<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.png" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter19.html">Previous Chapter - Frequency Analysis</a> | <a href="chapter21.html">Next Chapter - The One-Time Pad Cipher</a></div>
<div id="calibre_link-36" class="calibre">
<h2 class="h2a1" id="calibre_link-64"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-970" class="calibre1"></span><span class="big">20</span><br class="calibre15" />HACKING THE VIGENÈRE CIPHER</h2>
<p class="epigraph"><em class="calibre7">“Privacy is an inherent human right, and a requirement for maintaining the human condition with dignity and respect.”<br class="calibre9" />&mdash;Bruce Schneier, cryptographer, 2006</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">Two methods exist to hack the Vigenère cipher. One method uses a brute-force <em class="calibre7">dictionary attack</em> to try every word in the dictionary file as the Vigenère key, which works only if the key is an English word, such as RAVEN or DESK. The second, more sophisticated method, which was used by the 19th-century mathematician Charles Babbage, works even when the key is a random group of letters, such as VUWFE or PNFJ. In this chapter, we’ll write programs to hack the Vigenère cipher using both methods.</p>
<div class="sidebar">
<p class="sidebart"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-204"></span><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<ul class="calibre10">
<li class="calibre11"><p class="noindent">Dictionary attacks</p></li>
<li class="calibre11"><p class="noindent">Kasiski examination</p></li>
<li class="calibre11"><p class="noindent">Calculating factors</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">set</span> data type and <span class="literal">set()</span> function</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">extend()</span> list method</p></li>
<li class="calibre11"><p class="noindent">The <span class="literal">itertools.product()</span> function</p></li>
</ul>
</div>
<h3 class="h1" id="calibre_link-739"><strong class="calibre3">Using a Dictionary Attack to Brute-Force the Vigenère Cipher</strong></h3>
<p class="noindent">We’ll first use the dictionary attack to hack the Vigenère cipher. The dictionary file <em class="calibre7">dictionary.txt</em> (available on this book’s website at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>) has approximately 45,000 English words. It takes less than five minutes for my computer to run through all these decryptions for a message the size of a long paragraph. This means that if an English word is used to encrypt a Vigenère ciphertext, the ciphertext is vulnerable to a dictionary attack. Let’s look at the source code for a program that uses a dictionary attack to hack the Vigenère cipher.</p>
<h3 class="h1" id="calibre_link-740"><strong class="calibre3">Source Code for the Vigenère Dictionary Hacker Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Enter the following code into the file editor, and then save it as <em class="calibre7">vigenereDictionaryHacker.py</em>. Be sure to place the <em class="calibre7">detectEnglish.py</em>, <em class="calibre7">vigenereCipher.py</em>, and <em class="calibre7">pyperclip.py</em> files in the same directory as the <em class="calibre7">vigenereDictionaryHacker.py</em> file. Then press F5 to run the program.</p>
<p class="noindentz"><em class="calibre7">vigenere<br class="calibre9" />Dictionary<br class="calibre9" />Hacker.py</em></p>
<p class="programs1">&nbsp;1. # Vigenere Cipher Dictionary Hacker<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import detectEnglish, vigenereCipher, pyperclip<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6. def main():<br class="calibre9" />&nbsp;7.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = """Tzx isnz eccjxkg nfq lol mys bbqq I lxcz."""<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = hackVigenereDictionary(ciphertext)<br class="calibre9" />&nbsp;9.<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Failed to hack encryption.')<br class="calibre9" />16.<br class="calibre9" />17.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-330"></span>18. def hackVigenereDictionary(ciphertext):<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open('dictionary.txt')<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = fo.readlines()<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />22.<br class="calibre9" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for word in lines:<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;word = word.strip() # Remove the newline at the end.<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = vigenereCipher.decryptMessage(word, ciphertext)<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if detectEnglish.isEnglish(decryptedText, wordPercentage=40):<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check with user to see if the decrypted key has been found:<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible encryption break:')<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key ' + str(word) + ': ' + decryptedText[:100])<br class="calibre9" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter D for done, or just press Enter to continue<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;breaking:')<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = input('&gt; ')<br class="calibre9" />34.<br class="calibre9" />35.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if response.upper().startswith('D'):<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptedText<br class="calibre9" />37.<br class="calibre9" />38. if __name__ == '__main__':<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-741"><strong class="calibre3">Sample Run of the Vigenère Dictionary Hacker Program</strong></h3>
<p class="noindent">When you run the <em class="calibre7">vigenereDictionaryHacker.py</em> program, the output should look like this:</p>
<p class="programs1">Possible encryption break:<br class="calibre9" />Key ASTROLOGY: The recl yecrets crk not the qnks I tell.<br class="calibre9" />Enter D for done, or just press Enter to continue breaking:<br class="calibre9" />&gt;<br class="calibre9" />Possible encryption break:<br class="calibre9" />Key ASTRONOMY: The real secrets are not the ones I tell.<br class="calibre9" />Enter D for done, or just press Enter to continue breaking:<br class="calibre9" />&gt; <span class="codestrong">d</span><br class="calibre9" />Copying hacked message to clipboard:<br class="calibre9" />The real secrets are not the ones I tell.</p>
<p class="indent">The first keyword the program suggests (<span class="literal">ASTROLOGY</span>) doesn’t work, so the user presses <small class="calibre14">enter</small> to let the hacking program continue until it finds the correct decryption key (<span class="literal">ASTRONOMY</span>).</p>
<h3 class="h1" id="calibre_link-742">About the Vigenère Dictionary Hacker Program</h3>
<p class="noindent">Because the source code for the <em class="calibre7">vigenereDictionaryHacker.py</em> program is similar to previous hacking programs in this book, I won’t explain it line by line. Briefly, the <span class="literal">hackVigenereDictionary()</span> function attempts to use each word in the dictionary file to decrypt the ciphertext, and when the decrypted text looks like English (according to the <span class="literal">detectEnglish</span> module), it prints the decryption and prompts the user to quit or continue.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-136"></span>Note that this program uses the <span class="literal">readlines()</span> method on file objects returned from <span class="literal">open()</span>:</p>
<p class="programs1">20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;words = fo.readlines()</p>
<p class="indent">Unlike the <span class="literal">read()</span> method, which returns the full contents of the file as a single string, the <span class="literal">readlines()</span> method returns a list of strings, where each string is a single line from the file. Since there is one word in each line of the dictionary file, the <span class="literal">words</span> variable contains a list of every English word from <em class="calibre7">Aarhus</em> to <em class="calibre7">Zurich</em>.</p>
<p class="indent">The rest of the program, from lines 23 to 36, works similarly to the transposition cipher&ndash;hacking program in <a href="#calibre_link-37" class="calibre8">Chapter 12</a>. A <span class="literal">for</span> loop will iterate over each word in the <span class="literal">words</span> list, decrypt the message with the word as the key, and then call <span class="literal">detectEnglish.isEnglish()</span> to see whether the result is understandable English text.</p>
<p class="indent">Now that we’ve written a program that hacks the Vigenère cipher using a dictionary attack, let’s look at how to hack the Vigenère cipher even when the key is a random group of letters rather than a dictionary word.</p>
<h3 class="h1" id="calibre_link-743"><strong class="calibre3">Using Kasiski Examination to Find the Key’s Length</strong></h3>
<p class="noindent"><em class="calibre7">Kasiski examination</em> is a process that we can use to determine the length of the Vigenère key used to encrypt a ciphertext. We can then use frequency analysis to break each of the subkeys independently. Charles Babbage was the first person to have broken the Vigenère cipher using this process, but he never published his results. His method was later published by Friedrich Kasiski, an early 20th-century mathematician who became the namesake of the method. Let’s look at the steps involved in Kasiski examination. These are the steps that our Vigenère hacking program will take.</p>
<h4 class="h2" id="calibre_link-744"><strong class="calibre3"><em class="calibre12">Finding Repeated Sequences</em></strong></h4>
<p class="noindent">The first step of Kasiski examination is to find every repeated set of at least three letters in the ciphertext. These repeated sequences could be the same letters of plaintext encrypted using the same subkeys of the Vigenère key. For example, if you encrypted the plaintext THE CAT IS OUT OF THE BAG with the key SPILLTHEBEANS, you’d get:</p>
<p class="programs1"><span class="codestrong">THE</span>CATISOUTOF<span class="codestrong">THE</span>BAG<br class="calibre9" /><span class="codestrong">SPI</span>LLTHEBEANS<span class="codestrong">SPI</span>LLT<br class="calibre9" /><span class="codestrong">LWM</span>NLMPWPYTBX<span class="codestrong">LWM</span>MLZ</p>
<p class="indent">Notice that the letters LWM repeat twice. The reason is that in the ciphertext, LWM is the plaintext word THE encrypted using the same letters of the key&mdash;SPI&mdash;because the key happens to repeat at the second THE. The number of letters from the beginning of the first LWM to the beginning of the second LWM, which we’ll call the <em class="calibre7">spacing</em>, is 13. This suggests that the key used for this ciphertext is 13 letters long. By just looking at the repeated sequences, you can figure out the length of the key.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-231"></span>However, in most ciphertexts, the key won’t conveniently align with a repeated sequence of letters, or the key might repeat more than once between repeated sequences, meaning that the number of letters between the repeated letters would be equal to a multiple of the key rather than the key itself. To try to address these problems, let’s look at a longer example in which we don’t know what the key is.</p>
<p class="indent">When we remove the non-letters in the ciphertext PPQCA XQVEKG YBNKMAZU YBNGBAL JON I TSZM JYIM. VRAG VOHT VRAU C TKSG. DDWUO XITLAZU VAVV RAZ C VKB QP IWPOU, it would look like the string shown in <a href="#calibre_link-38" class="calibre8">Figure 20-1</a>. The figure also shows the repeated sequences in this string&mdash;VRA, AZU, and YBN&mdash;and the number of letters between each sequence pair.</p>
<div class="image"><img src="images/00035.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-38" class="calibre8"></a><em class="calibre7">Figure 20-1: The repeated sequences in the example string</em></p>
<p class="indent">In this example, there are several potential key lengths. The next step of the Kasiski examination is to calculate all the factors of these counts to narrow down the potential key lengths.</p>
<h4 class="h2" id="calibre_link-48"><strong class="calibre3"><em class="calibre12">Getting Factors of Spacings</em></strong></h4>
<p class="noindent">The spacings between the sequences are 8, 8, 24, 32, and 48 in the example. But the factors of the spacings are more important than the spacings.</p>
<p class="indent">To see why, look at the message THEDOGANDTHECAT in <a href="#calibre_link-39" class="calibre8">Table 20-1</a> and try to encrypt it with the nine-letter key ABCDEFGHI and the three-letter key XYZ. Each key repeats for the length of the message.</p>
<p class="tabcap"><a id="calibre_link-39" class="calibre8"></a><strong class="calibre5">Table 20-1:</strong> Encrypting THEDOGANDTHECAT with Two Different Keys</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"></td>
<td class="table_th"><p class="table"><strong class="calibre5">Encrypting with ABCDEFGHI</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Encrypting with XYZ</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18"><p class="table"><strong class="calibre5">Plaintext message</strong></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">THE</span><span class="literal">DOGAND</span><span class="codestrong">THE</span><span class="literal">CAT</span></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">THE</span><span class="literal">DOGAND</span><span class="codestrong">THE</span><span class="literal">CAT</span></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><strong class="calibre5">Key (repeating)</strong></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">ABC</span><span class="literal">DEFGHI</span><span class="codestrong">ABC</span><span class="literal">DEF</span></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">XYZ</span><span class="literal">XYZXYZ</span><span class="codestrong">XYZ</span><span class="literal">XYZ</span></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><strong class="calibre5">Ciphertext</strong></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">TIG</span><span class="literal">GSLGUL</span><span class="codestrong">TIG</span><span class="literal">FEY</span></p></td>
<td class="calibre18"><p class="table"><span class="codestrong">QFD</span><span class="literal">AMFXLC</span><span class="codestrong">QFD</span><span class="literal">ZYS</span></p></td>
</tr></tbody></table>
<p class="indent">The two keys produce two different ciphertexts, as expected. Of course, the hacker won’t know the original message or the key, but they will see in the <strong class="calibre5">TIG</strong>GSLGUL<strong class="calibre5">TIG</strong>FEY ciphertext that the sequence TIG appears at index 0 and index 9. Because 9 &ndash; 0 = 9, the spacing between these sequences is 9, which would seem to indicate that the original key was a nine-letter key; in this case, that indication is correct.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-232"></span>However, the <strong class="calibre5">QFD</strong>AMFXLC<strong class="calibre5">QFD</strong>ZYS ciphertext also produces a repeated sequence (QFD) that appears at index 0 and index 9. The spacing between these sequences is also 9, indicating that the key used in this ciphertext was also nine letters long. But we know that the key is only three letters long: XYZ.</p>
<p class="indent">The repeated sequences occur when the same letters in the message (THE in our example) are encrypted with the same letters of the key (ABC and XYZ in our example), which happens when the similar letters in the message and key “line up” and encrypt to the same sequence. This alignment can happen at any multiple of the real key length (such as 3, 6, 9, 12, and so on), which is why the three-letter key can produce a repeated sequence with a spacing of 9.</p>
<p class="indent">So the possible key length is due not just to the spacing but any factor of that spacing. The factors of 9 are 9, 3, and 1. Therefore, if you find repeated sequences with a spacing of 9, you must consider that the key could be of length 9 or 3. We can ignore 1 because a Vigenère cipher with a one-letter key is just the Caesar cipher.</p>
<p class="indent">Step 2 of Kasiski examination involves finding each of the spacings’ factors (excluding 1), as shown in <a href="#calibre_link-40" class="calibre8">Table 20-2</a>.</p>
<p class="tabcap"><a id="calibre_link-40" class="calibre8"></a><strong class="calibre5">Table 20-2:</strong> Factors of Each Spacing</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"><p class="table"><strong class="calibre5">Spacing</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Factors</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18"><p class="table">8</p></td>
<td class="calibre18"><p class="table">2, 4, 8</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">24</p></td>
<td class="calibre18"><p class="table">2, 4, 6, 8, 12, 24</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">32</p></td>
<td class="calibre18"><p class="table">2, 4, 8, 16</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">48</p></td>
<td class="calibre18"><p class="table">2, 4, 6, 8, 12, 24, 48</p></td>
</tr></tbody></table>
<p class="indent">Collectively, the numbers 8, 8, 24, 32, and 48 have the following factors: 2, 2, 2, 2, 4, 4, 4, 4, 6, 6, 8, 8, 8, 8, 12, 12, 16, 24, 24, and 48.</p>
<p class="indent">The key is most likely to be the most frequently occurring factors, which you can determine by counting. Because 2, 4, and 8 are the most frequently occurring factors of the spacings, they are the most likely lengths of the Vigenère key.</p>
<h4 class="h2" id="calibre_link-745"><strong class="calibre3"><em class="calibre12">Getting Every Nth Letters from a String</em></strong></h4>
<p class="noindent">Now that we have possible lengths of the Vigenère key, we can use this information to decrypt the message one subkey at a time. For this example, let’s assume that the key length is 4. If we’re unable to crack this ciphertext, we can try again assuming the key length is 2 or 8.</p>
<p class="indent">Because the key is cycled through to encrypt the plaintext, a key length of 4 would mean that starting from the first letter, every fourth letter in the ciphertext is encrypted using the first subkey, every fourth letter starting from the second letter of the plaintext is encrypted using the second subkey, and so on. Using this information, we’ll form strings from the ciphertext of the letters that have been encrypted by the same subkey. First, let’s <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-245"></span>identify what every fourth letter in the string would be if we started from different letters. Then we’ll combine the letters into a single string. In these examples, we’ll bold every fourth letter.</p>
<p class="indent">Identify every fourth letter starting with the <em class="calibre7">first</em> letter:</p>
<p class="programs1"><span class="codestrong">P</span>PQC<span class="codestrong">A</span>XQV<span class="codestrong">E</span>KGY<span class="codestrong">B</span>NKM<span class="codestrong">A</span>ZUY<span class="codestrong">B</span>NGB<span class="codestrong">A</span>LJO<span class="codestrong">N</span>ITS<span class="codestrong">Z</span>MJY<span class="codestrong">I</span>MVR<span class="codestrong">A</span>GVO<span class="codestrong">H</span>TVR<span class="codestrong">A</span>UCT<span class="codestrong">K</span>SGD<span class="codestrong">D</span>WUO<span class="codestrong">X</span>ITL<span class="codestrong">A</span>ZUV<span class="codestrong">A</span>VVR<span class="codestrong">A</span>ZCV<br class="calibre9" /><span class="codestrong">K</span>BQP<span class="codestrong">I</span>WPO<span class="codestrong">U</span></p>
<p class="indent">Next, we find every fourth letter starting with the <em class="calibre7">second</em> letter:</p>
<p class="programs1">P<span class="codestrong">P</span>QCA<span class="codestrong">X</span>QVE<span class="codestrong">K</span>GYB<span class="codestrong">N</span>KMA<span class="codestrong">Z</span>UYB<span class="codestrong">N</span>GBA<span class="codestrong">L</span>JON<span class="codestrong">I</span>TSZ<span class="codestrong">M</span>JYI<span class="codestrong">M</span>VRA<span class="codestrong">G</span>VOH<span class="codestrong">T</span>VRA<span class="codestrong">U</span>CTK<span class="codestrong">S</span>GDD<span class="codestrong">W</span>UOX<span class="codestrong">I</span>TLA<span class="codestrong">Z</span>UVA<span class="codestrong">V</span>VRA<span class="codestrong">Z</span>CV<br class="calibre9" />K<span class="codestrong">B</span>QPI<span class="codestrong">W</span>POU</p>
<p class="indent">Then we do the same starting with the <em class="calibre7">third</em> letter and <em class="calibre7">fourth</em> letter until we reach the length of the subkey we’re testing. <a href="#calibre_link-41" class="calibre8">Table 20-3</a> shows the combined strings of the bolded letters for each iteration.</p>
<p class="tabcap"><a id="calibre_link-41" class="calibre8"></a><strong class="calibre5">Table 20-3:</strong> Strings of Every Fourth Letter</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"><p class="table"><strong class="calibre5">Starting with</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">String</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18"><p class="table">First letter</p></td>
<td class="calibre18"><p class="table"><span class="literal">PAEBABANZIAHAKDXAAAKIU</span></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">Second letter</p></td>
<td class="calibre18"><p class="table"><span class="literal">PXKNZNLIMMGTUSWIZVZBW</span></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">Third letter</p></td>
<td class="calibre18"><p class="table"><span class="literal">QQGKUGJTJVVVCGUTUVCQP</span></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table">Fourth letter</p></td>
<td class="calibre18"><p class="table"><span class="literal">CVYMYBOSYRORTDOLVRVPO</span></p></td>
</tr></tbody></table>
<h4 class="h2" id="calibre_link-746"><strong class="calibre3"><em class="calibre12">Using Frequency Analysis to Break Each Subkey</em></strong></h4>
<p class="noindent">If we guessed the correct key length, each of the four strings we created in the previous section would have been encrypted with one subkey. This means that when a string is decrypted with the correct subkey and undergoes frequency analysis, the decrypted letters are likely to have a high English frequency match score. Let’s see how this process works using the first string, <span class="literal">PAEBABANZIAHAKDXAAAKIU</span>, as an example.</p>
<p class="indent">First, we decrypt the string 26 times (once for each of the 26 possible subkeys) using the Vigenère decryption function in <a href="#calibre_link-31" class="calibre8">Chapter 18</a>, <span class="literal">vigenereCipher.decryptMessage()</span>. Then we test each decrypted string using the English frequency analysis function in <a href="#calibre_link-42" class="calibre8">Chapter 19</a>, <span class="literal">freqAnalysis.</span><span class="literal">englishFreqMatchScore</span><span class="literal">()</span>. Run the following code in the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import freqAnalysis, vigenereCipher</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">for subkey in 'ABCDEFGHJIJKLMNOPQRSTUVWXYZ':</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">decryptedMessage = vigenereCipher.decryptMessage(subkey,</span> <br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'PAEBABANZIAHAKDXAAAKIU')</span><br class="calibre9" />...&nbsp;&nbsp;&nbsp;<span class="codestrong">print(subkey, decryptedMessage,</span> <br class="calibre9" /><span class="codestrong">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqAnalysis.englishFreqMatchScore(</span><span class="codestrong">decryptedMessage</span><span class="codestrong">))</span><br class="calibre9" />...<br class="calibre9" />A PAEBABANZIAHAKDXAAAKIU 2<br class="calibre9" />B OZDAZAZMYHZGZJCWZZZJHT 1<br class="calibre9" />--<span class="codeitalic">snip</span>--</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-249"></span><a href="#calibre_link-43" class="calibre8">Table 20-4</a> shows the results.</p>
<p class="tabcap"><a id="calibre_link-43" class="calibre8"></a><strong class="calibre5">Table 20-4:</strong> English Frequency Match Score for Each Decryption</p>
<table class="topbot">
<tbody class="calibre17">
<tr class="table_w">
<td class="table_th"><p class="table"><strong class="calibre5">Subkey</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Decryption</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">English frequency match score</strong></p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'A'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'PAEBABANZIAHAKDXAAAKIU'</span></p></td>
<td class="calibre18"><p class="table">2</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'B'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'OZDAZAZMYHZGZJCWZZZJHT'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'C'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'NYCZYZYLXGYFYIBVYYYIGS'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'D'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'MXBYXYXKWFXEXHAUXXXHFR'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'E'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'LWAXWXWJVEWDWGZTWWWGEQ'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'F'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'KVZWVWVIUDVCVFYSVVVFDP'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'G'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'JUYVUVUHTCUBUEXRUUUECO'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'H'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'ITXUTUTGSBTATDWQTTTDBN'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'I'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'HSWTSTSFRASZSCVPSSSCAM'</span></p></td>
<td class="calibre18"><p class="table">2</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'J'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'GRVSRSREQZRYRBUORRRBZL'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'K'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'FQURQRQDPYQXQATNQQQAYK'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'L'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'EPTQPQPCOXPWPZSMPPPZXJ'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'M'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'DOSPOPOBNWOVOYRLOOOYWI'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'N'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'CNRONONAMVNUNXQKNNNXVH'</span></p></td>
<td class="calibre18"><p class="table">2</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'O'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'BMQNMNMZLUMTMWPJMMMWUG'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'P'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'ALPMLMLYKTLSLVOILLLVTF'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'Q'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'ZKOLKLKXJSKRKUNHKKKUSE'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'R'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'YJNKJKJWIRJQJTMGJJJTRD'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'S'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'XIMJIJIVHQIPISLFIIISQC'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'T'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'WHLIHIHUGPHOHRKEHHHRPB'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'U'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'VGKHGHGTFOGNGQJDGGGQOA'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'V'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'UFJGFGFSENFMFPICFFFPNZ'</span></p></td>
<td class="calibre18"><p class="table">1</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'W'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'TEIFEFERDMELEOHBEEEOMY'</span></p></td>
<td class="calibre18"><p class="table">2</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'X'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'SDHEDEDQCLDKDNGADDDNLX'</span></p></td>
<td class="calibre18"><p class="table">2</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'Y'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'RCGDCDCPBKCJCMFZCCCMKW'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">'Z'</span></p></td>
<td class="calibre18"><p class="table"><span class="literal">'QBFCBCBOAJBIBLEYBBBLJV'</span></p></td>
<td class="calibre18"><p class="table">0</p></td>
</tr></tbody></table>
<p class="indent">The subkeys that produce decryptions with the closest frequency match to English are most likely to be the real subkey. In <a href="#calibre_link-43" class="calibre8">Table 20-4</a>, the subkeys <span class="literal">'A'</span>, <span class="literal">'I'</span>, <span class="literal">'N'</span>, <span class="literal">'W'</span>, and <span class="literal">'X'</span> result in the highest frequency match scores for the first string. Note that these scores are low in general because there isn’t enough ciphertext to give us a large sample of text, but they work well enough for this example.</p>
<p class="indent">The next step is to repeat this process for the other three strings to find their most likely subkeys. <a href="#calibre_link-44" class="calibre8">Table 20-5</a> shows the final results.</p>
<p class="tabcap"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-246"></span><a id="calibre_link-44" class="calibre8"></a><strong class="calibre5">Table 20-5:</strong> Most Likely Subkeys for the Example Strings</p>
<table class="topbot">
<thead class="calibre16">
<tr class="table_w">
<td class="table_th"><p class="table"><strong class="calibre5">Ciphertext string</strong></p></td>
<td class="table_th"><p class="table"><strong class="calibre5">Most likely subkeys</strong></p></td>
</tr>
</thead>
<tbody class="calibre17">
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">PAEBABANZIAHAKDXAAAKIU</span></p></td>
<td class="calibre18"><p class="table">A, I, N, W, X</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">PXKNZNLIMMGTUSWIZVZBW</span></p></td>
<td class="calibre18"><p class="table">I, Z</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">QQGKUGJTJVVVCGUTUVCQP</span></p></td>
<td class="calibre18"><p class="table">C</p></td>
</tr>
<tr class="table_w">
<td class="calibre18"><p class="table"><span class="literal">CVYMYBOSYRORTDOLVRVPO</span></p></td>
<td class="calibre18"><p class="table">K, N, R, V, Y</p></td>
</tr></tbody></table>
<p class="indent">Because there are five possible subkeys for the first subkey, two for the second subkey, one for the third subkey, and five for the fourth subkey, the total number of combinations is 50 (which we get from multiplying all the possible subkeys 5 × 2 × 1 × 5). In other words, we need to brute-force 50 possible keys. But this is much better than brute-forcing through 26 × 26 × 26 × 26 (or 456,976) possible keys, our task had we not narrowed down the list of possible subkeys. This difference becomes even greater if the Vigenère key is longer!</p>
<h4 class="h2" id="calibre_link-747"><strong class="calibre3"><em class="calibre12">Brute-Forcing Through the Possible Keys</em></strong></h4>
<p class="noindentb">To brute-force the key, we’ll try every combination of the likely subkeys. All 50 possible subkey combinations are listed as follows:</p>
<div class="imagea"><img src="images/00036.jpeg" alt="Images" class="calibre4" /></div>
<p class="indentt">The final step in our Vigenère hacking program will be to test all 50 of these decryption keys on the full ciphertext to see which produces readable English plaintext. Doing so should reveal that the key to the “PPQCA XQVEKG…” ciphertext is WICK.</p>
<h3 class="h1" id="calibre_link-748"><strong class="calibre3">Source Code for the Vigenère Hacking Program</strong></h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Make sure the <em class="calibre7">detectEnglish.py</em>, <em class="calibre7">freqAnalysis.py</em>, <em class="calibre7">vigenereCipher.py</em>, and <em class="calibre7">pyperclip.py</em> files are in the same directory as the <em class="calibre7">vigenereHacker.py</em> file. Then enter the following code into the file editor and save it as <em class="calibre7">vigenereHacker.py</em>. Press F5 to run the program.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-971"></span>The ciphertext on line 17 in this program is difficult to copy from the book. To avoid typos, copy and paste it from the book’s website at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>. You can check for any differences between the text in your program and the text of the program in this book by using the online diff tool on the book’s website.</p>
<p class="noindentz"><em class="calibre7">vigenere<br class="calibre9" />Hacker.py</em></p>
<p class="programs1">&nbsp;&nbsp;1. # Vigenere Cipher Hacker<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import itertools, re<br class="calibre9" />&nbsp;&nbsp;5. import vigenereCipher, pyperclip, freqAnalysis, detectEnglish<br class="calibre9" />&nbsp;&nbsp;6.<br class="calibre9" />&nbsp;&nbsp;7. LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'<br class="calibre9" />&nbsp;&nbsp;8. MAX_KEY_LENGTH = 16 # Will not attempt keys longer than this.<br class="calibre9" />&nbsp;&nbsp;9. NUM_MOST_FREQ_LETTERS = 4 # Attempt this many letters per subkey.<br class="calibre9" />&nbsp;10. SILENT_MODE = False # If set to True, program doesn't print anything.<br class="calibre9" />&nbsp;11. NONLETTERS_PATTERN = re.compile('[^A-Z]')<br class="calibre9" />&nbsp;12.<br class="calibre9" />&nbsp;13.<br class="calibre9" />&nbsp;14. def main():<br class="calibre9" />&nbsp;15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Instead of typing this ciphertext out, you can copy &amp; paste it<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# from https://www.nostarch.com/crackingcodes/:<br class="calibre9" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = """Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lgouqdaf, kdmktsvmztsl, izr xoexghzr kkusitaaf. Vz wsa twbhdg<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ubalmmzhdad qz<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;azmtmd'g widt ion bwnafz tzm Tcpsw wr Zjrva ivdcz eaigd yzmbo<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmzubb a kbmhptgzk dvrvwz wa efiohzd."""<br class="calibre9" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = hackVigenere(ciphertext)<br class="calibre9" />&nbsp;19.<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Failed to hack encryption.')<br class="calibre9" />&nbsp;26.<br class="calibre9" />&nbsp;27.<br class="calibre9" />&nbsp;28. def findRepeatSequencesSpacings(message):<br class="calibre9" />&nbsp;29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Goes through the message and finds any 3- to 5-letter sequences<br class="calibre9" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# that are repeated. Returns a dict with the keys of the sequence and<br class="calibre9" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# values of a list of spacings (num of letters between the repeats).<br class="calibre9" />&nbsp;32.<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use a regular expression to remove non-letters from the message:<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = NONLETTERS_PATTERN.sub('', message.upper())<br class="calibre9" />&nbsp;35.<br class="calibre9" />&nbsp;36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Compile a list of seqLen-letter sequences found in the message:<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings = {} # Keys are sequences; values are lists of int spacings.<br class="calibre9" />&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seqLen in range(3, 6):<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seqStart in range(len(message) - seqLen):<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine what the sequence is and store it in seq:<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq = message[seqStart:seqStart + seqLen]<br class="calibre9" />&nbsp;42.<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-972"></span>&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Look for this sequence in the rest of the message:<br class="calibre9" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(seqStart + seqLen, len(message) - seqLen):<br class="calibre9" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if message[i:i + seqLen] == seq:<br class="calibre9" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Found a repeated sequence:<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if seq not in seqSpacings:<br class="calibre9" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings[seq] = [] # Initialize blank list.<br class="calibre9" />&nbsp;49.<br class="calibre9" />&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Append the spacing distance between the repeated<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# sequence and the original sequence:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings[seq].append(i - seqStart)<br class="calibre9" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return seqSpacings<br class="calibre9" />&nbsp;54.<br class="calibre9" />&nbsp;55.<br class="calibre9" />&nbsp;56. def getUsefulFactors(num):<br class="calibre9" />&nbsp;57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a list of useful factors of num. By "useful" we mean factors<br class="calibre9" />&nbsp;58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# less than MAX_KEY_LENGTH + 1 and not 1. For example,<br class="calibre9" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# getUsefulFactors(144) returns [2, 3, 4, 6, 8, 9, 12, 16].<br class="calibre9" />&nbsp;60.<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num &lt; 2:<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [] # Numbers less than 2 have no useful factors.<br class="calibre9" />&nbsp;63.<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors = [] # The list of factors found.<br class="calibre9" />&nbsp;65.<br class="calibre9" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# When finding factors, you only need to check the integers up to<br class="calibre9" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# MAX_KEY_LENGTH:<br class="calibre9" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, MAX_KEY_LENGTH + 1): # Don't test 1: it's not useful.<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % i == 0:<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors.append(i)<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherFactor = int(num / i)<br class="calibre9" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if otherFactor &lt; MAX_KEY_LENGTH + 1 and otherFactor != 1:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors.append(otherFactor)<br class="calibre9" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return list(set(factors)) # Remove duplicate factors.<br class="calibre9" />&nbsp;75.<br class="calibre9" />&nbsp;76.<br class="calibre9" />&nbsp;77. def getItemAtIndexOne(x):<br class="calibre9" />&nbsp;78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x[1]<br class="calibre9" />&nbsp;79.<br class="calibre9" />&nbsp;80.<br class="calibre9" />&nbsp;81. def getMostCommonFactors(seqFactors):<br class="calibre9" />&nbsp;82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, get a count of how many times a factor occurs in seqFactors:<br class="calibre9" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts = {} # Key is a factor; value is how often it occurs.<br class="calibre9" />&nbsp;84.<br class="calibre9" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# seqFactors keys are sequences; values are lists of factors of the<br class="calibre9" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# spacings. seqFactors has a value like {'GFD': [2, 3, 4, 6, 9, 12,<br class="calibre9" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# 18, 23, 36, 46, 69, 92, 138, 207], 'ALW': [2, 3, 4, 6, ...], ...}.<br class="calibre9" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seq in seqFactors:<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorList = seqFactors[seq]<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for factor in factorList:<br class="calibre9" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if factor not in factorCounts:<br class="calibre9" />&nbsp;92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts[factor] = 0<br class="calibre9" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts[factor] += 1<br class="calibre9" />&nbsp;94.<br class="calibre9" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Second, put the factor and its count into a tuple and make a list<br class="calibre9" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# of these tuples so we can sort them:<br class="calibre9" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount = []<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-973"></span>&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for factor in factorCounts:<br class="calibre9" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exclude factors larger than MAX_KEY_LENGTH:<br class="calibre9" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if factor &lt;= MAX_KEY_LENGTH:<br class="calibre9" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# factorsByCount is a list of tuples: (factor, factorCount).<br class="calibre9" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# factorsByCount has a value like [(3, 497), (2, 487), ...].<br class="calibre9" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount.append( (factor, factorCounts[factor]) )<br class="calibre9" />104.<br class="calibre9" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Sort the list by the factor count:<br class="calibre9" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount.sort(key=getItemAtIndexOne, reverse=True)<br class="calibre9" />107.<br class="calibre9" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return factorsByCount<br class="calibre9" />109.<br class="calibre9" />110.<br class="calibre9" />111. def kasiskiExamination(ciphertext):<br class="calibre9" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Find out the sequences of 3 to 5 letters that occur multiple times<br class="calibre9" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# in the ciphertext. repeatedSeqSpacings has a value like<br class="calibre9" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# {'EXG': [192], 'NAF': [339, 972, 633], ... }:<br class="calibre9" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeatedSeqSpacings = findRepeatSequencesSpacings(ciphertext)<br class="calibre9" />116.<br class="calibre9" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# (See getMostCommonFactors() for a description of seqFactors.)<br class="calibre9" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors = {}<br class="calibre9" />119.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seq in repeatedSeqSpacings:<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors[seq] = []<br class="calibre9" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for spacing in repeatedSeqSpacings[seq]:<br class="calibre9" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors[seq].extend(getUsefulFactors(spacing))<br class="calibre9" />123.<br class="calibre9" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# (See getMostCommonFactors() for a description of factorsByCount.)<br class="calibre9" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount = getMostCommonFactors(seqFactors)<br class="calibre9" />126.<br class="calibre9" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Now we extract the factor counts from factorsByCount and<br class="calibre9" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# put them in allLikelyKeyLengths so that they are easier to<br class="calibre9" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# use later:<br class="calibre9" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths = []<br class="calibre9" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for twoIntTuple in factorsByCount:<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths.append(twoIntTuple[0])<br class="calibre9" />133.<br class="calibre9" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return allLikelyKeyLengths<br class="calibre9" />135.<br class="calibre9" />136.<br class="calibre9" />137. def getNthSubkeysLetters(nth, keyLength, message):<br class="calibre9" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns every nth letter for each keyLength set of letters in text.<br class="calibre9" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# E.g. getNthSubkeysLetters(1, 3, 'ABCABCABC') returns 'AAA'<br class="calibre9" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getNthSubkeysLetters(2, 3, 'ABCABCABC') returns 'BBB'<br class="calibre9" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getNthSubkeysLetters(3, 3, 'ABCABCABC') returns 'CCC'<br class="calibre9" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getNthSubkeysLetters(1, 5, 'ABCDEFGHI') returns 'AF'<br class="calibre9" />143.<br class="calibre9" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use a regular expression to remove non-letters from the message:<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = NONLETTERS_PATTERN.sub('', message.upper())<br class="calibre9" />146.<br class="calibre9" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = nth - 1<br class="calibre9" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters = []<br class="calibre9" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while i &lt; len(message):<br class="calibre9" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters.append(message[i])<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += keyLength<br class="calibre9" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(letters)<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-974"></span>153.<br class="calibre9" />154.<br class="calibre9" />155. def attemptHackWithKeyLength(ciphertext, mostLikelyKeyLength):<br class="calibre9" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the most likely letters for each letter in the key:<br class="calibre9" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp = ciphertext.upper()<br class="calibre9" />158.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# allFreqScores is a list of mostLikelyKeyLength number of lists.<br class="calibre9" />159.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# These inner lists are the freqScores lists:<br class="calibre9" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFreqScores = []<br class="calibre9" />161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for nth in range(1, mostLikelyKeyLength + 1):<br class="calibre9" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nthLetters = getNthSubkeysLetters(nth, mostLikelyKeyLength,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp)<br class="calibre9" />163.<br class="calibre9" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# freqScores is a list of tuples like<br class="calibre9" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# [(&lt;letter&gt;, &lt;Eng. Freq. match score&gt;), ... ]<br class="calibre9" />166.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# List is sorted by match score. Higher score means better match.<br class="calibre9" />167.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# See the englishFreqMatchScore() comments in freqAnalysis.py.<br class="calibre9" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores = []<br class="calibre9" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for possibleKey in LETTERS:<br class="calibre9" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = vigenereCipher.decryptMessage(possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nthLetters)<br class="calibre9" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyAndFreqMatchTuple = (possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqAnalysis.englishFreqMatchScore(decryptedText))<br class="calibre9" />172.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores.append(keyAndFreqMatchTuple)<br class="calibre9" />173.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Sort by match score:<br class="calibre9" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores.sort(key=getItemAtIndexOne, reverse=True)<br class="calibre9" />175.<br class="calibre9" />176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFreqScores.append(freqScores[:NUM_MOST_FREQ_LETTERS])<br class="calibre9" />177.<br class="calibre9" />178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />179.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(allFreqScores)):<br class="calibre9" />180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use i + 1 so the first letter is not called the "0th" letter:<br class="calibre9" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible letters for letter %s of the key: ' % (i + 1),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end='')<br class="calibre9" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freqScore in allFreqScores[i]:<br class="calibre9" />183.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%s ' % freqScore[0], end='')<br class="calibre9" />184.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print() # Print a newline.<br class="calibre9" />185.<br class="calibre9" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try every combination of the most likely letters for each position<br class="calibre9" />187.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# in the key:<br class="calibre9" />188.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for indexes in itertools.product(range(NUM_MOST_FREQ_LETTERS),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat=mostLikelyKeyLength):<br class="calibre9" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a possible key from the letters in allFreqScores:<br class="calibre9" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleKey = ''<br class="calibre9" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(mostLikelyKeyLength):<br class="calibre9" />192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleKey += allFreqScores[i][indexes[i]][0]<br class="calibre9" />193.<br class="calibre9" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting with key: %s' % (possibleKey))<br class="calibre9" />196.<br class="calibre9" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = vigenereCipher.decryptMessage(possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp)<br class="calibre9" />198.<br class="calibre9" />199.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if detectEnglish.isEnglish(decryptedText):<br class="calibre9" />200.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Set the hacked ciphertext to the original casing:<br class="calibre9" />201.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase = []<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-975"></span>202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(ciphertext)):<br class="calibre9" />203.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ciphertext[i].isupper():<br class="calibre9" />204.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase.append(decryptedText[i].upper())<br class="calibre9" />205.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />206.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase.append(decryptedText[i].lower())<br class="calibre9" />207.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = ''.join(origCase)<br class="calibre9" />208.<br class="calibre9" />209.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check with user to see if the key has been found:<br class="calibre9" />210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible encryption hack with key %s:' % (possibleKey))<br class="calibre9" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(decryptedText[:200]) # Only show first 200 characters.<br class="calibre9" />212.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter D if done, anything else to continue hacking:')<br class="calibre9" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = input('&gt; ')<br class="calibre9" />215.<br class="calibre9" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if response.strip().upper().startswith('D'):<br class="calibre9" />217.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptedText<br class="calibre9" />218.<br class="calibre9" />219.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# No English-looking decryption found, so return None:<br class="calibre9" />220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None<br class="calibre9" />221.<br class="calibre9" />222.<br class="calibre9" />223. def hackVigenere(ciphertext):<br class="calibre9" />224.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, we need to do Kasiski examination to figure out what the<br class="calibre9" />225.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# length of the ciphertext's encryption key is:<br class="calibre9" />226.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths = kasiskiExamination(ciphertext)<br class="calibre9" />227.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />228.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLengthStr = ''<br class="calibre9" />229.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in allLikelyKeyLengths:<br class="calibre9" />230.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLengthStr += '%s ' % (keyLength)<br class="calibre9" />231.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Kasiski examination results say the most likely key lengths<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are: ' + keyLengthStr + '\n')<br class="calibre9" />232.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = None<br class="calibre9" />233.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in allLikelyKeyLengths:<br class="calibre9" />234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting hack with key length %s (%s possible keys)...'<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength))<br class="calibre9" />236.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength)<br class="calibre9" />237.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />238.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre9" />239.<br class="calibre9" />240.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If none of the key lengths found using Kasiski examination<br class="calibre9" />241.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# worked, start brute-forcing through key lengths:<br class="calibre9" />242.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage == None:<br class="calibre9" />243.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />244.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Unable to hack message with likely key length(s). Brute-<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forcing key length...')<br class="calibre9" />245.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in range(1, MAX_KEY_LENGTH + 1):<br class="calibre9" />246.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Don't recheck key lengths already tried from Kasiski:<br class="calibre9" />247.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyLength not in allLikelyKeyLengths:<br class="calibre9" />248.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />249.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting hack with key length %s (%s possible<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS **<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLength))<br class="calibre9" />250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = attemptHackWithKeyLength(ciphertext,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLength)<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-976"></span>251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre9" />253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hackedMessage<br class="calibre9" />254.<br class="calibre9" />255.<br class="calibre9" />256. # If vigenereHacker.py is run (instead of imported as a module), call<br class="calibre9" />257. # the main() function:<br class="calibre9" />258. if __name__ == '__main__':<br class="calibre9" />259.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-749"><strong class="calibre3">Sample Run of the Vigenère Hacking Program</strong></h3>
<p class="noindent">When you run the <em class="calibre7">vigenereHacker.py</em> program, the output should look like this:</p>
<p class="programs1">Kasiski examination results say the most likely key lengths are: 3 2 6 4 12<br class="calibre9" />Attempting hack with key length 3 (27 possible keys)...<br class="calibre9" />Possible letters for letter 1 of the key: A L M<br class="calibre9" />Possible letters for letter 2 of the key: S N O<br class="calibre9" />Possible letters for letter 3 of the key: V I Z<br class="calibre9" />Attempting with key: ASV<br class="calibre9" />Attempting with key: ASI<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />Attempting with key: MOI<br class="calibre9" />Attempting with key: MOZ<br class="calibre9" />Attempting hack with key length 2 (9 possible keys)...<br class="calibre9" />Possible letters for letter 1 of the key: O A E<br class="calibre9" />Possible letters for letter 2 of the key: M S I<br class="calibre9" />Attempting with key: OM<br class="calibre9" />Attempting with key: OS<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />Attempting with key: ES<br class="calibre9" />Attempting with key: EI<br class="calibre9" />Attempting hack with key length 6 (729 possible keys)...<br class="calibre9" />Possible letters for letter 1 of the key: A E O<br class="calibre9" />Possible letters for letter 2 of the key: S D G<br class="calibre9" />Possible letters for letter 3 of the key: I V X<br class="calibre9" />Possible letters for letter 4 of the key: M Z Q<br class="calibre9" />Possible letters for letter 5 of the key: O B Z<br class="calibre9" />Possible letters for letter 6 of the key: V I K<br class="calibre9" />Attempting with key: ASIMOV<br class="calibre9" />Possible encryption hack with key ASIMOV:<br class="calibre9" />ALAN MATHISON TURING WAS A BRITISH MATHEMATICIAN, LOGICIAN, CRYPTANALYST, AND<br class="calibre9" />COMPUTER SCIENTIST. HE WAS HIGHLY INFLUENTIAL IN THE DEVELOPMENT OF COMPUTER<br class="calibre9" />SCIENCE, PROVIDING A FORMALISATION OF THE CON<br class="calibre9" />Enter D for done, or just press Enter to continue hacking:<br class="calibre9" />&gt; <span class="codestrong">d</span><br class="calibre9" />Copying hacked message to clipboard:<br class="calibre9" />Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and<br class="calibre9" />computer scientist. He was highly influential in the development of computer<br class="calibre9" />--<span class="codeitalic">snip</span>--</p>
<h3 class="h1" id="calibre_link-750"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-291" class="calibre1"></span><strong class="calibre3">Importing Modules and Setting Up the main() Function</strong></h3>
<p class="noindent">Let’s look at the source code for the Vigenère hacking program. The hacking program imports many different modules, including a new module named <span class="literal">itertools</span>, which you’ll learn more about soon:</p>
<p class="programs1">&nbsp;&nbsp;1. # Vigenere Cipher Hacker<br class="calibre9" />&nbsp;&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;&nbsp;3.<br class="calibre9" />&nbsp;&nbsp;4. import itertools, re<br class="calibre9" />&nbsp;&nbsp;5. import vigenereCipher, pyperclip, freqAnalysis, detectEnglish</p>
<p class="indent">In addition, the program sets up several constants on lines 7 to 11, which I’ll explain later when they’re used in the program.</p>
<p class="indent">The <span class="literal">main()</span> function of the hacking program is similar to the <span class="literal">main()</span> functions in previous hacking functions:</p>
<p class="programs1">&nbsp;14. def main():<br class="calibre9" />&nbsp;15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Instead of typing this ciphertext out, you can copy &amp; paste it<br class="calibre9" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# from https://www.nostarch.com/crackingcodes/:<br class="calibre9" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertext = """Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lgouqdaf, kdmktsvmztsl, izr xoexghzr kkusitaaf. Vz wsa twbhdg<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ubalmmzhdad qz<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;azmtmd'g widt ion bwnafz tzm Tcpsw wr Zjrva ivdcz eaigd yzmbo<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tmzubb a kbmhptgzk dvrvwz wa efiohzd."""<br class="calibre9" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = hackVigenere(ciphertext)<br class="calibre9" />&nbsp;19.<br class="calibre9" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Copying hacked message to clipboard:')<br class="calibre9" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(hackedMessage)<br class="calibre9" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pyperclip.copy(hackedMessage)<br class="calibre9" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Failed to hack encryption.')</p>
<p class="indent">The ciphertext is passed to the <span class="literal">hackVigenere()</span> function, which either returns the decrypted string if the hack is successful or the <span class="literal">None</span> value if the hack fails. If successful, the program prints the hacked message to the screen and copies it to the clipboard.</p>
<h3 class="h1" id="calibre_link-47"><strong class="calibre3">Finding Repeated Sequences</strong></h3>
<p class="noindent">The <span class="literal">findRepeatSequencesSpacings()</span> function accomplishes the first step of the Kasiski examination by locating all the repeated sequences of letters in the <span class="literal">message</span> string and counting the spacings between the sequences:</p>
<p class="programs1">&nbsp;28. def findRepeatSequencesSpacings(message):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use a regular expression to remove non-letters from the message:<br class="calibre9" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = NONLETTERS_PATTERN.sub('', message.upper())<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-977"></span>&nbsp;35.<br class="calibre9" />&nbsp;36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Compile a list of seqLen-letter sequences found in the message:<br class="calibre9" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings = {} # Keys are sequences; values are lists of int spacings.</p>
<p class="indent">Line 34 converts the message to uppercase and removes any non-letter characters from <span class="literal">message</span> using the <span class="literal">sub()</span> regular expression method.</p>
<p class="indent">The <span class="literal">seqSpacings</span> dictionary on line 37 holds repeated sequence strings as its keys and a list with integers representing the number of letters between all the occurrences of that sequence as its values. For example, if we pass the <span class="literal">'PPQCAXQV...'</span> example string as <span class="literal">message</span>, the <span class="literal">findRepeatSequenceSpacings()</span> function would return <span class="literal">{'VRA': [8, 24, 32], 'AZU': [48], 'YBN': [8]}</span>.</p>
<p class="indent">The <span class="literal">for</span> loop on line 38 checks whether each sequence repeats by finding the sequences in <span class="literal">message</span> and calculating the spacings between repeated sequences:</p>
<p class="programs1">&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seqLen in range(3, 6):<br class="calibre9" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seqStart in range(len(message) - seqLen):<br class="calibre9" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine what the sequence is and store it in seq:<br class="calibre9" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seq = message[seqStart:seqStart + seqLen]</p>
<div class="image"><img src="images/00037.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-45" class="calibre8"></a><em class="calibre7">Figure 20-2: Values of <span class="literalcaption">seq</span> from <span class="literalcaption">message</span> depending on the value in <span class="literalcaption">seqStart</span></em></p>
<p class="indent">On the first iteration of the loop, the code finds sequences that are exactly three letters long. On the next iteration, it finds sequences exactly four letters long, and then five letters long. You can change what sequence lengths the code searches for by modifying the <span class="literal">range(3, 6)</span> call on line 38; however, finding repeated sequences of length three, four, and five seems to work for most ciphertexts. The reason is that these are long enough that repeats in the ciphertext aren’t likely to be coincidence but short enough that repeats are likely to be found. The sequence length the <span class="literal">for</span> loop is currently checking is stored in <span class="literal">seqLen</span>.</p>
<p class="indent">The <span class="literal">for</span> loop on line 39 slices <span class="literal">message</span> into every possible substring of length <span class="literal">seqLen</span>. We’ll use this <span class="literal">for</span> loop to determine the start of the slice and slice <span class="literal">message</span> into a substring <span class="literal">seqLen</span> characters long. For example, if <span class="literal">seqLen</span> is <span class="literal">3</span> and message is <span class="literal">'PPQCAXQ'</span>, we would want to start at the first index, which is <span class="literal">0</span>, and slice three characters to get the substring <span class="literal">'PPQ'</span>. Then we would want to go to the next index, which is <span class="literal">1</span>, and slice three characters to get the substring <span class="literal">'PQC'</span>. We need to do this for every index up to the last three characters, which is the index equivalent to <span class="literal">len(message) &ndash; seqLen</span>. Doing this, you would get the sequences shown in <a href="#calibre_link-45" class="calibre8">Figure 20-2</a>.</p>
<p class="indent">The <span class="literal">for</span> loop on line 39 loops through every index up to <span class="literal">len(message) &ndash; seqLen</span> and assigns the current index to start the substring slice to the variable <span class="literal">seqStart</span>. After we have the starting index, line 41 sets the <span class="literal">seq</span> variable to the substring slice.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-978"></span>We’ll search through the message for repeats of that slice using the <span class="literal">for</span> loop on line 44.</p>
<p class="programs1">&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Look for this sequence in the rest of the message:<br class="calibre9" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(seqStart + seqLen, len(message) - seqLen):<br class="calibre9" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if message[i:i + seqLen] == seq:</p>
<p class="indent">The <span class="literal">for</span> loop on line 44 is inside the <span class="literal">for</span> loop on line 39 and sets <span class="literal">i</span> to be the indexes of every possible sequence of length <span class="literal">seqLen</span> in <span class="literal">message</span>. These indexes start at <span class="literal">seqStart + seqLen</span>, or after the sequence currently in <span class="literal">seq</span>, and go up to <span class="literal">len(message) - seqLen</span>, which is the last index where a sequence of length <span class="literal">seqLen</span> can be found. For example, if <span class="literal">message</span> was <span class="literal">'PPQCAXQVEKG</span><span class="codestrong">YBN</span><span class="literal">KMAZU</span><span class="codestrong">YBN</span><span class="literal">'</span>, <span class="literal">seqStart</span> was <span class="literal">11</span>, and <span class="literal">seqLen</span> was <span class="literal">3</span>, line 41 would set <span class="literal">seq</span> to <span class="literal">'YBN'</span>. The <span class="literal">for</span> loop would begin looking at <span class="literal">message</span> starting from index <span class="literal">14</span>.</p>
<p class="indent">The expression <span class="literal">message[i:i + seqLen]</span> on line 45 evaluates to a substring of <span class="literal">message</span>, which is compared to <span class="literal">seq</span> to check whether the substring is a repeat of <span class="literal">seq</span>. If it is, lines 46 to 52 calculate the spacing and add it to the <span class="literal">seqSpacings</span> dictionary. On the first iteration, line 45 compares <span class="literal">'KMA'</span> to <span class="literal">seq</span>, then <span class="literal">'MAZ'</span> to <span class="literal">seq</span> on the next iteration, then <span class="literal">'AZU'</span> to <span class="literal">seq</span> on the next, and so on. When <span class="literal">i</span> is <span class="literal">19</span>, line 45 finds <span class="literal">'YBN'</span> is equal to <span class="literal">seq</span>, and the execution runs lines 46 to 52:</p>
<p class="programs1">&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Found a repeated sequence:<br class="calibre9" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if seq not in seqSpacings:<br class="calibre9" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings[seq] = [] # Initialize blank list.<br class="calibre9" />&nbsp;49.<br class="calibre9" />&nbsp;50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Append the spacing distance between the repeated<br class="calibre9" />&nbsp;51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# sequence and the original sequence:<br class="calibre9" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqSpacings[seq].append(i - seqStart)</p>
<p class="indent">Lines 47 and 48 check whether the <span class="literal">seq</span> variable exists as a key in <span class="literal">seqSpacings</span>. If not, <span class="literal">seqSpacings[seq]</span> is set as a key with a blank list as its value.</p>
<p class="indent">The number of letters between the sequence at <span class="literal">message[i:i + seqLen]</span> and the original sequence at <span class="literal">message[seqStart:seqStart+seqLen]</span> is simply <span class="literal">i - seqStart</span>. Notice that <span class="literal">i</span> and <span class="literal">seqStart</span> are the beginning indexes before the colons. So the integer that <span class="literal">i - seqStart</span> evaluates to is the number of letters between the two sequences, which we append to the list stored at <span class="literal">seqSpacings[seq]</span>.</p>
<p class="indent">When all these <span class="literal">for</span> loops have finished, the <span class="literal">seqSpacings</span> dictionary should contain every repeated sequence of length 3, 4, and 5 as well as the number of letters between repeated sequences. The <span class="literal">seqSpacings</span> dictionary is returned from <span class="literal">findRepeatSequencesSpacings()</span> on line 53:</p>
<p class="programs1">&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return seqSpacings</p>
<p class="indent">Now that you’ve seen how the program performs the first step of the Kasiski examination by finding repeated sequences in the ciphertext and counting the number of letters between them, let’s look at how the program conducts the next step of the Kasiski examination.</p>
<h3 class="h1" id="calibre_link-751"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-233" class="calibre1"></span><strong class="calibre3">Calculating the Factors of the Spacings</strong></h3>
<p class="noindent">Recall that the next step of the Kasiski examination involves finding the factors of the spacings. We’re looking for factors between <span class="literal">2</span> and <span class="literal">MAX_KEY_LENGTH</span> in length. To do this, we’ll create the <span class="literal">getUsefulFactors()</span> function, which takes a <span class="literal">num</span> parameter and returns a list of only those factors that meet this criteria.</p>
<p class="programs1">&nbsp;56. def getUsefulFactors(num):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num &lt; 2:<br class="calibre9" />&nbsp;62.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [] # Numbers less than 2 have no useful factors.<br class="calibre9" />&nbsp;63.<br class="calibre9" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors = [] # The list of factors found.</p>
<p class="indent">Line 61 checks for the special case where <span class="literal">num</span> is less than <span class="literal">2</span>. In this case, line 62 returns the empty list because <span class="literal">num</span> would have had no useful factors if it were less than <span class="literal">2</span>.</p>
<p class="indent">If <span class="literal">num</span> is larger than <span class="literal">2</span>, we would need to calculate all the factors of <span class="literal">num</span> and store them in a list. At line 64, we create an empty list called <span class="literal">factors</span> to store the factors.</p>
<p class="indent">The <span class="literal">for</span> loop on line 68 loops through the integers from <span class="literal">2</span> up to <span class="literal">MAX_KEY_LENGTH</span>, including the value in <span class="literal">MAX_KEY_LENGTH</span>. Remember that because <span class="literal">range()</span> causes the <span class="literal">for</span> loop to iterate up to but not including the second argument, we pass <span class="literal">MAX_KEY_LENGTH + 1</span> so that <span class="literal">MAX_KEY_LENGTH</span> is included. This loop finds all the factors of <span class="literal">num</span>.</p>
<p class="programs1">&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, MAX_KEY_LENGTH + 1): # Don't test 1: it's not useful.<br class="calibre9" />&nbsp;69.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if num % i == 0:<br class="calibre9" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors.append(i)<br class="calibre9" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherFactor = int(num / i)</p>
<p class="indent">Line 69 tests whether <span class="literal">num % i</span> is equal to <span class="literal">0</span>; if it is, we know that <span class="literal">i</span> divides <span class="literal">num</span> evenly with no remainder, which means <span class="literal">i</span> is a factor of <span class="literal">num</span>. In this case, line 70 appends <span class="literal">i</span> to the list of factors in the <span class="literal">factors</span> variable. Because we know that <span class="literal">num / i</span> must also divide <span class="literal">num</span> evenly, line 71 stores the integer form of it in <span class="literal">otherFactor</span>. (Remember that the <span class="literal">/</span> operator always evaluates to a float value, such as <span class="literal">21 / 7</span> evaluating to the float <span class="literal">3.0</span> instead of the int <span class="literal">3</span>.) If the resulting value is <span class="literal">1</span>, the program doesn’t include it in the <span class="literal">factors</span> list, so line 72 checks for this case:</p>
<p class="programs1">&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if otherFactor &lt; MAX_KEY_LENGTH + 1 and otherFactor != 1:<br class="calibre9" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factors.append(otherFactor)</p>
<p class="indent">Line 73 appends the value if it isn’t <span class="literal">1</span>. We exclude <span class="literal">1</span> because if the Vigenère key had a length of 1, the Vigenère cipher would be no different than the Caesar cipher!</p>
<h4 class="h2" id="calibre_link-752"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-312" class="calibre1"></span><strong class="calibre3"><em class="calibre12">Removing Duplicates with the set() Function</em></strong></h4>
<p class="noindent">Recall that we need to know the most common factor as part of the Kasiski examination because the most common factor will almost certainly be the length of the Vigenère key. However, before we can analyze the frequency of each factor, we’ll need to use the <span class="literal">set()</span> function to remove any duplicate factors from the <span class="literal">factors</span> list. For example, if <span class="literal">getUsefulFactors()</span> was passed <span class="literal">9</span> for the <span class="literal">num</span> parameter, then <span class="literal">9 % 3 == 0</span> would be <span class="literal">True</span> and both <span class="literal">i</span> and <span class="literal">otherFactor</span> would have been appended to <span class="literal">factors</span>. But both <span class="literal">i</span> and <span class="literal">int(num / i)</span> are equal to <span class="literal">3</span>, so <span class="literal">3</span> would be appended to the list twice. To prevent duplicate numbers, we can pass the list to <span class="literal">set()</span>, which returns a list as a set data type. The <em class="calibre7">set</em> data type is similar to the list data type except a set value can only contain unique values.</p>
<p class="indent">You can pass any list value to the <span class="literal">set()</span> function to get a set value that doesn’t have any duplicate values in it. Conversely, if you pass a set value to <span class="literal">list()</span>, it would return a list value version of the set. To see examples of this, enter the following into the interactive shell:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">set([1, 2, 3, 3, 4])</span><br class="calibre9" />set([1, 2, 3, 4])<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam = list(set([2, 2, 2, 'cats', 2, 2]))</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />[2, 'cats']</p>
<p class="indent">Any repeated list values are removed when a list is converted to a set. Even when a set converted from a list is reconverted to a list, it will still not have any repeated values.</p>
<h4 class="h2" id="calibre_link-753"><strong class="calibre3"><em class="calibre12">Removing Duplicate Factors and Sorting the List</em></strong></h4>
<p class="noindent">Line 74 passes the list value in <span class="literal">factors</span> to <span class="literal">set()</span> to remove any duplicate factors:</p>
<p class="programs1">&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return list(set(factors)) # Remove duplicate factors.</p>
<p class="indent">The function <span class="literal">getItemAtIndexOne()</span> on line 77 is almost identical to <span class="literal">getItemAtIndexZero</span><span class="literal">()</span> in the <em class="calibre7">freqAnalysis.py</em> program you wrote in <a href="#calibre_link-42" class="calibre8">Chapter 19</a> (see “<a href="#calibre_link-46" class="calibre8">Getting the First Member of a Tuple</a>” on <a href="#calibre_link-46" class="calibre8">page 268</a>):</p>
<p class="programs1">&nbsp;77. def getItemAtIndexOne(x):<br class="calibre9" />&nbsp;78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return x[1]</p>
<p class="indent">This function will be passed to <span class="literal">sort()</span> later in the program to sort based on the item at index <span class="literal">1</span> of the items being sorted.</p>
<h4 class="h2" id="calibre_link-754"><strong class="calibre3"><em class="calibre12">Finding the Most Common Factors</em></strong></h4>
<p class="noindent">To find the most common factors, which are the most likely key lengths, we need to write the <span class="literal">getMostCommonFactors()</span> function, which begins on line 81.</p>
<span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-979"></span>
<p class="programs1">&nbsp;81. def getMostCommonFactors(seqFactors):<br class="calibre9" />&nbsp;82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, get a count of how many times a factor occurs in seqFactors:<br class="calibre9" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts = {} # Key is a factor; value is how often it occurs.</p>
<p class="indent">The <span class="literal">seqFactors</span> parameter on line 81 takes a dictionary value created using the <span class="literal">kasiskiExamination()</span> function, which I’ll explain shortly. This dictionary has strings of sequences as its keys and a list of integer factors as the value of each key. (These are factors of the spacing integers that <span class="literal">findRepeatSequencesSpacings</span><span class="literal">()</span> returned previously.) For example, <span class="literal">seqFactors</span> could contain a dictionary value that looks something like this:</p>
<p class="programs1">{'VRA': [8, 2, 4, 2, 3, 4, 6, 8, 12, 16, 8, 2, 4], 'AZU': [2, 3, 4, 6, 8, 12,<br class="calibre9" />&nbsp;16, 24], 'YBN': [8, 2, 4]}</p>
<p class="indent">The <span class="literal">getMostCommonFactors()</span> function orders the most common factors in <span class="literal">seqFactors</span> from the most frequently occurring to the least occurring and returns them as a list of two-integer tuples. The first integer in the tuple is the factor, and the second integer is how many times it appeared in <span class="literal">seqFactors</span>.</p>
<p class="indent">For example, <span class="literal">getMostCommonFactors()</span> might return a list value, such as this:</p>
<p class="programs1">[(3, 556), (2, 541), (6, 529), (4, 331), (12, 325), (8, 171), (9, 156), (16,<br class="calibre9" />105), (5, 98), (11, 86), (10, 84), (15, 84), (7, 83), (14, 68), (13, 52)]</p>
<p class="indent">This list shows that in the <span class="literal">seqFactors</span> dictionary that was passed to <span class="literal">getMostCommonFactors</span><span class="literal">()</span>, the factor 3 occurred 556 times, the factor 2 occurred 541 times, the factor 6 occurred 529 times, and so on. Note that 3 appears first in the list because it’s the most frequent factor; 13 is the least frequent factor and therefore is last in the list.</p>
<p class="indent">For the first step of <span class="literal">getMostCommonFactors()</span>, we’ll set up the <span class="literal">factorCounts</span> dictionary on line 83, which we’ll use to store the counts of each factor. The key of <span class="literal">factorCounts</span> will be the factor, and the values associated with the keys will be the counts of those factors.</p>
<p class="indent">Next, the <span class="literal">for</span> loop on line 88 loops over every sequence in <span class="literal">seqFactors</span>, storing it in a variable named <span class="literal">seq</span> on each iteration. The list of factors in <span class="literal">seqFactors</span> for <span class="literal">seq</span> is stored in a variable named <span class="literal">factorList</span> on line 89:</p>
<p class="programs1">&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seq in seqFactors:<br class="calibre9" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorList = seqFactors[seq]<br class="calibre9" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for factor in factorList:<br class="calibre9" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if factor not in factorCounts:<br class="calibre9" />&nbsp;92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts[factor] = 0<br class="calibre9" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorCounts[factor] += 1</p>
<p class="indent">The factors in this list are looped over with a <span class="literal">for</span> loop on line 90. If a factor doesn’t exist as a key in <span class="literal">factorCounts</span>, it’s added on line 92 with a value of <span class="literal">0</span>. Line 93 increments <span class="literal">factorCounts[factor]</span>, which is the factor’s value in <span class="literal">factorCounts</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-980"></span>For the second step of <span class="literal">getMostCommonFactors()</span>, we need to sort the values in the <span class="literal">factorCounts</span> dictionary by their count. But because dictionary values aren’t ordered, we must first convert the dictionary to a list of two-integer tuples. (We did something similar in <a href="#calibre_link-42" class="calibre8">Chapter 19</a> in the <span class="literal">getFrequencyOrder()</span> function in the <em class="calibre7">freqAnalaysis.py</em> module.) We store this list value in a variable named <span class="literal">factorsByCount</span>, which starts as an empty list on line 97:</p>
<p class="programs1">&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount = []<br class="calibre9" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for factor in factorCounts:<br class="calibre9" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Exclude factors larger than MAX_KEY_LENGTH:<br class="calibre9" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if factor &lt;= MAX_KEY_LENGTH:<br class="calibre9" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# factorsByCount is a list of tuples: (factor, factorCount).<br class="calibre9" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# factorsByCount has a value like [(3, 497), (2, 487), ...].<br class="calibre9" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount.append( (factor, factorCounts[factor]) )</p>
<p class="indent">Then the <span class="literal">for</span> loop on line 98 goes through each of the factors in <span class="literal">factorCounts</span> and appends this <span class="literal">(factor, factorCounts[factor])</span> tuple to the <span class="literal">factorsByCount</span> list only if the factor is less than or equal to <span class="literal">MAX_KEY_LENGTH</span>.</p>
<p class="indent">After the <span class="literal">for</span> loop finishes adding all the tuples to <span class="literal">factorsByCount</span>, line 106 sorts the <span class="literal">factorsByCount</span> as the final step of the <span class="literal">getMostCommonFactors()</span> function.</p>
<p class="programs1">106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount.sort(key=getItemAtIndexOne, reverse=True)<br class="calibre9" />107.<br class="calibre9" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return factorsByCount</p>
<p class="indent">Because the <span class="literal">getItemAtIndexOne</span> function is passed for the <span class="literal">key</span> keyword argument and <span class="literal">True</span> is passed for the <span class="literal">reverse</span> keyword argument, the list is sorted by the factor counts in descending order. Line 108 returns the sorted list in <span class="literal">factorsByCount</span>, which should indicate which factors appear most frequently and therefore are most likely to be the Vigenère key lengths.</p>
<h3 class="h1" id="calibre_link-755"><strong class="calibre3">Finding the Most Likely Key Lengths</strong></h3>
<p class="noindent">Before we can figure out what the possible subkeys are for a ciphertext, we need to know how many subkeys there are. That is, we need to know the length of the key. The <span class="literal">kasiskiExamination()</span> function on line 111 returns a list of the most likely key lengths for the given <span class="literal">ciphertext</span> argument.</p>
<p class="programs1">111. def kasiskiExamination(ciphertext):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeatedSeqSpacings = findRepeatSequencesSpacings(ciphertext)</p>
<p class="indent">The key lengths are integers in a list; the first integer in the list is the most likely key length, the second integer the second most likely, and so on.</p>
<p class="indent">The first step in finding the key length is to find the spacings between repeated sequences in the ciphertext. This is returned from the function <span class="literal">findRepeatSequencesSpacings()</span> as a dictionary with the sequence strings as <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-131"></span>its keys and a list with the spacings as integers as its values. The function <span class="literal">findRepeatSequencesSpacings</span><span class="literal">()</span> was described previously in “<a href="#calibre_link-47" class="calibre8">Finding Repeated Sequences</a>” on <a href="#calibre_link-47" class="calibre8">page 294</a>.</p>
<p class="indent">Before continuing with the next lines of code, you’ll need to learn about the <span class="literal">extend()</span> list method.</p>
<h4 class="h2" id="calibre_link-756"><strong class="calibre3"><em class="calibre12">The extend() List Method</em></strong></h4>
<p class="noindent">When you need to add multiple values to the end of a list, there is an easier way than calling <span class="literal">append()</span> inside a loop. The <span class="literal">extend()</span> list method can add values to the end of a list, similar to the <span class="literal">append()</span> list method. When passed a list, the <span class="literal">append()</span> method adds the entire list as one item to the end of another list, like this:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = ['cat', 'dog', 'mouse']</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs = [1, 2, 3]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.append(eggs)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['cat', 'dog', 'mouse', [1, 2, 3]]</p>
<p class="indent">In contrast, the <span class="literal">extend()</span> method adds each item in the list argument to the end of a list. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">spam = ['cat', 'dog', 'mouse']</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">eggs = [1, 2, 3]</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam.extend(eggs)</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre9" />['cat', 'dog', 'mouse', 1, 2, 3]</p>
<p class="indent">As you can see, all the values in <span class="literal">eggs</span> (<span class="literal">1</span>, <span class="literal">2</span>, and <span class="literal">3</span>) are appended to <span class="literal">spam</span> as discrete items.</p>
<h4 class="h2" id="calibre_link-757"><strong class="calibre3"><em class="calibre12">Extending the repeatedSeqSpacings Dictionary</em></strong></h4>
<p class="noindent">Although <span class="literal">repeatedSeqSpacings</span> is a dictionary that maps sequence strings to lists of integer spacings, we actually need a dictionary that maps sequence strings to lists of factors of those integer spacings. (See “<a href="#calibre_link-48" class="calibre8">Getting Factors of Spacings</a>” on <a href="#calibre_link-48" class="calibre8">page 283</a> for the reason why.) Lines 118 to 122 do this:</p>
<p class="programs1">118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors = {}<br class="calibre9" />119.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for seq in repeatedSeqSpacings:<br class="calibre9" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors[seq] = []<br class="calibre9" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for spacing in repeatedSeqSpacings[seq]:<br class="calibre9" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seqFactors[seq].extend(getUsefulFactors(spacing))</p>
<p class="indent">Line 118 starts with an empty dictionary in <span class="literal">seqFactors</span>. The <span class="literal">for</span> loop on line 119 iterates over every key, which is a sequence string, in the dictionary <span class="literal">repeatedSeqSpacings</span>. For each key, line 120 sets a blank list to be the value in <span class="literal">seqFactors</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-981"></span>The <span class="literal">for</span> loop on line 121 iterates over all the spacings integers by passing each to a <span class="literal">getUsefulFactors()</span> call. Each of the items in the list returned from <span class="literal">getUsefulFactors()</span> is added to <span class="literal">seqFactors[seq]</span> using the <span class="literal">extend()</span> method. When all the <span class="literal">for</span> loops are finished, <span class="literal">seqFactors</span> should be a dictionary that maps sequence strings to lists of factors of integer spacings. This allows us to have the factors of the spacings, not just the spacings.</p>
<p class="indent">Line 125 passes the <span class="literal">seqFactors</span> dictionary to the <span class="literal">getMostCommonFactors()</span> function and returns a list of two-integer tuples whose first integer represents the factor and whose second integer shows how often that factor appears in <span class="literal">seqFactors</span>. Then the tuple gets stored in <span class="literal">factorsByCount</span>.</p>
<p class="programs1">125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factorsByCount = getMostCommonFactors(seqFactors)</p>
<p class="indent">But we want the <span class="literal">kasiskiExamination()</span> function to return a list of integer factors, not a list of tuples with factors and the count of how often they appeared. Because these factors are stored as the first item of the two-integer tuples list in <span class="literal">factorsByCount</span>, we need to pull these factors from the tuples and put them in a separate list.</p>
<h4 class="h2" id="calibre_link-758"><strong class="calibre3"><em class="calibre12">Getting the Factors from factorsByCount</em></strong></h4>
<p class="noindent">Lines 130 to 134 store the separate list of factors in <span class="literal">allLikelyKeyLengths</span>.</p>
<p class="programs1">130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths = []<br class="calibre9" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for twoIntTuple in factorsByCount:<br class="calibre9" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths.append(twoIntTuple[0])<br class="calibre9" />133.<br class="calibre9" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return allLikelyKeyLengths</p>
<p class="indent">The <span class="literal">for</span> loop on line 131 iterates over each of the tuples in <span class="literal">factorsByCount</span> and appends the tuple’s index <span class="literal">0</span> item to the end of <span class="literal">allLikelyKeyLengths</span>. After this <span class="literal">for</span> loop completes, the <span class="literal">allLikelyKeyLengths</span> variable should contain all the integer factors in <span class="literal">factorsByCount</span>, which gets returned as a list from <span class="literal">kasiskiExamination()</span>.</p>
<p class="indent">Although we now have the ability to find the likely key lengths the message was encrypted with, we need to be able to separate letters from the message that were encrypted with the same subkey. Recall that encrypting <span class="literal">'THEDOGANDTHECAT'</span> with the key <span class="literal">'XYZ'</span> ends up using the <span class="literal">'X'</span> from the key to encrypt the message letters at index <span class="literal">0</span>, <span class="literal">3</span>, <span class="literal">6</span>, <span class="literal">9</span>, and <span class="literal">12</span>. Because these letters from the original English message are encrypted with the same subkey (<span class="literal">'X'</span>), the decrypted text should have a letter frequency count similar to English. We can use this information to figure out the subkey.</p>
<h3 class="h1" id="calibre_link-759"><strong class="calibre3">Getting Letters Encrypted with the Same Subkey</strong></h3>
<p class="noindent">To pull out the letters from a ciphertext that were encrypted with the same subkey, we need to write a function that can create a string using the 1st, 2nd, or <em class="calibre7">n</em>th letters of a message. After the function has the starting index, <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-982"></span>the key length, and the message passed to it, the first step is to remove the non-letter characters from <span class="literal">message</span> using a regular expression object and its <span class="literal">sub()</span> method on line 145.</p>
<div class="note">
<p class="notet"><strong class="calibre3"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre7">Regular expressions are discussed in “<a href="#calibre_link-49" class="calibre8">Finding Characters with Regular Expressions</a>” on <a href="#calibre_link-49" class="calibre8">page 230</a>.</em></p>
</div>
<p class="indent">This letters-only string is then stored as the new value in <span class="literal">message</span>:</p>
<p class="programs1">137. def getNthSubkeysLetters(nth, keyLength, message):<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message = NONLETTERS_PATTERN.sub('', message.upper())</p>
<p class="indent">Next, we build a string by appending the letter strings to a list and then use <span class="literal">join()</span> to merge the list into a single string:</p>
<p class="programs1">147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = nth - 1<br class="calibre9" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters = []<br class="calibre9" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while i &lt; len(message):<br class="calibre9" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letters.append(message[i])<br class="calibre9" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i += keyLength<br class="calibre9" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ''.join(letters)</p>
<p class="indent">The <span class="literal">i</span> variable points to the index of the letter in <span class="literal">message</span> that you want to append to the string-building list, which is stored in a variable named <span class="literal">letters</span>. The <span class="literal">i</span> variable starts with the value <span class="literal">nth - 1</span> on line 147, and the <span class="literal">letters</span> variable starts with a blank list on line 148.</p>
<p class="indent">The <span class="literal">while</span> loop on line 149 continues to run as long as <span class="literal">i</span> is less than the length of <span class="literal">message</span>. On each iteration, the letter at <span class="literal">message[i]</span> is appended to the list in <span class="literal">letters</span>. Then <span class="literal">i</span> is updated to point to the next letter in the subkey by adding <span class="literal">keyLength</span> to <span class="literal">i</span> on line 151.</p>
<p class="indent">After this loop finishes, line 152 joins the single-letter string values in the <span class="literal">letters</span> list into a one string, and this string is returned from <span class="literal">getNthSubkeysLetters()</span>.</p>
<p class="indent">Now that we can pull out letters that were encrypted with the same subkey, we can use <span class="literal">getNthSubkeysLetters()</span> to try decrypting with some potential key lengths.</p>
<h3 class="h1" id="calibre_link-760"><strong class="calibre3">Attempting Decryption with a Likely Key Length</strong></h3>
<p class="noindent">Recall that the <span class="literal">kasiskiExamination()</span> function isn’t guaranteed to return the actual length of the Vigenère key but rather a list of several possible lengths sorted in order of most likely to least likely key length. If the code has determined the wrong key length, it will try again using a different key length. The <span class="literal">attemptHackWithKeyLength()</span> function does this when passed the ciphertext and the determined key length. If successful, this function returns a string of the hacked message. If the hacking fails, the function returns <span class="literal">None</span>.</p>
<p class="indent">The hacking code works only on uppercase letters, but we want to return any decrypted string with its original casing, so we need to preserve <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-983"></span>the original string. To do this, we store the uppercase form of the <span class="literal">ciphertext</span> string in a separate variable named <span class="literal">ciphertextUp</span> on line 157.</p>
<p class="programs1">155. def attemptHackWithKeyLength(ciphertext, mostLikelyKeyLength):<br class="calibre9" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Determine the most likely letters for each letter in the key:<br class="calibre9" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp = ciphertext.upper()</p>
<p class="indent">If we assume the value in the <span class="literal">mostLikelyKeyLength</span> is the correct key length, the hacking algorithm calls <span class="literal">getNthSubkeysLetters()</span> for each subkey and then brute-forces through the 26 possible letters to find the one that produces decrypted text whose letter frequency most closely matches the letter frequency of English for that subkey.</p>
<p class="indent">First, an empty list is stored in <span class="literal">allFreqScores</span> on line 160, which will store the frequency match scores returned by <span class="literal">freqAnalysis.englishFreqMatchScore()</span>:</p>
<p class="programs1">160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFreqScores = []<br class="calibre9" />161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for nth in range(1, mostLikelyKeyLength + 1):<br class="calibre9" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nthLetters = getNthSubkeysLetters(nth, mostLikelyKeyLength,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp)</p>
<p class="indent">The <span class="literal">for</span> loop on line 161 sets the <span class="literal">nth</span> variable to each integer from <span class="literal">1</span> to the <span class="literal">mostLikelyKeyLength</span> value. Recall that when <span class="literal">range()</span> is passed two arguments, the range goes up to, but not including, the second argument. The <span class="literal">+ 1</span> is put into the code so the integer value in <span class="literal">mostLikelyKeyLength</span> is included in the range object returned.</p>
<p class="indent">The letters of the <em class="calibre7">n</em>th subkey are returned from <span class="literal">getNthSubkeysLetters()</span> on line 162.</p>
<p class="indent">Next, we need to decrypt the letters of the <em class="calibre7">n</em>th subkey with all 26 possible subkeys to see which ones produce English-like letter frequencies. A list of English frequency match scores is stored in a list in a variable named <span class="literal">freqScores</span>. This variable starts as an empty list on line 168 and then the <span class="literal">for</span> loop on line 169 loops through each of the 26 uppercase letters from the <span class="literal">LETTERS</span> string:</p>
<p class="programs1">168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores = []<br class="calibre9" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for possibleKey in LETTERS:<br class="calibre9" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = vigenereCipher.decryptMessage(possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nthLetters)</p>
<p class="indent">The <span class="literal">possibleKey</span> value decrypts the ciphertext by calling <span class="literal">vigenereCipher.decryptMessage()</span> on line 170. The subkey in <span class="literal">possibleKey</span> is only one letter, but the string in <span class="literal">nthLetters</span> is made up of only the letters from <span class="literal">message</span> that would have been encrypted with that subkey if the code has determined the key length correctly.</p>
<p class="indent">The decrypted text is then passed to <span class="literal">freqAnalysis.englishFreqMatchScore()</span> to see how closely the frequency of the letters in <span class="literal">decryptedText</span> matches the letter frequency of regular English. As you learned in <a href="#calibre_link-42" class="calibre8">Chapter 19</a>, the return value is an integer between <span class="literal">0</span> and <span class="literal">12</span>: recall that a higher number means a closer match.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-984"></span>Line 171 puts this frequency match score and the key used to decrypt into a tuple and stores it in the <span class="literal">keyAndFreqMatchTuple</span> variable. This tuple is appended to the end of <span class="literal">freqScores</span> on line 172:</p>
<p class="programs1">171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyAndFreqMatchTuple = (possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqAnalysis.englishFreqMatchScore(decryptedText))<br class="calibre9" />172.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores.append(keyAndFreqMatchTuple)</p>
<p class="indent">After the <span class="literal">for</span> loop on line 169 completes, the <span class="literal">freqScores</span> list should contain 26 key-and-frequency-match-score tuples: one tuple for each of the 26 subkeys. We need to sort this list so the tuples with the largest English frequency match scores come first. This means that we want to sort the tuples in <span class="literal">freqScores</span> by the value at index <span class="literal">1</span> and in reverse (descending) order.</p>
<p class="indent">We call the <span class="literal">sort()</span> method on the <span class="literal">freqScores</span> list, passing the function value <span class="literal">getItemAtIndexOne</span> for the <span class="literal">key</span> keyword argument. Note that we’re <em class="calibre7">not</em> calling the function, as you can tell from the lack of parentheses. The value <span class="literal">True</span> is passed for the <span class="literal">reverse</span> keyword argument to sort in descending order.</p>
<p class="programs1">174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;freqScores.sort(key=getItemAtIndexOne, reverse=True)</p>
<p class="indent">Initially, the <span class="literal">NUM_MOST_FREQ_LETTERS</span> constant was set to the integer value <span class="literal">4</span> on line 9. After sorting the tuples in <span class="literal">freqScores</span> in reverse order, line 176 appends a list containing only the first three tuples, or the tuples with the three highest English frequency match scores, to <span class="literal">allFreqScores</span>. As a result, <span class="literal">allFreqScores[0]</span> contains the frequency scores for the first subkey, <span class="literal">allFreqScores[1]</span> contains the frequency scores for the second subkey, and so on.</p>
<p class="programs1">176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allFreqScores.append(freqScores[:NUM_MOST_FREQ_LETTERS])</p>
<p class="indent">After the <span class="literal">for</span> loop on line 161 completes, <span class="literal">allFreqScores</span> should contain a number of list values equal to the integer value in <span class="literal">mostLikelyKeyLength</span>. For example, if <span class="literal">mostLikelyKeyLength</span> was <span class="literal">3</span>, <span class="literal">allFreqScores</span> would be a list of three lists. The first list value holds the tuples for the top three highest matching subkeys for the first subkey of the full Vigenère key. The second list value holds the tuples for the top three highest matching subkeys for the second subkey of the full Vigenère key, and so on.</p>
<p class="indent">Originally, if we wanted to brute-force through the full Vigenère key, the number of possible keys would be 26 raised to the power of key length. For example, if the key was ROSEBUD with a length of 7, there would be 26<sup class="calibre21">7</sup>, or 8,031,810,176, possible keys.</p>
<p class="indent">But checking the English frequency matching helped determine the four most likely letters for each subkey. Continuing with the ROSEBUD example, this means that we only need to check 4<sup class="calibre21">7</sup>, or 16,384, possible keys, which is a huge improvement over 8 billion possible keys!</p>
<h4 class="h2" id="calibre_link-761"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-126" class="calibre1"></span><strong class="calibre3"><em class="calibre12">The end Keyword Argument for print()</em></strong></h4>
<p class="noindent">Next, we want to print output to the user. To do this, we use <span class="literal">print()</span> but pass an argument to an optional parameter we haven’t used before. Whenever the <span class="literal">print()</span> function is called, it prints to the screen the string passed to it along with a newline character. To print something else at the end of the string instead of a newline character, we can specify the string for the <span class="literal">print()</span> function’s <span class="literal">end</span> keyword argument. Enter the following into the interactive shell to see how to use the <span class="literal">print()</span> function’s <span class="literal">end</span> keyword argument:</p>
<p class="programs1">&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">def printStuff():</span><br class="calibre9" /><span class="ent">➊</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Hello', end='\n')</span><br class="calibre9" /><span class="ent">➋</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Howdy', end='')</span><br class="calibre9" /><span class="ent">➌</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Greetings', end='XYZ')</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="codestrong">print('Goodbye')</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">printStuff()</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;Hello<br class="calibre9" />&nbsp;&nbsp;&nbsp;HowdyGreetingsXYZGoodbye</p>
<p class="indent">Passing <span class="literal">end='\n'</span> prints the string normally <span class="ent">➊</span>. However, passing <span class="literal">end=''</span> <span class="ent">➋</span> or <span class="literal">end='XYZ'</span> <span class="ent">➌</span> replaces the usual newline character, so subsequent <span class="literal">print()</span> calls are not displayed on a new line.</p>
<h4 class="h2" id="calibre_link-762"><strong class="calibre3"><em class="calibre12">Running the Program in Silent Mode or Printing Information to the User</em></strong></h4>
<p class="noindent">At this point, we want to know which letters are the top three candidates for each subkey. If the <span class="literal">SILENT_MODE</span> constant was set to <span class="literal">False</span> earlier in the program, the code on lines 178 to 184 would print the values in <span class="literal">allFreqScores</span> to the screen:</p>
<p class="programs1">178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />179.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(allFreqScores)):<br class="calibre9" />180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Use i + 1 so the first letter is not called the "0th" letter:<br class="calibre9" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible letters for letter %s of the key: ' % (i + 1),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end='')<br class="calibre9" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for freqScore in allFreqScores[i]:<br class="calibre9" />183.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('%s ' % freqScore[0], end='')<br class="calibre9" />184.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print() # Print a newline.</p>
<p class="indent">If <span class="literal">SILENT_MODE</span> were set to <span class="literal">True</span>, the code in the <span class="literal">if</span> statement’s block would be skipped.</p>
<p class="indent">We’ve now reduced the number of subkeys to a small enough number that we can brute-force all of them. Next, you’ll learn how to use the <span class="literal">itertools</span><span class="literal">.product()</span> function to generate every possible combination of subkeys to brute-force.</p>
<h4 class="h2" id="calibre_link-763"><strong class="calibre3"><em class="calibre12">Finding Possible Combinations of Subkeys</em></strong></h4>
<p class="noindent">Now that we have possible subkeys, we need to put them together to find the whole key. The problem is that, even though we’ve found letters for each <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-128"></span>subkey, the most likely letter might not actually be the right letter. Instead, the second most likely or third most likely letter might be the right subkey letter. This means we can’t just combine the most likely letters for each subkey into one key: we need to try different combinations of likely letters to find the right key.</p>
<p class="indent">The <em class="calibre7">vigenereHacker.py</em> program uses the <span class="literal">itertools.product()</span> function to test every possible combination of subkeys.</p>
<h5 class="h3"><strong class="calibre3">The itertools.product() Function</strong></h5>
<p class="noindent">The <span class="literal">itertools.product()</span> function produces every possible combination of items in a list or list-like value, such as a string or tuple. Such a combination of items is called a <em class="calibre7">Cartesian product</em>, which is where the function gets its name. The function returns an itertools product object value, which can also be converted to a list by passing it to <span class="literal">list()</span>. Enter the following into the interactive shell to see an example:</p>
<p class="programs1">&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">import itertools</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">itertools.product('ABC', repeat=4)</span><br class="calibre9" /><span class="ent">➊</span> &lt;itertools.product object at 0x02C40170&gt;<br class="calibre9" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">list(itertools.product('ABC', repeat=4))</span><br class="calibre9" />&nbsp;&nbsp;&nbsp;[('A', 'A', 'A', 'A'), ('A', 'A', 'A', 'B'), ('A', 'A', 'A', 'C'), ('A', 'A',<br class="calibre9" />&nbsp;&nbsp;&nbsp;'B', 'A'), ('A', 'A', 'B', 'B'), ('A', 'A', 'B', 'C'), ('A', 'A', 'C', 'A'),<br class="calibre9" />&nbsp;&nbsp;&nbsp;('A', 'A', 'C', 'B'), ('A', 'A', 'C', 'C'), ('A', 'B', 'A', 'A'), ('A', 'B',<br class="calibre9" />&nbsp;&nbsp;&nbsp;'A', 'B'), ('A', 'B', 'A', 'C'), ('A', 'B', 'B', 'A'), ('A', 'B', 'B', 'B'),<br class="calibre9" />&nbsp;&nbsp;&nbsp;--<span class="codeitalic">snip</span>--<br class="calibre9" />&nbsp;&nbsp;&nbsp;('C', 'B', 'C', 'B'), ('C', 'B', 'C', 'C'), ('C', 'C', 'A', 'A'), ('C', 'C',<br class="calibre9" />&nbsp;&nbsp;&nbsp;'A', 'B'), ('C', 'C', 'A', 'C'), ('C', 'C', 'B', 'A'), ('C', 'C', 'B', 'B'),<br class="calibre9" />&nbsp;&nbsp;&nbsp;('C', 'C', 'B', 'C'), ('C', 'C', 'C', 'A'), ('C', 'C', 'C', 'B'), ('C', 'C',<br class="calibre9" />&nbsp;&nbsp;&nbsp;'C', 'C')]</p>
<p class="indent">Passing <span class="literal">'ABC'</span> and the integer <span class="literal">4</span> for the <span class="literal">repeat</span> keyword argument to <span class="literal">itertools</span><span class="literal">.product()</span> returns an itertools product object <span class="ent">➊</span> that, when converted to a list, has tuples of four values with every possible combination of <span class="literal">'A'</span>, <span class="literal">'B'</span>, and <span class="literal">'C'</span>. This results in a list that has a total of 3<sup class="calibre21">4</sup>, or 81, tuples.</p>
<p class="indent">You can also pass list values to <span class="literal">itertools.product()</span> and some values similar to lists, such as range objects returned from <span class="literal">range()</span>. Enter the following into the interactive shell to see what happens when lists and objects like lists are passed to this function:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">import itertools</span><br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">list(itertools.product(range(8), repeat=5))</span><br class="calibre9" />[(0, 0, 0, 0, 0), (0, 0, 0, 0, 1), (0, 0, 0, 0, 2), (0, 0, 0, 0, 3), (0, 0, 0,<br class="calibre9" />0, 4), (0, 0, 0, 0, 5), (0, 0, 0, 0, 6), (0, 0, 0, 0, 7), (0, 0, 0, 1, 0), (0,<br class="calibre9" />0, 0, 1, 1), (0, 0, 0, 1, 2), (0, 0, 0, 1, 3), (0, 0, 0, 1, 4),<br class="calibre9" />--<span class="codeitalic">snip</span>--<br class="calibre9" />(7, 7, 7, 6, 6), (7, 7, 7, 6, 7), (7, 7, 7, 7, 0), (7, 7, 7, 7, 1), (7, 7, 7,<br class="calibre9" />7, 2), (7, 7, 7, 7, 3), (7, 7, 7, 7, 4), (7, 7, 7, 7, 5), (7, 7, 7, 7, 6), (7,<br class="calibre9" />7, 7, 7, 7)]</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-261"></span>When the range object returned from <span class="literal">range(8)</span> is passed to <span class="literal">itertools.product()</span>, along with <span class="literal">5</span> for the <span class="literal">repeat</span> keyword argument, it generates a list that has tuples of five values, integers ranging from <span class="literal">0</span> to <span class="literal">7</span>.</p>
<p class="indent">We can’t just pass <span class="literal">itertools.product()</span> a list of the potential subkey letters, because the function creates combinations of the same values and each of the subkeys will probably have different potential letters. Instead, because our subkeys are stored in tuples in <span class="literal">allFreqScores</span>, we’ll access those letters by index values, which will range from 0 to the number of letters we want to try minus 1. We know that the number of letters in each tuple is equal to <span class="literal">NUM_MOST_FREQ_LETTERS</span> because we only stored that number of potential letters in each tuple earlier on line 176. So the range of indexes we’ll need to access is from <span class="literal">0</span> to <span class="literal">NUM_MOST_FREQ_LETTERS</span>, which is what we’ll pass to <span class="literal">itertools</span><span class="literal">.product()</span>. We’ll also pass <span class="literal">itertools.product()</span> a likely key length as a second argument, creating tuples as long as the potential key length.</p>
<p class="indent">For example, if we wanted to try only the first three most likely letters of each subkey (which is determined by <span class="literal">NUM_MOST_FREQ_LETTERS</span>) for a key that’s likely five letters long, the first value <span class="literal">itertools.product()</span> would produce would be <span class="literal">(0, 0, 0, 0, 0)</span>. The next value would be <span class="literal">(0, 0, 0, 0, 1)</span>, then <span class="literal">(0, 0, 0, 0, 2)</span>, and values would be generated until reaching <span class="literal">(2, 2, 2, 2, 2)</span>. Each integer in the five-value tuples represents an index to <span class="literal">allFreqScores</span>.</p>
<h5 class="h3"><strong class="calibre3">Accessing the Subkeys in allFreqScores</strong></h5>
<p class="noindent">The value in <span class="literal">allFreqScores</span> is a list that holds the most likely letters of each subkey along with their frequency match scores. To see how this list works, let’s create a hypothetical <span class="literal">allFreqScores</span> value in IDLE. For example, <span class="literal">allFreqScores</span> might look like this for a six-letter key where we found the four most likely letters for each subkey:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">allFreqScores = [[('A', 9), ('E', 5), ('O', 4), ('P', 4)], [('S', 10),</span><br class="calibre9" /><span class="codestrong">('D', 4), ('G', 4), ('H', 4)], [('I', 11), ('V', 4), ('X', 4), ('B', 3)],</span><br class="calibre9" /><span class="codestrong">[('M', 10), ('Z', 5), ('Q', 4), ('A', 3)], [('O', 11), ('B', 4), ('Z', 4),</span><br class="calibre9" /><span class="codestrong">('A', 3)], [('V', 10), ('I', 5), ('K', 5), ('Z', 4)]]</span></p>
<p class="indent">This may look complex, but we can drill down to specific values of the lists and tuples with indexing. When <span class="literal">allFreqScores</span> is accessed at an index, it evaluates to a list of tuples of possible letters for a single subkey and their frequency match scores. For example, <span class="literal">allFreqScores[0]</span> has a list of tuples for the first subkey along with the frequency match scores of each potential subkey, <span class="literal">allFreqScores[1]</span> has a list of tuples for the second subkey and frequency match scores, and so on:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">allFreqScores[0]</span><br class="calibre9" />[('A', 9), ('E', 5), ('O', 4), ('P', 4)]<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">allFreqScores[1]</span><br class="calibre9" />[('S', 10), ('D', 4), ('G', 4), ('H', 4)]</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-985"></span>You can also access each tuple of the possible letters for each subkey by adding an additional index reference. For example, we would get a tuple of the most likely letter to be the second subkey and its frequency match score if we accessed <span class="literal">allFreqScores[1][0]</span>, the second most likely letter from <span class="literal">allFreqScores</span><span class="literal">[1][1]</span>, and so on:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">allFreqScores[1][0]</span><br class="calibre9" />('S', 10)<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">allFreqScores[1][1]</span><br class="calibre9" />('D', 4)</p>
<p class="indent">Because these values are tuples, we would need to access the first value in the tuple to get just the possible letter without its frequency match score value. Each letter is stored in the first index of the tuples, so we would use <span class="literal">allFreqScores[1][0][0]</span> to access the most likely letter of the first subkey, <span class="literal">allFreqScores</span><span class="literal">[1][1][0]</span> to access the most likely letter of the second subkey, and so on:</p>
<p class="programs1">&gt;&gt;&gt; <span class="codestrong">allFreqScores[1][0][0]</span><br class="calibre9" />'S'<br class="calibre9" />&gt;&gt;&gt; <span class="codestrong">allFreqScores[1][1][0]</span><br class="calibre9" />'D'</p>
<p class="indent">Once you’re able to access potential subkeys in <span class="literal">allFreqScores</span>, you need to combine them to find potential keys.</p>
<h5 class="h3"><strong class="calibre3">Creating Subkey Combinations with itertools.product()</strong></h5>
<p class="noindent">The tuples produced by <span class="literal">itertools.product()</span> each represent one key where the position in the tuple corresponds to the first index we access in <span class="literal">allFreqScores</span>, and the integers in the tuple represent the second index we access in <span class="literal">allFreqScores</span>.</p>
<p class="indent">Because we set the <span class="literal">NUM_MOST_FREQ_LETTERS</span> constant to <span class="literal">4</span> earlier, <span class="literal">itertools.product(range(NUM_MOST_FREQ_LETTERS), repeat=mostLikelyKeyLength)</span> on line 188 causes the <span class="literal">for</span> loop to have a tuple of integers (from <span class="literal">0</span> to <span class="literal">3</span>) representing the four most likely letters for each subkey for the <span class="literal">indexes</span> variable:</p>
<p class="programs1">188.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for indexes in itertools.product(range(NUM_MOST_FREQ_LETTERS),<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat=mostLikelyKeyLength):<br class="calibre9" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a possible key from the letters in allFreqScores:<br class="calibre9" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleKey = ''<br class="calibre9" />191.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(mostLikelyKeyLength):<br class="calibre9" />192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleKey += allFreqScores[i][indexes[i]][0]</p>
<p class="indent">We construct full Vigenère keys using <span class="literal">indexes</span>, which takes the value of one tuple created by <span class="literal">itertools.product()</span> on each iteration. The key starts as a blank string on line 190, and the <span class="literal">for</span> loop on line 191 iterates through the integers from <span class="literal">0</span> up to, but not including, <span class="literal">mostLikelyKeyLength</span> for each tuple to construct a key.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-986"></span>As the <span class="literal">i</span> variable changes for each iteration of the <span class="literal">for</span> loop, the value at <span class="literal">indexes[i]</span> is the index of the tuple we want to use in <span class="literal">allFreqScores[i]</span>. This is why <span class="literal">allFreqScores[i][indexes[i]]</span> evaluates to the correct tuple we want. When we have the correct tuple, we need to access index <span class="literal">0</span> in that tuple to get the subkey letter.</p>
<p class="indent">If <span class="literal">SILENT_MODE</span> is <span class="literal">False</span>, line 195 prints the key that was created by the <span class="literal">for</span> loop on line 191:</p>
<p class="programs1">194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting with key: %s' % (possibleKey))</p>
<p class="indent">Now that we have a complete Vigenère key, lines 197 to 208 decrypt the ciphertext and check whether the decrypted text is readable English. If it is, the program prints it to the screen for the user to confirm that it is indeed English to check for false positives.</p>
<h4 class="h2" id="calibre_link-764"><strong class="calibre3"><em class="calibre12">Printing the Decrypted Text with the Correct Casing</em></strong></h4>
<p class="noindent">Because <span class="literal">decryptedText</span> is in uppercase, lines 201 to 207 build a new string by appending an uppercase or lowercase form of the letters in <span class="literal">decryptedText</span> to the <span class="literal">origCase</span> list:</p>
<p class="programs1">197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = vigenereCipher.decryptMessage(possibleKey,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ciphertextUp)<br class="calibre9" />198.<br class="calibre9" />199.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if detectEnglish.isEnglish(decryptedText):<br class="calibre9" />200.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Set the hacked ciphertext to the original casing:<br class="calibre9" />201.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase = []<br class="calibre9" />202.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(len(ciphertext)):<br class="calibre9" />203.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ciphertext[i].isupper():<br class="calibre9" />204.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase.append(decryptedText[i].upper())<br class="calibre9" />205.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre9" />206.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;origCase.append(decryptedText[i].lower())<br class="calibre9" />207.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decryptedText = ''.join(origCase)</p>
<p class="indent">The <span class="literal">for</span> loop on line 202 goes through each of the indexes in the <span class="literal">ciphertext</span> string, which, unlike <span class="literal">ciphertextUp</span>, has the original casing of the <span class="literal">ciphertext</span>. If <span class="literal">ciphertext[i]</span> is uppercase, the uppercase form of <span class="literal">decryptedText[i]</span> is appended to <span class="literal">origCase</span>. Otherwise, the lowercase form of <span class="literal">decryptedText[i]</span> is appended. The list in <span class="literal">origCase</span> is then joined on line 207 to become the new value of <span class="literal">decryptedText</span>.</p>
<p class="indent">The next lines of code print the decryption output to the user to check whether the key has been found:</p>
<p class="programs1">210.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Possible encryption hack with key %s:' % (possibleKey))<br class="calibre9" />211.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(decryptedText[:200]) # Only show first 200 characters.<br class="calibre9" />212.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />213.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Enter D if done, anything else to continue hacking:')<br class="calibre9" />214.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response = input('&gt; ')<br class="calibre9" />215.<br class="calibre9" />216.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if response.strip().upper().startswith('D'):<br class="calibre9" />217.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return decryptedText</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-144"></span>The correctly cased decrypted text is printed to the screen for the user to confirm it is English. If the user enters <span class="literal">'D'</span>, the function returns the <span class="literal">decryptedText</span> string.</p>
<p class="indent">Otherwise, if none of the decryptions look like English, the hacking has failed and the <span class="literal">None</span> value is returned:</p>
<p class="programs1">220.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None</p>
<h3 class="h1" id="calibre_link-765"><strong class="calibre3">Returning the Hacked Message</strong></h3>
<p class="noindent">Finally, all of the functions we’ve defined will be used by the <span class="literal">hackVigenere</span><span class="literal">()</span> function, which accepts a ciphertext string as an argument and returns the hacked message (if hacking was successful) or <span class="literal">None</span> (if it wasn’t). It starts by getting the likely key lengths with <span class="literal">kasiskiExamination()</span>:</p>
<p class="programs1">223. def hackVigenere(ciphertext):<br class="calibre9" />224.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, we need to do Kasiski examination to figure out what the<br class="calibre9" />225.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# length of the ciphertext's encryption key is:<br class="calibre9" />226.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;allLikelyKeyLengths = kasiskiExamination(ciphertext)</p>
<p class="indent">The <span class="literal">hackVignere()</span> function’s output depends on whether the program is in <span class="literal">SILENT_MODE</span>:</p>
<p class="programs1">227.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />228.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLengthStr = ''<br class="calibre9" />229.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in allLikelyKeyLengths:<br class="calibre9" />230.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLengthStr += '%s ' % (keyLength)<br class="calibre9" />231.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Kasiski examination results say the most likely key lengths<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are: ' + keyLengthStr + '\n')</p>
<p class="indent">The likely key lengths are printed to the screen if <span class="literal">SILENT_MODE</span> is <span class="literal">False</span>.</p>
<p class="indent">Next, we need to find likely subkey letters for each key length. We’ll do that with another loop that attempts to hack the cipher with each key length we found.</p>
<h4 class="h2" id="calibre_link-766"><strong class="calibre3"><em class="calibre12">Breaking Out of the Loop When a Potential Key Is Found</em></strong></h4>
<p class="noindent">We want the code to continue looping and checking key lengths until it finds a potentially correct key length. When it finds a key length that seems correct, we’ll stop the loop with a <span class="literal">break</span> statement.</p>
<p class="indent">Similar to how the <span class="literal">continue</span> statement is used inside a loop to go back to the start of the loop, the <span class="literal">break</span> statement is used inside a loop to immediately exit the loop. When the program execution breaks out of a loop, it <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-145"></span>immediately moves to the first line of code after the loop ends. We’ll break out of the loop whenever the program finds a potentially correct key and needs to ask the user to confirm that the key is correct.</p>
<p class="programs1">232.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = None<br class="calibre9" />233.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in allLikelyKeyLengths:<br class="calibre9" />234.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />235.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting hack with key length %s (%s possible keys)...'<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% (keyLength, NUM_MOST_FREQ_LETTERS ** keyLength))<br class="calibre9" />236.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = attemptHackWithKeyLength(ciphertext, keyLength)<br class="calibre9" />237.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />238.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">For each possible key length, the code calls <span class="literal">attemptHackWithKeyLength()</span> on line 236. If <span class="literal">attemptHackWithKeyLength()</span> does not return <span class="literal">None</span>, the hack is successful, and the program execution should break out of the <span class="literal">for</span> loop on line 238.</p>
<h4 class="h2" id="calibre_link-767"><strong class="calibre3"><em class="calibre12">Brute-Forcing All Other Key Lengths</em></strong></h4>
<p class="noindent">If the hack fails all the possible key lengths that <span class="literal">kasiskiExamination()</span> returned, <span class="literal">hackedMessage</span> is set to <span class="literal">None</span> when the <span class="literal">if</span> statement on line 242 executes. In this case, all the <em class="calibre7">other</em> key lengths up to <span class="literal">MAX_KEY_LENGTH</span> are tried. If Kasiski examination fails to calculate the correct key length, we can just brute-force through the key lengths with the <span class="literal">for</span> loop on line 245:</p>
<p class="programs1">242.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage == None:<br class="calibre9" />243.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />244.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Unable to hack message with likely key length(s). Brute-<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forcing key length...')<br class="calibre9" />245.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for keyLength in range(1, MAX_KEY_LENGTH + 1):<br class="calibre9" />246.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Don't recheck key lengths already tried from Kasiski:<br class="calibre9" />247.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if keyLength not in allLikelyKeyLengths:<br class="calibre9" />248.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not SILENT_MODE:<br class="calibre9" />249.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Attempting hack with key length %s (%s possible<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys)...' % (keyLength, NUM_MOST_FREQ_LETTERS **<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLength))<br class="calibre9" />250.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hackedMessage = attemptHackWithKeyLength(ciphertext,<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keyLength)<br class="calibre9" />251.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if hackedMessage != None:<br class="calibre9" />252.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">Line 245 starts a <span class="literal">for</span> loop that calls <span class="literal">attemptHackWithKeyLength()</span> for each value of <span class="literal">keyLength</span> (which ranges from <span class="literal">1</span> to <span class="literal">MAX_KEY_LENGTH</span>) as long as it’s not in <span class="literal">allLikelyKeyLengths</span>. The reason is that the key lengths in <span class="literal">allLikelyKeyLengths</span> have already been tried in the code on lines 233 to 238.</p>
<p class="indent">Finally, the value in <span class="literal">hackedMessage</span> is returned on line 253:</p>
<p class="programs1">253.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return hackedMessage</p>
<h3 class="h1" id="calibre_link-768"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-177" class="calibre1"></span><strong class="calibre3">Calling the main() Function</strong></h3>
<p class="noindent">Lines 258 and 259 call the <span class="literal">main()</span> function if this program was run by itself rather than being imported by another program:</p>
<p class="programs1">256. # If vigenereHacker.py is run (instead of imported as a module), call<br class="calibre9" />257. # the main() function:<br class="calibre9" />258. if __name__ == '__main__':<br class="calibre9" />259.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">That’s the full Vigenère hacking program. Whether it’s successful depends on the characteristics of the ciphertext. The closer the original plaintext’s letter frequency is to regular English’s letter frequency and the longer the plaintext, the more likely the hacking program will work.</p>
<h3 class="h1" id="calibre_link-769"><strong class="calibre3">Modifying the Constants of the Hacking Program</strong></h3>
<p class="noindent">We can modify a few details if the hacking program doesn’t work. Three constants we set on lines 8 to 10 affect how the hacking program runs:</p>
<p class="programs1">&nbsp;&nbsp;8. MAX_KEY_LENGTH = 16 # Will not attempt keys longer than this.<br class="calibre9" />&nbsp;&nbsp;9. NUM_MOST_FREQ_LETTERS = 4 # Attempt this many letters per subkey.<br class="calibre9" />&nbsp;10. SILENT_MODE = False # If set to True, program doesn't print anything.</p>
<p class="indent">If the Vigenère key is longer than the integer in <span class="literal">MAX_KEY_LENGTH</span> on line 8, there is no way the hacking program will find the correct key. If the hacking program fails to hack the ciphertext, try increasing this value and running the program again.</p>
<p class="indent">Keep in mind that trying to hack an incorrect key length that is short takes a short amount of time. But if <span class="literal">MAX_KEY_LENGTH</span> is set very high and the <span class="literal">kasiskiExamination()</span> function mistakenly thinks that the key length could be an enormous integer, the program could spend hours, or even months, attempting to hack the ciphertext using the wrong key lengths.</p>
<p class="indent">To prevent this, <span class="literal">NUM_MOST_FREQ_LETTERS</span> on line 9 limits the number of possible letters tried for each subkey. By increasing this value, the hacking program tries many more keys, which you might need to do if the <span class="literal">freqAnalysis.englishFreqMatchScore()</span> was inaccurate for the original plaintext message, but this also causes the program to slow down. And setting <span class="literal">NUM_MOST_FREQ_LETTERS</span> to <span class="literal">26</span> would cause the program to skip narrowing down the number of possible letters for each subkey entirely!</p>
<p class="indent">For both <span class="literal">MAX_KEY_LENGTH</span> and <span class="literal">NUM_MOST_FREQ_LETTERS</span>, a smaller value is faster to execute but less likely to succeed in hacking the cipher, and a larger value is slower to execute but more likely to succeed.</p>
<p class="indent">Finally, to increase the speed of your program, you can set <span class="literal">SILENT_MODE</span> to <span class="literal">True</span> on line 10 so the program doesn’t waste time printing information to the screen. Although your computer can perform calculations quickly, displaying characters on the screen can be relatively slow. The downside of not printing information is that you won’t know how the program is doing until it has completely finished running.</p>
<h3 class="h1" id="calibre_link-770"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-987" class="calibre1"></span><strong class="calibre3">Summary</strong></h3>
<p class="noindent">Hacking the Vigenère cipher requires you to follow several detailed steps. Also, many parts of the hacking program could fail: for example, perhaps the Vigenère key used for encryption is longer than <span class="literal">MAX_KEY_LENGTH</span>, or perhaps the English frequency&ndash;matching function received inaccurate results because the plaintext doesn’t follow normal letter frequency, or maybe the plaintext has too many words that aren’t in the dictionary file and <span class="literal">isEnglish()</span> doesn’t recognize it as English.</p>
<p class="indent">As you identify different ways in which the hacking program could fail, you can change the code to handle such cases. But the hacking program in this book does a pretty good job of reducing billions or trillions of possible keys to mere thousands.</p>
<p class="indent">However, there is one trick that makes the Vigenère cipher mathematically impossible to break, no matter how powerful your computer or how clever your hacking program is. You’ll learn about this trick, which is called a one-time pad, in <a href="#calibre_link-50" class="calibre8">Chapter 21</a>.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-771"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What is a dictionary attack?</p>
</li>
<li value="2" class="calibre11"><p class="noindent">What does Kasiski examination of a ciphertext reveal?</p>
</li>
<li value="3" class="calibre11"><p class="noindent">What two changes happen when converting a list value to a set value with the <span class="literal">set()</span> function?</p>
</li>
<li value="4" class="calibre11"><p class="noindent">If the <span class="literal">spam</span> variable contains <span class="literal">['cat', 'dog', 'mouse', 'dog']</span>, this list has four items in it. How many items does the list returned from <span class="literal">list(set(spam))</span> have?</p>
</li>
<li value="5" class="calibre11"><p class="noindent">What does the following code print?</p>
<p class="programs1">print('Hello', end='')<br class="calibre9" />print('World')</p>
</li>
</ol>
</div>
</div>



<a href="chapter19.html">Prev: Chapter 19 - Frequency Analysis</a> | <a href="chapter21.html">Next: Chapter 21 - The One-Time Pad Cipher</a>
</body></html>