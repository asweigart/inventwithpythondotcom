<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style_cracking.css" rel="stylesheet" type="text/css" /><title>Chapter 23 - Generating Keys for the Public Key Cipher</title></head><body style="background-color: #fffeee;">

<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<div style="background-color: #eeeddd; float: right; height: 310px; font-family: sans-serif;" id="otherbooks">
  <a href="#" onclick="document.getElementById('otherbooks').outerHTML='';" style="vertical-align: top;">(close)</a><br />

  <a target="_blank" href="https://nostarch.com/automatestuff2" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_automate.link');"><img src="/images/cover_automate2_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/big-book-small-python-projects" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_bigbookpython.link');"><img src="/images/cover_bigbookpython_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/beyond-basic-stuff-python" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_beyond.link');"><img src="/images/cover_beyond_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/inventwithpython" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_invent.link');"><img src="/images/cover_invent4th_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://www.amazon.com/Making-Games-Python-Pygame-Sweigart/dp/1469901730?ie=UTF8&amp;tag=playwithpyth-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1469901730" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_pygame.link');"><img src="/images/cover_makinggames_thumb.webp" style="height: 200px; border: solid black 1px; /"></a>
  <a target="_blank" href="https://nostarch.com/crackingcodes" onclick="javascript: pageTracker._trackPageview('/affiliate_chapters_hacking.link');"><img src="/images/cover_crackingcodes_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/scratchplayground"><img src="/images/cover_scratchprogrammingplayground_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <a target="_blank" href="https://nostarch.com/codingwithminecraft"><img src="/images/cover_codingwithminecraft_thumb.webp" style="height: 200px; border: solid black 1px;" /></a>
  <br />
  <a href="https://inventwithpython.com/automateudemy">Use this link to get 70% off the Automate the Boring Stuff online video course.</a><br />
  <a href="https://www.patreon.com/AlSweigart">Support me on Patreon</a>
</div>

<a href="chapter22.html">Prev: Chapter 22 - Finding and Generating Prime Numbers</a> | <a href="chapter24.html">Next: Chapter 24 - Programming the Public Key Cipher</a>




<div><a target="_blank" href="https://www.amazon.com/gp/product/1593278225/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1593278225&linkCode=as2&tag=playwithpyth-20&linkId=bf3b22819f0886d277e88b8a653b81ad">
<img src="images/cover_crackingcodes_thumb.webp" /><br />Buy the print or ebook online.</a></div>
<div><a href="chapter22.html">Previous Chapter - Finding and Generating Prime Numbers</a> | <a href="chapter24.html">Next Chapter - Public Key Cryptography and the Public Key Cipher</a></div>
<div id="calibre_link-834" class="calibre">
<h2 class="h2a1" id="calibre_link-53"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-995" class="calibre1"></span><span class="big">23</span><br class="calibre15" />GENERATING KEYS FOR THE PUBLIC KEY CIPHER</h2>
<p class="epigraph"><em class="calibre7">“Use deliberately compromised cryptography, that has a back door that only the ‘good guys’ are supposed to have the keys to, and you have effectively no security. You might as well skywrite it as encrypt it with pre-broken, sabotaged encryption.”<br class="calibre9" />&mdash;Cory Doctorow, science fiction author, 2015</em></p>
<div class="image"><img src="images/00078.jpeg" alt="Images" class="calibre4" /></div>
<p class="noindent">All the ciphers you’ve learned about in this book so far have one feature in common: the encryption key is the same as the decryption key. This leads to a tricky problem: how do you share encrypted messages with someone you’ve never talked to before? Any eavesdroppers would be able to intercept an encryption key you send just as easily as they could intercept the encrypted messages.</p>
<p class="indent">In this chapter, you’ll learn about public key cryptography, which allows strangers to share encrypted messages using a public key and a private key. You’ll learn about the public key cipher, which in this book is based on the RSA cipher. Because the RSA cipher is complex and involves multiple steps, you’ll write two programs. In this chapter, you’ll write the public key generation program to generate your public and private keys. Then, in <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-305"></span><a href="#calibre_link-54" class="calibre8">Chapter 24</a>, you’ll write a second program to encrypt and decrypt messages using the public key cipher and applying the keys generated here. Before we dive into the program, let’s explore how public key cryptography works.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre5">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Public key cryptography</p>
<p class="bull">• Authentication</p>
<p class="bull">• Digital signatures</p>
<p class="bull">• MITM attacks</p>
<p class="bull">• Generating public and private keys</p>
<p class="bull">• Hybrid cryptosystems</p>
</div>
<h3 class="h1" id="calibre_link-791"><strong class="calibre3">Public Key Cryptography</strong></h3>
<p class="noindent">Imagine that someone on the other side of the world wants to communicate with you. You both know that spy agencies are monitoring all emails, letters, texts, and phone calls. To send encrypted messages to that person, you both must agree on a secret key to use. But if one of you emails the secret key to the other, the spy agency will intercept this key and then decrypt any future messages encrypted using that key. Secretly meeting in person to exchange the key is impossible. You can try encrypting the key, but this requires sending <em class="calibre7">that secret key</em> for that message to the other person, which will also be intercepted.</p>
<p class="indent"><em class="calibre7">Public key cryptography</em> solves this encryption problem by using two keys, one for encryption and one for decryption, and is an example of an <em class="calibre7">asymmetric cipher</em>. Ciphers that use the same key for encryption and decryption, like many of the previous ciphers in this book, are <em class="calibre7">symmetric ciphers</em>.</p>
<p class="indent">It’s important to know that <em class="calibre7">a message encrypted using the encryption key (public key) can only be decrypted using the decryption key (private key)</em>. So even if someone obtains the encryption key, they won’t be able to read the original message because the encryption key can’t decrypt the message.</p>
<p class="indent">The encryption key is called the <em class="calibre7">public key</em> because it can be shared with the entire world. In contrast, the <em class="calibre7">private key</em>, or the decryption key, must be kept secret.</p>
<p class="indent">For example, if Alice wants to send Bob a message, Alice finds Bob’s public key or Bob can give it to her. Then Alice encrypts her message to Bob using Bob’s public key. Because the public key cannot decrypt messages, it doesn’t matter that everyone else has access to Bob’s public key.</p>
<p class="indent">When Bob receives Alice’s encrypted message, he uses his private key to decrypt it. Only Bob has the private key that can decrypt messages encrypted using his public key. If Bob wants to reply to Alice, he finds her public key and uses it to encrypt his reply. Because only Alice knows <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-98"></span>her private key, Alice is the only person who can decrypt the encrypted response from Bob. Even if Alice and Bob are on opposite sides of the world, they can exchange messages without fear of interception.</p>
<p class="indent">The particular public key cipher we’ll implement in this chapter is based on the RSA cipher, which was invented in 1977 and is named using the initials of the last names of its inventors: Ron Rivest, Adi Shamir, and Leonard Adleman.</p>
<p class="indent">The RSA cipher uses large prime numbers hundreds of digits long in its algorithm. It is the reason we discussed the mathematics of prime numbers in <a href="#calibre_link-65" class="calibre8">Chapter 22</a>. The public key algorithm creates two random prime numbers and then uses complicated math (including finding a modular inverse, which you learned how to do in <a href="#calibre_link-59" class="calibre8">Chapter 13</a>) to create the public and private keys.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre5">THE DANGERS OF USING TEXTBOOK RSA</strong></p>
<p class="noindent">Although we don’t write a program in this book to hack the public key cipher program, keep in mind that the <em class="calibre7">publicKeyCipher.py</em> program you’ll write in <a href="#calibre_link-54" class="calibre8">Chapter 24</a> is <em class="calibre7">not</em> secure . Getting cryptography right is very difficult, and a lot of experience is required to know whether a cipher (and a program that implements it) is truly secure .</p>
<p class="indent">The RSA-based program in this chapter is known as <em class="calibre7">textbook RSA</em>, because even though it technically implements the RSA algorithm correctly using large prime numbers, it’s vulnerable to hacking . For example, using pseudorandom instead of truly random number generation functions makes the cipher vulnerable, and as you learned in <a href="#calibre_link-65" class="calibre8">Chapter 22</a>, the Rabin-Miller primality test isn’t guaranteed to always be correct .</p>
<p class="indent">So although you might not be able to hack the ciphertext created by <em class="calibre7">publicKeyCipher.py</em>, others might be able to . To paraphrase the highly accomplished cryptographer Bruce Schneier, anyone can create a cryptographic algorithm that they can’t break themselves . What’s challenging is creating an algorithm that no one else can break, even after years of analysis . The program in this book is just a fun example that is intended to teach you the basics of the RSA cipher . But be sure to use professional encryption software to secure your files . You can find a list of (usually free) encryption software at <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>.</p>
</div>
<h3 class="h1" id="calibre_link-792"><strong class="calibre3">The Problem with Authentication</strong></h3>
<p class="noindent">As ingenious as the public key ciphers might sound, there’s a slight problem. For example, imagine you received this email: “Hello. I am Emmanuel Goldstein, leader of the resistance. I would like to communicate secretly with you about important matters. Attached is my public key.”</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-134"></span>Using this public key, you can be sure that the messages you send cannot be read by anyone other than the sender of the public key. But how do you know the sender is actually Emmanuel Goldstein? You don’t know whether you’re sending encrypted messages to Emmanuel Goldstein or to a spy agency pretending to be Emmanuel Goldstein to lure you into a trap!</p>
<p class="indent">Although public key ciphers and, in fact, all the ciphers in this book can provide <em class="calibre7">confidentiality</em> (keeping the message a secret), they don’t always provide <em class="calibre7">authentication</em> (proof that who you’re communicating with is who they say they are).</p>
<p class="indent">Normally, this isn’t a problem with symmetric ciphers, because when you exchange keys with a person, you can see who that person is. However, when you use public key encryption, you don’t need to see a person to get their public key and begin sending them encrypted messages. Authentication is critical to keep in mind when you’re using public key cryptography.</p>
<p class="indent">An entire field called <em class="calibre7">public key infrastructure (PKI)</em> manages authentication so you can match public keys to people with some level of security; however, this topic is beyond the scope of this book.</p>
<h4 class="h2" id="calibre_link-793"><strong class="calibre3"><em class="calibre12">Digital Signatures</em></strong></h4>
<p class="noindent"><em class="calibre7">Digital signatures</em> allow you to electronically sign documents using encryption. To understand why digital signatures are necessary, let’s look at the following example email from Alice to Bob:</p>
<p class="block-quote">Dear Bob,</p>
<p class="block-quote">I promise to buy your old broken laptop for one million dollars.</p>
<p class="block-quote">Sincerely,</p>
<p class="block-quote">Alice</p>
<p class="indent">This is great news for Bob because he wants to get rid of his worthless laptop for any price. But what if Alice later claims that she didn’t make this promise and that the email Bob received is a fake that she didn’t send. After all, Bob could have easily created this email.</p>
<p class="indent">If they met in person, Alice and Bob could simply sign a contract agreeing to the sale. A handwritten signature is not as easy to forge and provides some proof that Alice did make this promise. But even if Alice signed such a contract, took a photo of it with her digital camera, and sent Bob the image file, it’s still conceivable that the image could have been altered.</p>
<p class="indent">The RSA cipher (like other public key ciphers) not only encrypts messages but also allows us to <em class="calibre7">digitally sign</em> a file or string. For example, Alice can encrypt a message using her private key, producing ciphertext that only Alice’s public key can decrypt. This ciphertext becomes the digital signature for the file. It isn’t actually a secret because everyone in the world has access to Alice’s public key to decrypt it. <em class="calibre7">But by encrypting a message using her private key, Alice can digitally sign the message in a way that cannot be forged.</em> <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-276"></span>Because only Alice has access to her private key, only Alice could have produced this ciphertext, and she couldn’t say that Bob forged or altered it!</p>
<p class="indent">The guarantee that someone who has authored a message won’t be able to deny authoring that message at a later time is called <em class="calibre7">non-repudiation</em>.</p>
<p class="indent">People use digital signatures for many important activities, including cryptocurrency, authentication of public keys, and anonymous web surfing. To find out more, go to <em class="calibre7"><a href="https://www.nostarch.com/crackingcodes/" class="calibre8">https://www.nostarch.com/crackingcodes/</a></em>. Read on to understand why authentication is as important as a secure cipher.</p>
<h4 class="h2" id="calibre_link-794"><strong class="calibre3"><em class="calibre12">Beware the MITM Attack</em></strong></h4>
<p class="noindent">Even more insidious than someone hacking our encrypted messages is a <em class="calibre7">man-in-the-middle</em> or <em class="calibre7">machine-in-the-middle (MITM) attack</em>. In this type of attack, someone intercepts your message and passes it along without your knowledge. For example, let’s say Emmanuel Goldstein really does want to communicate with you and sends you an unencrypted message with his public key, but the spy agency’s routers intercept it. The agency can replace the public key Emmanuel attached to the email with its own public key, and then send the message on to you. You would have no way of knowing whether the key you received is Emmanuel’s key or the spy agency’s key!</p>
<p class="indent">Then when you encrypt a reply to Emmanuel, you’re actually encrypting using the spy agency’s public key, not Emmanuel’s public key. The spy agency would be able to intercept that message, decrypt it and read it, and then reencrypt it using Emmanuel’s actual public key before sending your message to Emmanuel. The agency could do the same with any replies that Emmanuel sends to you. <a href="#calibre_link-835" class="calibre8">Figure 23-1</a> shows how the MITM attack works.</p>
<div class="image"><img src="images/00076.jpeg" alt="Images" class="calibre4" /></div>
<p class="figcap"><a id="calibre_link-835" class="calibre8"></a><em class="calibre7">Figure 23-1: An MITM attack</em></p>
<p class="indent">To you and Emmanuel, it looks like you’re communicating with each other in secret. But the spy agency is reading all your messages because you and Emmanuel are encrypting your messages using public keys generated by the spy agency! Again, this problem exists because a public key cipher only provides confidentiality, not authentication. An in-depth discussion of authentication and public key infrastructure is beyond the scope of this book. But now that you know how public key cryptography provides confidentiality, let’s look at how to generate keys for the public key cipher.</p>
<h3 class="h1" id="calibre_link-795"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-252" class="calibre1"></span>Steps for Generating Public and Private Keys</h3>
<p class="noindent">Each key in the public key scheme is made of two numbers. The public key will be the two numbers <em class="calibre7">n</em> and <em class="calibre7">e</em>. The private key will be the two numbers <em class="calibre7">n</em> and <em class="calibre7">d</em>.</p>
<p class="indent">The three steps to create these numbers are as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">Create two random, distinct, very large prime numbers: <em class="calibre7">p</em> and <em class="calibre7">q</em>. Multiply these two numbers to get a number called <em class="calibre7">n</em>.</p></li>
<li value="2" class="calibre11"><p class="noindent">Create a random number, called <em class="calibre7">e</em>, which is relatively prime to (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1).</p></li>
<li value="3" class="calibre11"><p class="noindent">Calculate the modular inverse of <em class="calibre7">e</em>, which we’ll call <em class="calibre7">d</em>.</p></li>
</ol>
<p class="indent">Notice that <em class="calibre7">n</em> is used in both keys. The <em class="calibre7">d</em> number must be kept secret because it can decrypt messages. Now you’re ready to write a program that generates these keys.</p>
<h3 class="h1" id="calibre_link-796">Source Code for the Public Key Generation Program</h3>
<p class="noindent">Open a new file editor window by selecting <strong class="calibre5">File</strong><span class="ent">▸</span><strong class="calibre5">New File</strong>. Make sure the <em class="calibre7">primeNum.py</em> and <em class="calibre7">cryptomath.py</em> modules are in the same folder as the program file. Enter the following code into the file editor and save it as <em class="calibre7">makePublicPrivateKeys.py</em>.</p>
<p class="noindentz"><em class="calibre7">makePublic<br class="calibre9" />PrivateKeys.py</em></p>
<p class="programs1">&nbsp;1. # Public Key Generator<br class="calibre9" />&nbsp;2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)<br class="calibre9" />&nbsp;3.<br class="calibre9" />&nbsp;4. import random, sys, os, primeNum, cryptomath<br class="calibre9" />&nbsp;5.<br class="calibre9" />&nbsp;6.<br class="calibre9" />&nbsp;7. def main():<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a public/private keypair with 1024-bit keys:<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Making key files...')<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeKeyFiles('al_sweigart', 1024)<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key files made.')<br class="calibre9" />12.<br class="calibre9" />13. def generateKey(keySize):<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Creates public/private keys keySize bits in size.<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = 0<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = 0<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 1: Create two prime numbers, p and q. Calculate n = p * q:<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Generating p prime...')<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while p == q:<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = primeNum.generateLargePrime(keySize)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = primeNum.generateLargePrime(keySize)<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = p * q<br class="calibre9" />23.<br class="calibre9" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 2: Create a number e that is relatively prime to (p-1)*(q-1):<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Generating e that is relatively prime to (p-1)*(q-1)...')<br class="calibre9" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-292"></span>26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep trying random numbers for e until one is valid:<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1:<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre9" />31.<br class="calibre9" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 3: Calculate d, the mod inverse of e:<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Calculating d that is mod inverse of e...')<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = cryptomath.findModInverse(e, (p - 1) * (q - 1))<br class="calibre9" />35.<br class="calibre9" />36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publicKey = (n, e)<br class="calibre9" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privateKey = (n, d)<br class="calibre9" />38.<br class="calibre9" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Public key:', publicKey)<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Private key:', privateKey)<br class="calibre9" />41.<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (publicKey, privateKey)<br class="calibre9" />43.<br class="calibre9" />44.<br class="calibre9" />45. def makeKeyFiles(name, keySize):<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Creates two files 'x_pubkey.txt' and 'x_privkey.txt' (where x<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# is the value in name) with the n,e and d,e integers written in<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# them, delimited by a comma.<br class="calibre9" />49.<br class="calibre9" />50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Our safety check will prevent us from overwriting our old key files:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if os.path.exists('%s_pubkey.txt' % (name)) or<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.path.exists('%s_privkey.txt' % (name)):<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('WARNING: The file %s_pubkey.txt or %s_privkey.txt<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;already exists! Use a different name or delete these files and<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rerun this program.' % (name, name))<br class="calibre9" />53.<br class="calibre9" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publicKey, privateKey = generateKey(keySize)<br class="calibre9" />55.<br class="calibre9" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The public key is a %s and a %s digit number.' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(len(str(publicKey[0])), len(str(publicKey[1]))))<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Writing public key to file %s_pubkey.txt...' % (name))<br class="calibre9" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open('%s_pubkey.txt' % (name), 'w')<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write('%s,%s,%s' % (keySize, publicKey[0], publicKey[1]))<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />62.<br class="calibre9" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The private key is a %s and a %s digit number.' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(len(str(privateKey[0])), len(str(privateKey[1]))))<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Writing private key to file %s_privkey.txt...' % (name))<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open('%s_privkey.txt' % (name), 'w')<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write('%s,%s,%s' % (keySize, privateKey[0], privateKey[1]))<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()<br class="calibre9" />69.<br class="calibre9" />70.<br class="calibre9" />71. # If makePublicPrivateKeys.py is run (instead of imported as a module),<br class="calibre9" />72. # call the main() function:<br class="calibre9" />73. if __name__ == '__main__':<br class="calibre9" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<h3 class="h1" id="calibre_link-797"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-111" class="calibre1"></span>Sample Run of the Public Key Generation Program</h3>
<p class="noindent">When we run the <em class="calibre7">makePublicPrivateKeys.py</em> program, the output should look similar to the following (of course, the numbers for your keys will look different because they’re randomly generated):</p>
<p class="programs1">Making key files...<br class="calibre9" />Generating p prime...<br class="calibre9" />Generating q prime...<br class="calibre9" />Generating e that is relatively prime to (p-1)*(q-1)...<br class="calibre9" />Calculating d that is mod inverse of e...<br class="calibre9" />Public key: (210902406316700502401968491406579417405090396754616926135810621<br class="calibre9" />2161161913380865678407459875355468897928072386270510720443827324671435893274<br class="calibre9" />8583937496850624116776147241821152026946322876869404394483922202407821672864<br class="calibre9" />2424789208131826990008473526711744296548563866768454251404951960805224682425<br class="calibre9" />498975230488955908086491852116348777849536270685085446970952915640050522212<br class="calibre9" />204221803744494065881010331486468305317449607027884787770315729959789994713<br class="calibre9" />265311327663776167710077018340036668306612665759417207845823479903440572724<br class="calibre9" />068125211002329298338718615859542093721097258263595617482450199200740185492<br class="calibre9" />04468791300114315056117093, 17460230769175161021731845459236833553832403910869<br class="calibre9" />129054954200373678580935247606622265764388235752176654737805849023006544732896<br class="calibre9" />308685513669509917451195822611398098951306676600958889189564599581456460070270<br class="calibre9" />393693277683404354811575681605990659145317074127084557233537504102479937142530<br class="calibre9" />0216777273298110097435989)<br class="calibre9" />Private key: (21090240631670050240196849140657941740509039675461692613581062<br class="calibre9" />1216116191338086567840745987535546889792807238627051072044382732467143589327<br class="calibre9" />4858393749685062411677614724182115202694632287686940439448392220240782167286<br class="calibre9" />4242478920813182699000847352671174429654856386676845425140495196080522468242<br class="calibre9" />5498975230488955908086491852116348777849536270685085446970952915640050522212<br class="calibre9" />204221803744494065881010331486468305317449607027884787770315729959789994713<br class="calibre9" />265311327663776167710077018340036668306612665759417207845823479903440572724<br class="calibre9" />068125211002329298338718615859542093721097258263595617482450199200740185492<br class="calibre9" />04468791300114315056117093, 47676735798137710412166884916983765043173120289416<br class="calibre9" />904341295971552286870991874666099933371008075948549008551224760695942666962465<br class="calibre9" />968168995404993934508399014283053710676760835948902312888639938402686187075052<br class="calibre9" />360773062364162664276144965652558545331166681735980981384493349313058750259417<br class="calibre9" />68372702963348445191139635826000818122373486213256488077192893119257248107794<br class="calibre9" />25681884603640028673273135292831170178614206817165802812291528319562200625082<br class="calibre9" />55726168047084560706359601833919317974375031636011432177696164717000025430368<br class="calibre9" />26990539739057474642785416933878499897014777481407371328053001838085314443545<br class="calibre9" />845219087249544663398589)<br class="calibre9" />The public key is a 617 and a 309 digit number.<br class="calibre9" />Writing public key to file al_sweigart_pubkey.txt...<br class="calibre9" />The private key is a 617 and a 309 digit number.<br class="calibre9" />Writing private key to file al_sweigart_privkey.txt...</p>
<p class="indent">Because the two keys are very large, they’re each written to their own files, <em class="calibre7">al_sweigart_pubkey.txt</em> and <em class="calibre7">al_sweigart_privkey.txt</em>. We’ll use both files in the public key cipher program in <a href="#calibre_link-54" class="calibre8">Chapter 24</a> to encrypt and decrypt messages. These filenames come from the string <span class="literal">'al_sweigart'</span>, which is passed to the <span class="literal">makeKeyFiles()</span> function on line 10 of the program. You can specify different filenames by passing a different string.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-112"></span>If we run <em class="calibre7">makePublicPrivateKeys.py</em> again and pass the same string to <span class="literal">makeKeyFiles()</span>, the output of the program should look like this:</p>
<p class="programs1">Making key files...<br class="calibre9" />WARNING: The file al_sweigart_pubkey.txt or al_sweigart_privkey.txt already<br class="calibre9" />exists! Use a different name or delete these files and rerun this program.</p>
<p class="indent">This warning is provided so we don’t accidentally overwrite our key files, which would make any files encrypted with them impossible to recover. Be sure to keep these key files safe!</p>
<h3 class="h1" id="calibre_link-798">Creating the main() Function</h3>
<p class="noindent">When we run <em class="calibre7">makePublicPrivateKeys.py</em>, the <span class="literal">main()</span> function is called, which creates the public and private key files using the <span class="literal">makeKeyFiles()</span> function that we’ll define shortly.</p>
<p class="programs1">&nbsp;7. def main():<br class="calibre9" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Create a public/private keypair with 1024-bit keys:<br class="calibre9" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Making key files...')<br class="calibre9" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeKeyFiles('al_sweigart', 1024)<br class="calibre9" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Key files made.')</p>
<p class="indent">Because the computer might take a while to generate the keys, we print a message on line 9 before the <span class="literal">makeKeyFiles()</span> call to let the user know what the program is doing.</p>
<p class="indent">The <span class="literal">makeKeyFiles()</span> call on line 10 passes the string <span class="literal">'al_sweigart'</span> and the integer <span class="literal">1024</span>, which generates keys that are 1024 bits and stores them in the files <em class="calibre7">al_sweigart_pubkey.txt</em> and <em class="calibre7">al_sweigart_privkey.txt</em>. The larger the key size, the more possible keys there are and the stronger the security of the cipher. However, large key sizes mean that it takes longer to encrypt or decrypt messages. I chose the size of 1024 bits as a balance between speed and security for this book’s examples; but in reality, a key size of 2048 bits or even 3072 bits is necessary for secure public key encryption.</p>
<h3 class="h1" id="calibre_link-799">Generating Keys with the generateKey() Function</h3>
<p class="noindent">The first step in creating keys is coming up with the two random prime numbers <em class="calibre7">p</em> and <em class="calibre7">q</em>. These numbers must be two large and distinct prime numbers.</p>
<p class="programs1">13. def generateKey(keySize):<br class="calibre9" />14.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Creates public/private keys keySize bits in size.<br class="calibre9" />15.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = 0<br class="calibre9" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = 0<br class="calibre9" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 1: Create two prime numbers, p and q. Calculate n = p * q:<br class="calibre9" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Generating p prime...')<br class="calibre9" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while p == q:<br class="calibre9" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p = primeNum.generateLargePrime(keySize)<br class="calibre9" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q = primeNum.generateLargePrime(keySize)<br class="calibre9" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = p * q</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-295"></span>The <span class="literal">generateLargePrime()</span> function you wrote in the <em class="calibre7">primeNum.py</em> program in <a href="#calibre_link-65" class="calibre8">Chapter 22</a> returns two prime numbers as integer values on lines 20 and 21, which we store in the variables <span class="literal">p</span> and <span class="literal">q</span>. This is done inside a <span class="literal">while</span> loop that continues to loop as long as <span class="literal">p</span> and <span class="literal">q</span> are the same. If <span class="literal">generateLargePrime</span><span class="literal">()</span> returns the same integer for both <span class="literal">p</span> and <span class="literal">q</span>, the program will try again to find unique primes for <span class="literal">p</span> and <span class="literal">q</span>. The value in <span class="literal">keySize</span> determines the sizes of <span class="literal">p</span> and <span class="literal">q</span>. On line 22, we multiply <span class="literal">p</span> and <span class="literal">q</span>, and store the product in <span class="literal">n</span>.</p>
<p class="indent">Next, in step 2, we calculate the other piece of the public key: <em class="calibre7">e</em>.</p>
<h4 class="h2" id="calibre_link-800"><strong class="calibre3"><em class="calibre12">Calculating an e Value</em></strong></h4>
<p class="noindent">The value for <em class="calibre7">e</em> is calculated by finding a number that is relatively prime to (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1). We won’t go into detail about why <em class="calibre7">e</em> is calculated this way, but we want <em class="calibre7">e</em> to be relatively prime to (<em class="calibre7">p</em> &ndash; 1) × (<em class="calibre7">q</em> &ndash; 1) because this ensures that <em class="calibre7">e</em> will always result in a unique ciphertext.</p>
<p class="indent">Using an infinite <span class="literal">while</span> loop, line 26 calculates a number <span class="literal">e</span>, which is relatively prime to the product of <span class="literal">p &ndash; 1</span> and <span class="literal">q &ndash; 1</span>.</p>
<p class="programs1">24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 2: Create a number e that is relatively prime to (p-1)*(q-1):<br class="calibre9" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Generating e that is relatively prime to (p-1)*(q-1)...')<br class="calibre9" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre9" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Keep trying random numbers for e until one is valid:<br class="calibre9" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))<br class="calibre9" />29.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1:<br class="calibre9" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">The <span class="literal">random.randrange()</span> call on line 28 returns a random integer and stores it in the <span class="literal">e</span> variable. Then line 29 tests whether <span class="literal">e</span> is relatively prime to <span class="literal">(p - 1) * (q - 1)</span> using the <span class="literal">cryptomath</span> module’s <span class="literal">gcd()</span> function. If <span class="literal">e</span> is relatively prime, the <span class="literal">break</span> statement on line 30 breaks out of the infinite loop. Otherwise, the program execution jumps back to line 26 and keeps trying different random numbers until it finds one that is relatively prime to <span class="literal">(p</span> <span class="literal">-</span> <span class="literal">1)</span> <span class="literal">*</span> <span class="literal">(q</span> <span class="literal">-</span> <span class="literal">1)</span>.</p>
<p class="indent">Next, we calculate the private key.</p>
<h4 class="h2" id="calibre_link-801"><strong class="calibre3"><em class="calibre12">Calculating a d Value</em></strong></h4>
<p class="noindent">The third step is to find the other half of the private key used to decrypt, which is <em class="calibre7">d</em>. The <em class="calibre7">d</em> is just the modular inverse of <em class="calibre7">e</em>, and we already have the <span class="literal">findModInverse()</span> function in the <span class="literal">cryptomath</span> module, which we used in <a href="#calibre_link-59" class="calibre8">Chapter 13</a>, to calculate that.</p>
<p class="indent">Line 34 calls <span class="literal">findModInverse()</span> and stores the result in variable <span class="literal">d</span>.</p>
<p class="programs1">32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Step 3: Calculate d, the mod inverse of e:<br class="calibre9" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Calculating d that is mod inverse of e...')<br class="calibre9" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = cryptomath.findModInverse(e, (p - 1) * (q - 1))</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-996"></span>We’ve now defined all the numbers we need to generate the public and private keys.</p>
<h4 class="h2" id="calibre_link-802"><strong class="calibre3"><em class="calibre12">Returning the Keys</em></strong></h4>
<p class="noindent">Recall that in the public key cipher, the public and private keys consist of two numbers each. The integers stored in <em class="calibre7">n</em> and <em class="calibre7">e</em> represent the public key, and the integers stored in <em class="calibre7">n</em> and <em class="calibre7">d</em> represent the private key. Lines 36 and 37 store these integer pairs as tuple values in <span class="literal">publicKey</span> and <span class="literal">privateKey</span>.</p>
<p class="programs1">36.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publicKey = (n, e)<br class="calibre9" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privateKey = (n, d)</p>
<p class="indent">The remaining lines in the <span class="literal">generateKey()</span> function print the keys on the screen using <span class="literal">print()</span> calls on lines 39 and 40.</p>
<p class="programs1">39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Public key:', publicKey)<br class="calibre9" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Private key:', privateKey)<br class="calibre9" />41.<br class="calibre9" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (publicKey, privateKey)</p>
<p class="indent">Then when <span class="literal">generateKey()</span> is called, line 42 returns a tuple containing <span class="literal">publicKey</span> and <span class="literal">privateKey</span>.</p>
<p class="indent">After we’ve generated the public and private keys, we also want to store them in files so our public key cipher program can use them later to encrypt and decrypt. In addition, storing the keys in files is very useful because the two integers that make up each key are hundreds of digits long, making them difficult to memorize or conveniently write down.</p>
<h3 class="h1" id="calibre_link-803">Creating Key Files with the makeKeyFiles() Function</h3>
<p class="noindent">The <span class="literal">makeKeyFiles()</span> function stores the keys in files by taking a filename and a key size as parameters.</p>
<p class="programs1">45. def makeKeyFiles(name, keySize):<br class="calibre9" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Creates two files 'x_pubkey.txt' and 'x_privkey.txt' (where x<br class="calibre9" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# is the value in name) with the n,e and d,e integers written in<br class="calibre9" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# them, delimited by a comma.</p>
<p class="indent">The function creates two files in the format <em class="calibre7">&lt;name&gt;_pubkey.txt</em> and <em class="calibre7">&lt;name&gt;_privkey.txt</em> that store the public and private keys, respectively. The <span class="literal">name</span> parameter passed to the function determines the <em class="calibre7">&lt;name&gt;</em> part of the files.</p>
<p class="indent">To prevent accidentally deleting key files by running the program again, line 51 checks whether the public or private key files with the given name already exist. If they do, the program exits with a warning message.</p>
<p class="programs1">50.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Our safety check will prevent us from overwriting our old key files:<br class="calibre9" />51.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if os.path.exists('%s_pubkey.txt' % (name)) or<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.path.exists('%s_privkey.txt' % (name)):<br class="calibre9" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit('WARNING: The file %s_pubkey.txt or %s_privkey.txt<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;already exists! Use a different name or delete these files and<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rerun this program.' % (name, name))</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-113"></span>After this check, line 54 calls <span class="literal">generateKey()</span> and passes <span class="literal">keySize</span> to create the public and private keys of the size specified.</p>
<p class="programs1">54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publicKey, privateKey = generateKey(keySize)</p>
<p class="indent">The <span class="literal">generateKey()</span> function returns a tuple of two tuples that it assigns to the <span class="literal">publicKey</span> and <span class="literal">privateKey</span> variables using multiple assignment. The first tuple has two integers for the public key, and the second tuple has two integers for the private key.</p>
<p class="indent">Now that we’ve finished the setup for creating the key files, we can make the actual key files. We’ll store the two numbers that make up each key in text files.</p>
<p class="indent">Line 56 prints an empty line, and then line 57 prints information about the public key for the user.</p>
<p class="programs1">56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />57.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The public key is a %s and a %s digit number.' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(len(str(publicKey[0])), len(str(publicKey[1]))))<br class="calibre9" />58.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Writing public key to file %s_pubkey.txt...' % (name))</p>
<p class="indent">Line 57 indicates how many digits are in the integer at <span class="literal">publicKey[0]</span> and <span class="literal">publicKey[1]</span> by converting those values to strings using the <span class="literal">str()</span> function and then finding the length of the string using the <span class="literal">len()</span> function. Then, line 58 reports that the public key is being written to the file.</p>
<p class="indent">The key file’s contents include the key size, a comma, the <span class="literal">n</span> integer, another comma, and the <span class="literal">e</span> (or <span class="literal">d</span>) integer. For example, the file’s contents should look like this: <span class="codeitalic">key size integer</span><span class="literal">,</span> <span class="codeitalic">n integer</span><span class="literal">,</span> <span class="codeitalic">e or d integer</span>, as in the following <em class="calibre7">al_sweigart_pubkey.txt</em> file:</p>
<div class="image"><img src="images/00024.jpeg" alt="Images" class="calibre4" /></div>
<p class="indent">Lines 59 to 61 open the <em class="calibre7">&lt;name&gt;_pubkey.txt</em> file in write mode, write the keys to the file, and close it.</p>
<p class="programs1">59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open('%s_pubkey.txt' % (name), 'w')<br class="calibre9" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write('%s,%s,%s' % (keySize, publicKey[0], publicKey[1]))<br class="calibre9" />61.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-258"></span>Lines 63 to 68 do the same thing as lines 56 to 61 except they write the private key to the <em class="calibre7">&lt;name&gt;_privkey.txt</em> file.</p>
<p class="programs1">63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print()<br class="calibre9" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The private key is a %s and a %s digit number.' %<br class="calibre9" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(len(str(publicKey[0])), len(str(publicKey[1]))))<br class="calibre9" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Writing private key to file %s_privkey.txt...' % (name))<br class="calibre9" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo = open('%s_privkey.txt' % (name), 'w')<br class="calibre9" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.write('%s,%s,%s' % (keySize, privateKey[0], privateKey[1]))<br class="calibre9" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fo.close()</p>
<p class="indent">Be sure that nobody hacks your computer and copies these key files. If they obtain your private key file, they’ll be able to decrypt all your messages!</p>
<h3 class="h1" id="calibre_link-804">Calling the main() Function</h3>
<p class="noindent">At the end of the program, lines 73 and 74 call the <span class="literal">main()</span> function if <em class="calibre7">makePublicPrivateKeys.py</em> is being run as a program instead of being imported as a module by another program.</p>
<p class="programs1">71. # If makePublicPrivateKeys.py is run (instead of imported as a module),<br class="calibre9" />72. # call the main() function:<br class="calibre9" />73. if __name__ == '__main__':<br class="calibre9" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main()</p>
<p class="indent">Now you have a program that can generate public and private keys. Although the public key cipher is useful for starting communications between two people who don’t have a way to securely exchange keys, it’s usually not used for all encrypted communication because of the drawbacks of public key cryptography. Often, public key ciphers are instead used in hybrid cryptosystems.</p>
<h3 class="h1" id="calibre_link-805">Hybrid Cryptosystems</h3>
<p class="noindent">RSA and public key encryption take lots of time to compute. This is especially true for servers that need to make thousands of encrypted connections with other computers per second. As a workaround, people can use public key encryption to encrypt and distribute the key for a much faster <em class="calibre7">symmetric key cipher</em>, which is any type of cipher where the decryption and encryption keys are the same. After securely sending the symmetric cipher’s key to the receiver using a public key&ndash;encrypted message, the sender can use the symmetric cipher for future messages. Using both a symmetric key cipher and an asymmetric key cipher to communicate is called a <em class="calibre7">hybrid cryptosystem</em>. You can read more about hybrid cryptosystems at <em class="calibre7"><a href="https://en.wikipedia.org/wiki/Hybrid_cryptosystem" class="calibre8">https://en.wikipedia.org/wiki/Hybrid_cryptosystem</a></em>.</p>
<h3 class="h1" id="calibre_link-806"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-997" class="calibre1"></span>Summary</h3>
<p class="noindent">In this chapter, you learned how public key cryptography works and how to write a program that generates the public and private keys. In <a href="#calibre_link-54" class="calibre8">Chapter 24</a>, you’ll use these keys to perform encryption and decryption using the public key cipher.</p>
<div class="sidebar">
<p class="sidebart" id="calibre_link-807"><strong class="calibre5">PRACTICE QUESTIONS</strong></p>
<p class="noindent">Answers to the practice questions can be found on the book’s website at <a href="https://www.nostarch.com/crackingcodes/" class="calibre8"><em class="calibre7">https://www.nostarch.com/crackingcodes/</em></a>.</p>
<ol class="calibre13">
<li value="1" class="calibre11"><p class="noindent">What is the difference between a symmetric cipher and an asymmetric cipher?</p></li>
<li value="2" class="calibre11"><p class="noindent">Alice generates a public key and a private key . Unfortunately, she later loses her private key.</p>
<ol class="lower-alpha">
<li value="1" class="calibre11"><p class="noindent">Will other people be able to send her encrypted messages?</p></li>
<li value="2" class="calibre11"><p class="noindent">Will she be able to decrypt messages previously sent to her?</p></li>
<li value="3" class="calibre11"><p class="noindent">Will she be able to digitally sign documents?</p></li>
<li value="4" class="calibre11"><p class="noindent">Will other people be able to verify her previously signed documents?</p></li>
</ol></li>
<li value="3" class="calibre11"><p class="noindent">What are authentication and confidentiality? How are they different?</p></li>
<li value="4" class="calibre11"><p class="noindent">What is non-repudiation?</p></li>
</ol>
</div>
</div>



<a href="chapter22.html">Prev: Chapter 22 - Finding and Generating Prime Numbers</a> | <a href="chapter24.html">Next: Chapter 24 - Programming the Public Key Cipher</a>
</body></html>