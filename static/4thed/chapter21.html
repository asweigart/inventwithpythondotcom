<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 21: A Dodger Game with Sounds and Images</title></head><body>
<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<a href="chapter20.html">Prev: Chapter 20: Using Sounds and Images</a>


<div id="calibre_link-136" class="calibre">
<h2 class="h1" id="calibre_link-99"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-936" class="calibre1"></span><span class="big"><strong class="calibre2">21</strong></span><br class="calibre9" /><strong class="calibre2">A DODGER GAME WITH SOUNDS AND IMAGES</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">The previous four chapters went over the <span class="literal1">pygame</span> module and demonstrated how to use its many features. In this chapter, we’ll use that knowledge to create a graphical game called Dodger.</p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• The <span class="literal1">pygame.FULLSCREEN</span> flag</p>
<p class="bull">• The <span class="literal1">move_ip() Rect</span> method</p>
<p class="bull">• Implementing cheat codes</p>
<p class="bull">• Modifying the Dodger game</p>
</div>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-239"></span>In the Dodger game, the player controls a sprite (the player’s character) who must dodge a whole bunch of baddies that fall from the top of the screen. The longer the player can keep dodging the baddies, the higher their score will get.</p>
<p class="indent">Just for fun, we’ll also add some cheat modes to this game. If the player holds down the X key, every baddie’s speed is reduced to a super slow rate. If the player holds down the Z key, the baddies will reverse their direction and travel up the screen instead of down.</p>
<h3 class="h2" id="calibre_link-766"><strong class="calibre2">Review of the Basic pygame Data Types</strong></h3>
<p class="noindent">Before we start making Dodger, let’s review some of the basic data types used in <span class="literal1">pygame</span>:</p>
<p class="term"><span class="literal1"><span class="codestrong">pygame.Rect</span></span></p>
<p class="termlist"><span class="literal1">Rect</span> objects represent a rectangular space’s location and size. The location is determined by the <span class="literal1">Rect</span> object’s <span class="literal1">topleft</span> attribute (or the <span class="literal1">topright</span>, <span class="literal1">bottomleft</span>, and <span class="literal1">bottomright</span> attributes). These corner attributes are a tuple of integers for the x- and y-coordinates. The size is determined by the <span class="literal1">width</span> and <span class="literal1">height</span> attributes, which are integers indicating how many pixels long or high the rectangle is. <span class="literal1">Rect</span> objects have a <span class="literal1">colliderect()</span> method that checks whether they are colliding with another <span class="literal1">Rect</span> object.</p>
<p class="term"><span class="literal1"><span class="codestrong">pygame.Surface</span></span></p>
<p class="termlist"><span class="literal1">Surface</span> objects are areas of colored pixels. A <span class="literal1">Surface</span> object represents a rectangular image, while a <span class="literal1">Rect</span> object represents only a rectangular space and location. <span class="literal1">Surface</span> objects have a <span class="literal1">blit()</span> method that is used to draw the image on one <span class="literal1">Surface</span> object onto another <span class="literal1">Surface</span> object. The <span class="literal1">Surface</span> object returned by the <span class="literal1">pygame.display.set_mode()</span> function is special because anything drawn on that <span class="literal1">Surface</span> object is displayed on the user’s screen when <span class="literal1">pygame.display.update()</span> is called.</p>
<p class="term"><span class="literal1"><span class="codestrong">pygame.event.Event</span></span></p>
<p class="termlist">The <span class="literal1">pygame.event</span> module generates <span class="literal1">Event</span> objects whenever the user provides keyboard, mouse, or other input. The <span class="literal1">pygame.event.get()</span> function returns a list of these <span class="literal1">Event</span> objects. You can determine the type of the <span class="literal1">Event</span> object by checking its <span class="literal1">type</span> attribute. <span class="literal1">QUIT</span>, <span class="literal1">KEYDOWN</span>, and <span class="literal1">MOUSEBUTTONUP</span> are examples of some event types. (See “<a href="#calibre_link-137" class="calibre4">Handling Events</a>” on <a href="#calibre_link-138" class="calibre4">page 292</a> for a complete list of all the event types.)</p>
<p class="term"><span class="literal1"><span class="codestrong">pygame.font.Font</span></span></p>
<p class="termlist">The <span class="literal1">pygame.font</span> module uses the <span class="literal1">Font</span> data type, which represents the typeface used for text in <span class="literal1">pygame</span>. The arguments to pass to <span class="literal1">pygame.font. SysFont()</span> are a string of the font name (it’s common to pass <span class="literal1">None</span> for the font name to get the default system font) and an integer of the font size.</p>
<p class="term"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-244"></span><span class="literal1"><span class="codestrong">pygame.time.Clock</span></span></p>
<p class="termlist">The <span class="literal1">Clock</span> object in the <span class="literal1">pygame.time</span> module is helpful for keeping our games from running faster than the player can see. The <span class="literal1">Clock</span> object has a <span class="literal1">tick()</span> method, which can be passed the number of frames per second (FPS) we want the game to run. The higher the FPS, the faster the game runs.</p>
<h3 class="h2" id="calibre_link-767"><strong class="calibre2">Sample Run of Dodger</strong></h3>
<p class="noindent">When you run this program, the game will look like <a href="#calibre_link-139" class="calibre4">Figure 21-1</a>.</p>
<div class="image"><img src="images/00050.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-139" class="calibre4"></a><em class="calibre6">Figure 21-1: A screenshot of the Dodger game</em></p>
<h3 class="h2" id="calibre_link-768"><strong class="calibre2">Source Code for Dodger</strong></h3>
<p class="noindent">Enter the following code in a new file and save it as <em class="calibre6">dodger.py</em>. You can download the code, image, and sound files from <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython/" class="calibre4">https://www.nostarch.com/inventwithpython/</a></em>. Place the image and sound files in the same folder as <em class="calibre6">dodger.py</em>.</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="indent">If you get errors after entering this code, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<p class="sidenote"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-937"></span><em class="calibre6">dodger.py</em></p>
<p class="programs">&nbsp;&nbsp;1. import pygame, random, sys<br class="calibre7" />&nbsp;&nbsp;2. from pygame.locals import *<br class="calibre7" />&nbsp;&nbsp;3.<br class="calibre7" />&nbsp;&nbsp;4. WINDOWWIDTH = 600<br class="calibre7" />&nbsp;&nbsp;5. WINDOWHEIGHT = 600<br class="calibre7" />&nbsp;&nbsp;6. TEXTCOLOR = (0, 0, 0)<br class="calibre7" />&nbsp;&nbsp;7. BACKGROUNDCOLOR = (255, 255, 255)<br class="calibre7" />&nbsp;&nbsp;8. FPS = 60<br class="calibre7" />&nbsp;&nbsp;9. BADDIEMINSIZE = 10<br class="calibre7" />&nbsp;10. BADDIEMAXSIZE = 40<br class="calibre7" />&nbsp;11. BADDIEMINSPEED = 1<br class="calibre7" />&nbsp;12. BADDIEMAXSPEED = 8<br class="calibre7" />&nbsp;13. ADDNEWBADDIERATE = 6<br class="calibre7" />&nbsp;14. PLAYERMOVERATE = 5<br class="calibre7" />&nbsp;15.<br class="calibre7" />&nbsp;16. def terminate():<br class="calibre7" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.quit()<br class="calibre7" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()<br class="calibre7" />&nbsp;19.<br class="calibre7" />&nbsp;20. def waitForPlayerToPressKey():<br class="calibre7" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />&nbsp;22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />&nbsp;23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()<br class="calibre7" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYDOWN:<br class="calibre7" />&nbsp;26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_ESCAPE: # Pressing ESC quits.<br class="calibre7" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()<br class="calibre7" />&nbsp;28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<br class="calibre7" />&nbsp;29.<br class="calibre7" />&nbsp;30. def playerHasHitBaddie(playerRect, baddies):<br class="calibre7" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerRect.colliderect(b['rect']):<br class="calibre7" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre7" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />&nbsp;35.<br class="calibre7" />&nbsp;36. def drawText(text, font, surface, x, y):<br class="calibre7" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textobj = font.render(text, 1, TEXTCOLOR)<br class="calibre7" />&nbsp;38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textrect = textobj.get_rect()<br class="calibre7" />&nbsp;39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textrect.topleft = (x, y)<br class="calibre7" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surface.blit(textobj, textrect)<br class="calibre7" />&nbsp;41.<br class="calibre7" />&nbsp;42. # Set up pygame, the window, and the mouse cursor.<br class="calibre7" />&nbsp;43. pygame.init()<br class="calibre7" />&nbsp;44. mainClock = pygame.time.Clock()<br class="calibre7" />&nbsp;45. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))<br class="calibre7" />&nbsp;46. pygame.display.set_caption('Dodger')<br class="calibre7" />&nbsp;47. pygame.mouse.set_visible(False)<br class="calibre7" />&nbsp;48.<br class="calibre7" />&nbsp;49. # Set up the fonts.<br class="calibre7" />&nbsp;50. font = pygame.font.SysFont(None, 48)<br class="calibre7" />&nbsp;51.<br class="calibre7" />&nbsp;52. # Set up sounds.<br class="calibre7" />&nbsp;53. gameOverSound = pygame.mixer.Sound('gameover.wav')<br class="calibre7" />&nbsp;54. pygame.mixer.music.load('background.mid')<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-938"></span> 55.<br class="calibre7" />&nbsp;56. # Set up images.<br class="calibre7" />&nbsp;57. playerImage = pygame.image.load('player.png')<br class="calibre7" />&nbsp;58. playerRect = playerImage.get_rect()<br class="calibre7" />&nbsp;59. baddieImage = pygame.image.load('baddie.png')<br class="calibre7" />&nbsp;60.<br class="calibre7" />&nbsp;61. # Show the "Start" screen.<br class="calibre7" />&nbsp;62. windowSurface.fill(BACKGROUNDCOLOR)<br class="calibre7" />&nbsp;63. drawText('Dodger', font, windowSurface, (WINDOWWIDTH / 3),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWHEIGHT / 3))<br class="calibre7" />&nbsp;64. drawText('Press a key to start.', font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWWIDTH / 3) - 30, (WINDOWHEIGHT / 3) + 50)<br class="calibre7" />&nbsp;65. pygame.display.update()<br class="calibre7" />&nbsp;66. waitForPlayerToPressKey()<br class="calibre7" />&nbsp;67.<br class="calibre7" />&nbsp;68. topScore = 0<br class="calibre7" />&nbsp;69. while True:<br class="calibre7" />&nbsp;70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Set up the start of the game.<br class="calibre7" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies = []<br class="calibre7" />&nbsp;72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0<br class="calibre7" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.topleft = (WINDOWWIDTH / 2, WINDOWHEIGHT - 50)<br class="calibre7" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveLeft = moveRight = moveUp = moveDown = False<br class="calibre7" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = slowCheat = False<br class="calibre7" />&nbsp;76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter = 0<br class="calibre7" />&nbsp;77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.mixer.music.play(-1, 0.0)<br class="calibre7" />&nbsp;78.<br class="calibre7" />&nbsp;79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True: # The game loop runs while the game part is playing.<br class="calibre7" />&nbsp;80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score += 1 # Increase score.<br class="calibre7" />&nbsp;81.<br class="calibre7" />&nbsp;82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />&nbsp;83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()<br class="calibre7" />&nbsp;85.<br class="calibre7" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYDOWN:<br class="calibre7" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_z:<br class="calibre7" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = True<br class="calibre7" />&nbsp;89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_x:<br class="calibre7" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowCheat = True<br class="calibre7" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_LEFT or event.key == K_a:<br class="calibre7" />&nbsp;92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveRight = False<br class="calibre7" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveLeft = True<br class="calibre7" />&nbsp;94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_RIGHT or event.key == K_d:<br class="calibre7" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveLeft = False<br class="calibre7" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveRight = True<br class="calibre7" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_UP or event.key == K_w:<br class="calibre7" />&nbsp;98.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveDown = False<br class="calibre7" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveUp = True<br class="calibre7" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_DOWN or event.key == K_s:<br class="calibre7" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveUp = False<br class="calibre7" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveDown = True<br class="calibre7" />103.<br class="calibre7" />104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYUP:<br class="calibre7" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_z:<br class="calibre7" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = False<br class="calibre7" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-939"></span>108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_x:<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowCheat = False<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0<br class="calibre7" />111.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_ESCAPE:<br class="calibre7" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()<br class="calibre7" />113.<br class="calibre7" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_LEFT or event.key == K_a:<br class="calibre7" />115.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveLeft = False<br class="calibre7" />116.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_RIGHT or event.key == K_d:<br class="calibre7" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveRight = False<br class="calibre7" />118.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_UP or event.key == K_w:<br class="calibre7" />119.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveUp = False<br class="calibre7" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_DOWN or event.key == K_s:<br class="calibre7" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveDown = False<br class="calibre7" />122.<br class="calibre7" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == MOUSEMOTION:<br class="calibre7" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If the mouse moves, move the player to the cursor.<br class="calibre7" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.centerx = event.pos[0]<br class="calibre7" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.centery = event.pos[1]<br class="calibre7" />127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add new baddies at the top of the screen, if needed.<br class="calibre7" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not reverseCheat and not slowCheat:<br class="calibre7" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter += 1<br class="calibre7" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if baddieAddCounter == ADDNEWBADDIERATE:<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter = 0<br class="calibre7" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieSize = random.randint(BADDIEMINSIZE, BADDIEMAXSIZE)<br class="calibre7" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newBaddie = {'rect': pygame.Rect(random.randint(0,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINDOWWIDTH - baddieSize), 0 - baddieSize,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieSize, baddieSize),<br class="calibre7" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'speed': random.randint(BADDIEMINSPEED,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BADDIEMAXSPEED),<br class="calibre7" />135.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'surface':pygame.transform.scale(baddieImage,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(baddieSize, baddieSize)),<br class="calibre7" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br class="calibre7" />137.<br class="calibre7" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies.append(newBaddie)<br class="calibre7" />139.<br class="calibre7" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the player around.<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveLeft and playerRect.left &gt; 0:<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(-1 * PLAYERMOVERATE, 0)<br class="calibre7" />143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveRight and playerRect.right &lt; WINDOWWIDTH:<br class="calibre7" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(PLAYERMOVERATE, 0)<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveUp and playerRect.top &gt; 0:<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(0, -1 * PLAYERMOVERATE)<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveDown and playerRect.bottom &lt; WINDOWHEIGHT:<br class="calibre7" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(0, PLAYERMOVERATE)<br class="calibre7" />149.<br class="calibre7" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the baddies down.<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not reverseCheat and not slowCheat:<br class="calibre7" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, b['speed'])<br class="calibre7" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif reverseCheat:<br class="calibre7" />155.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, -5)<br class="calibre7" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif slowCheat:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, 1)<br class="calibre7" />158.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-283"></span>159.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Delete baddies that have fallen past the bottom.<br class="calibre7" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies[:]:<br class="calibre7" />161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].top &gt; WINDOWHEIGHT:<br class="calibre7" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies.remove(b)<br class="calibre7" />163.<br class="calibre7" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the game world on the window.<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.fill(BACKGROUNDCOLOR)<br class="calibre7" />166.<br class="calibre7" />167.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the score and top score.<br class="calibre7" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Score: %s' % (score), font, windowSurface, 10, 0)<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Top Score: %s' % (topScore), font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10, 40)<br class="calibre7" />170.<br class="calibre7" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the player's rectangle.<br class="calibre7" />172.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.blit(playerImage, playerRect)<br class="calibre7" />173.<br class="calibre7" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw each baddie.<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.blit(b['surface'], b['rect'])<br class="calibre7" />177.<br class="calibre7" />178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()<br class="calibre7" />179.<br class="calibre7" />180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check if any of the baddies have hit the player.<br class="calibre7" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerHasHitBaddie(playerRect, baddies):<br class="calibre7" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if score &gt; topScore:<br class="calibre7" />183.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topScore = score # Set new top score.<br class="calibre7" />184.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />185.<br class="calibre7" />186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainClock.tick(FPS)<br class="calibre7" />187.<br class="calibre7" />188.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stop the game and show the "Game Over" screen.<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.mixer.music.stop()<br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameOverSound.play()<br class="calibre7" />191.<br class="calibre7" />192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('GAME OVER', font, windowSurface, (WINDOWWIDTH / 3),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWHEIGHT / 3))<br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Press a key to play again.', font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWWIDTH / 3) - 80, (WINDOWHEIGHT / 3) + 50)<br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()<br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForPlayerToPressKey()<br class="calibre7" />196.<br class="calibre7" />197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameOverSound.stop()</p>
<h3 class="h2" id="calibre_link-769"><strong class="calibre2">Importing the Modules</strong></h3>
<p class="noindent">The Dodger game imports the same modules as did the previous <span class="literal1">pygame</span> programs: <span class="literal1">pygame</span>, <span class="literal1">random</span>, <span class="literal1">sys</span>, and <span class="literal1">pygame.locals</span>.</p>
<p class="programs">1. import pygame, random, sys<br class="calibre7" />2. from pygame.locals import *</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-280"></span>The <span class="literal1">pygame.locals</span> module contains several constant variables that <span class="literal1">pygame</span> uses, such as the event types (<span class="literal1">QUIT</span>, <span class="literal1">KEYDOWN</span>, and so on) and keyboard keys (<span class="literal1">K_ESCAPE</span>, <span class="literal1">K_LEFT</span>, and so on). By using the <span class="literal1">from pygame.locals import *</span> syntax, you can just use <span class="literal1">QUIT</span> in the source code instead of <span class="literal1">pygame.locals.QUIT</span>.</p>
<h3 class="h2" id="calibre_link-770"><strong class="calibre2">Setting Up the Constant Variables</strong></h3>
<p class="noindent">Lines 4 to 7 set up constants for the window dimensions, the text color, and the background color:</p>
<p class="programs">4. WINDOWWIDTH = 600<br class="calibre7" />5. WINDOWHEIGHT = 600<br class="calibre7" />6. TEXTCOLOR = (0, 0, 0)<br class="calibre7" />7. BACKGROUNDCOLOR = (255, 255, 255)</p>
<p class="indent">We use constant variables because they are much more descriptive than if we had typed out the values. For example, the line <span class="literal1">windowSurface.fill(BACKGROUNDCOLOR)</span> is more understandable than <span class="literal1">windowSurface.fill((255, 255, 255))</span>.</p>
<p class="indent">You can easily change the game by changing the constant variables. By changing <span class="literal1">WINDOWWIDTH</span> on line 4, you automatically change the code everywhere <span class="literal1">WINDOWWIDTH</span> is used. If you had used the value <span class="literal1">600</span> instead, you would have to change each occurrence of <span class="literal1">600</span> in the code. It’s easier to change the value in the constant once.</p>
<p class="indent">On line 8, you set the constant for the <span class="literal1">FPS</span>, the number of frames per second you want the game to run:</p>
<p class="programs">8. FPS = 60</p>
<p class="indent">A <em class="calibre6">frame</em> is a screen that’s drawn for a single iteration through the game loop. You pass <span class="literal1">FPS</span> to the <span class="literal1">mainClock.tick()</span> method on line 186 so that the function knows how long to pause the program. Here <span class="literal1">FPS</span> is set to <span class="literal1">60</span>, but you can change <span class="literal1">FPS</span> to a higher value to have the game run faster or to a lower value to slow it down.</p>
<p class="indent">Lines 9 to 13 set some more constant variables for the falling baddies:</p>
<p class="programs">&nbsp;9. BADDIEMINSIZE = 10<br class="calibre7" />10. BADDIEMAXSIZE = 40<br class="calibre7" />11. BADDIEMINSPEED = 1<br class="calibre7" />12. BADDIEMAXSPEED = 8<br class="calibre7" />13. ADDNEWBADDIERATE = 6</p>
<p class="indent">The width and height of the baddies will be between <span class="literal1">BADDIEMINSIZE</span> and <span class="literal1">BADDIEMAXSIZE</span>. The rate at which the baddies fall down the screen will be between <span class="literal1">BADDIEMINSPEED</span> and <span class="literal1">BADDIEMAXSPEED</span> pixels per iteration through the game loop. And a new baddie will be added to the top of the window every <span class="literal1">ADDNEWBADDIERATE</span> iterations through the game loop.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-281"></span>Finally, the <span class="literal1">PLAYERMOVERATE</span> stores the number of pixels the player’s character moves in the window on each iteration through the game loop (if the character is moving):</p>
<p class="programs">14. PLAYERMOVERATE = 5</p>
<p class="indent">By increasing this number, you can increase the speed at which the character moves.</p>
<h3 class="h2" id="calibre_link-771"><strong class="calibre2">Defining Functions</strong></h3>
<p class="noindent">There are several functions you’ll create for this game. The <span class="literal1">terminate()</span> and <span class="literal1">waitForPlayerToPressKey()</span> functions will end and pause the game, respectively, the <span class="literal1">playerHasHitBaddie()</span> function will track the player’s collisions with baddies, and the <span class="literal1">drawText()</span> function will draw the score and other text to the screen.</p>
<h4 class="h3" id="calibre_link-772"><em class="calibre10"><strong class="calibre2">Ending and Pausing the Game</strong></em></h4>
<p class="noindenta">The <span class="literal1">pygame</span> module requires that you call both <span class="literal1">pygame.quit()</span> and <span class="literal1">sys.exit()</span> to end the game. Lines 16 to 18 put them both into a function called <span class="literal1">terminate()</span>.</p>
<p class="programs">16. def terminate():<br class="calibre7" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.quit()<br class="calibre7" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys.exit()</p>
<p class="indent">Now you only need to call <span class="literal1">terminate()</span> instead of both <span class="literal1">pygame.quit()</span> and <span class="literal1">sys.exit()</span>.</p>
<p class="indent">Sometimes you’ll want to pause the program until the player presses a key, such as at the very start of the game when the <em class="calibre6">Dodger</em> title text appears or at the end when <em class="calibre6">Game Over</em> shows. Lines 20 to 24 create a new function called <span class="literal1">waitForPlayerToPressKey()</span>:</p>
<p class="programs">20. def waitForPlayerToPressKey():<br class="calibre7" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True:<br class="calibre7" />22.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()</p>
<p class="indent">Inside this function, there’s an infinite loop that breaks only when a <span class="literal1">KEYDOWN</span> or <span class="literal1">QUIT</span> event is received. At the start of the loop, <span class="literal1">pygame.event.get()</span> returns a list of <span class="literal1">Event</span> objects to check out.</p>
<p class="indent">If the player has closed the window while the program is waiting for the player to press a key, <span class="literal1">pygame</span> will generate a <span class="literal1">QUIT</span> event, which you check for in line 23 with <span class="literal1">event.type</span>. If the player has quit, Python calls the <span class="literal1">terminate()</span> function on line 24.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-246"></span>If the game receives a <span class="literal1">KEYDOWN</span> event, it should first check whether <small class="calibre11">ESC</small> was pressed:</p>
<p class="programs">25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYDOWN:<br class="calibre7" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_ESCAPE: # Pressing ESC quits.<br class="calibre7" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()<br class="calibre7" />28.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</p>
<p class="indent">If the player pressed <small class="calibre11">ESC</small>, the program should terminate. If that wasn’t the case, then execution will skip the <span class="literal1">if</span> block on line 27 and go straight to the <span class="literal1">return</span> statement, which exits the <span class="literal1">waitForPlayerToPressKey()</span> function.</p>
<p class="indent">If a <span class="literal1">QUIT</span> or <span class="literal1">KEYDOWN</span> event isn’t generated, the code keeps looping. Since the loop does nothing, this will make it look like the game has frozen until the player presses a key.</p>
<h4 class="h3" id="calibre_link-773"><em class="calibre10"><strong class="calibre2">Keeping Track of Baddie Collisions</strong></em></h4>
<p class="noindenta">The <span class="literal1">playerHasHitBaddie()</span> function will return <span class="literal1">True</span> if the player’s character has collided with one of the baddies:</p>
<p class="programs">30. def playerHasHitBaddie(playerRect, baddies):<br class="calibre7" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerRect.colliderect(b['rect']):<br class="calibre7" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre7" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False</p>
<p class="indent">The <span class="literal1">baddies</span> parameter is a list of baddie dictionary data structures. Each of these dictionaries has a <span class="literal1">'rect'</span> key, and the value for that key is a <span class="literal1">Rect</span> object that represents the baddie’s size and location.</p>
<p class="indent"><span class="literal1">playerRect</span> is also a <span class="literal1">Rect</span> object. <span class="literal1">Rect</span> objects have a method named <span class="literal1">colliderect()</span> that returns <span class="literal1">True</span> if the <span class="literal1">Rect</span> object has collided with the <span class="literal1">Rect</span> object that is passed to it. Otherwise, <span class="literal1">colliderect()</span> returns <span class="literal1">False</span>.</p>
<p class="indent">The <span class="literal1">for</span> loop on line 31 iterates through each baddie dictionary in the <span class="literal1">baddies</span> list. If any of these baddies collides with the player’s character, then <span class="literal1">playerHasHitBaddie()</span> returns <span class="literal1">True</span>. If the code manages to iterate through all the baddies in the <span class="literal1">baddies</span> list without detecting a collision, <span class="literal1">playerHasHitBaddie()</span> returns <span class="literal1">False</span>.</p>
<h4 class="h3" id="calibre_link-774"><em class="calibre10"><strong class="calibre2">Drawing Text to the Window</strong></em></h4>
<p class="noindenta">Drawing text on the window involves a few steps, which we accomplish with <span class="literal1">drawText()</span>. This way, there’s only one function to call when we want to display the player’s score or the <em class="calibre6">Game Over</em> text on the screen.</p>
<p class="programs">36. def drawText(text, font, surface, x, y):<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textobj = font.render(text, 1, TEXTCOLOR)<br class="calibre7" />38.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textrect = textobj.get_rect()<br class="calibre7" />39.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;textrect.topleft = (x, y)<br class="calibre7" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;surface.blit(textobj, textrect)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-311"></span>First, the <span class="literal1">render()</span> method call on line 37 creates a <span class="literal1">Surface</span> object that renders the text in a specific font.</p>
<p class="indent">Next, you need to know the size and location of the <span class="literal1">Surface</span> object. You can get a <span class="literal1">Rect</span> object with this information using the <span class="literal1">get_rect() Surface</span> method.</p>
<p class="indent">The <span class="literal1">Rect</span> object returned from <span class="literal1">get_rect()</span> on line 38 has a copy of the width and height information from the <span class="literal1">Surface</span> object. Line 39 changes the location of the <span class="literal1">Rect</span> object by setting a new tuple value for its <span class="literal1">topleft</span> attribute.</p>
<p class="indent">Finally, line 40 draws the <span class="literal1">Surface</span> object of the rendered text onto the <span class="literal1">Surface</span> object that was passed to the <span class="literal1">drawText()</span> function. Displaying text in <span class="literal1">pygame</span> takes a few more steps than simply calling the <span class="literal1">print()</span> function. But if you put this code into a single function named <span class="literal1">drawText()</span>, then you only need to call this function to display text on the screen.</p>
<h3 class="h2" id="calibre_link-775"><strong class="calibre2">Initializing pygame and Setting Up the Window</strong></h3>
<p class="noindent">Now that the constant variables and functions are finished, we’ll start calling the <span class="literal1">pygame</span> functions that set up the window and clock:</p>
<p class="programs">42. # Set up pygame, the window, and the mouse cursor.<br class="calibre7" />43. pygame.init()<br class="calibre7" />44. mainClock = pygame.time.Clock()</p>
<p class="indent">Line 43 sets up <span class="literal1">pygame</span> by calling the <span class="literal1">pygame.init()</span> function. Line 44 creates a <span class="literal1">pygame.time.Clock()</span> object and stores it in the <span class="literal1">mainClock</span> variable. This object will help us keep the program from running too fast.</p>
<p class="indent">Line 45 creates a new <span class="literal1">Surface</span> object that is used for the window display:</p>
<p class="programs">45. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))</p>
<p class="indent">Notice that there’s only one argument passed to <span class="literal1">pygame.display.set_mode()</span>: a tuple. The arguments for <span class="literal1">pygame.display.set_mode()</span> are not two integers but one tuple of two integers. You can specify the width and height of this <span class="literal1">Surface</span> object (and the window) by passing a tuple with the <span class="literal1">WINDOWWIDTH</span> and <span class="literal1">WINDOWHEIGHT</span> constant variables.</p>
<p class="indent">The <span class="literal1">pygame.display.set_mode()</span> function has a second, optional parameter. You can pass the <span class="literal1">pygame.FULLSCREEN</span> constant to make the window fill the entire screen. Look at this modification to line 45:</p>
<p class="programs">45. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.FULLSCREEN)</p>
<p class="indent">The parameters <span class="literal1">WINDOWWIDTH</span> and <span class="literal1">WINDOWHEIGHT</span> are still passed for the window’s width and height, but the image will be stretched larger to fit the screen. Try running the program with and without fullscreen mode.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-198"></span>Line 46 sets the caption of the window to the string <span class="literal1">'Dodger'</span>:</p>
<p class="programs">46. pygame.display.set_caption('Dodger')</p>
<p class="indent">This caption will appear in the title bar at the top of the window.</p>
<p class="indent">In Dodger, the mouse cursor shouldn’t be visible. You want the mouse to be able to move the player’s character around the screen, but the mouse cursor would get in the way of the character’s image. We can make the mouse invisible with just one line of code:</p>
<p class="programs">47. pygame.mouse.set_visible(False)</p>
<p class="indent">Calling <span class="literal1">pygame.mouse.set_visible(False)</span> tells <span class="literal1">pygame</span> to make the cursor invisible.</p>
<h3 class="h2" id="calibre_link-776"><strong class="calibre2">Setting Up Font, Sound, and Image Objects</strong></h3>
<p class="noindent">Since we are displaying text on the screen in this program, we need to give the <span class="literal1">pygame</span> module a <span class="literal1">Font</span> object to use for the text. Line 50 creates a <span class="literal1">Font</span> object by calling <span class="literal1">pygame.font.SysFont()</span>:</p>
<p class="programs">49. # Set up the fonts.<br class="calibre7" />50. font = pygame.font.SysFont(None, 48)</p>
<p class="indent">Passing <span class="literal1">None</span> uses the default font. Passing <span class="literal1">48</span> gives the font a size of 48 points.</p>
<p class="indent">Next, we’ll create the <span class="literal1">Sound</span> objects and set up the background music:</p>
<p class="programs">52. # Set up sounds.<br class="calibre7" />53. gameOverSound = pygame.mixer.Sound('gameover.wav')<br class="calibre7" />54. pygame.mixer.music.load('background.mid')</p>
<p class="indent">The <span class="literal1">pygame.mixer.Sound()</span> constructor function creates a new <span class="literal1">Sound</span> object and stores a reference to this object in the <span class="literal1">gameOverSound</span> variable. In your own games, you can create as many <span class="literal1">Sound</span> objects as you like, each with a different sound file.</p>
<p class="indent">The <span class="literal1">pygame.mixer.music.load()</span> function loads a sound file to play for the background music. This function doesn’t return any objects, and only one background sound file can be loaded at a time. The background music will play constantly during the game, but <span class="literal1">Sound</span> objects will play only when the player loses the game by running into a baddie.</p>
<p class="indent">You can use any WAV or MIDI file for this game. Some sound files are available from this book’s website at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython/" class="calibre4">https://www.nostarch.com/inventwithpython/</a></em>. You can also use your own sound files for this game, as long as you name the files <em class="calibre6">gameover.wav</em> and <em class="calibre6">background.mid</em> or change the strings used on lines 53 and 54 to match the filename you want.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-940"></span>Next you’ll load the image files to be used for the player’s character and the baddies:</p>
<p class="programs">56. # Set up images.<br class="calibre7" />57. playerImage = pygame.image.load('player.png')<br class="calibre7" />58. playerRect = playerImage.get_rect()<br class="calibre7" />59. baddieImage = pygame.image.load('baddie.png')</p>
<p class="indent">The image for the character is stored in <em class="calibre6">player.png</em>, and the image for the baddies is stored in <em class="calibre6">baddie.png</em>. All the baddies look the same, so you need only one image file for them. You can download these images from this book’s website at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython/" class="calibre4">https://www.nostarch.com/inventwithpython/</a></em>.</p>
<h3 class="h2" id="calibre_link-777"><strong class="calibre2">Displaying the Start Screen</strong></h3>
<p class="noindent">When the game first starts, Python should display the Dodger title on the screen. You also want to tell the player that they can start the game by pushing any key. This screen appears so that the player has time to get ready to start playing after running the program.</p>
<p class="indent">On lines 63 and 64, we write code to call the <span class="literal1">drawText()</span> function:</p>
<p class="programs">61. # Show the "Start" screen.<br class="calibre7" />62. windowSurface.fill(BACKGROUNDCOLOR)<br class="calibre7" />63. drawText('Dodger', font, windowSurface, (WINDOWWIDTH / 3),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWHEIGHT / 3))<br class="calibre7" />64. drawText('Press a key to start.', font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWWIDTH / 3) - 30, (WINDOWHEIGHT / 3) + 50)<br class="calibre7" />65. pygame.display.update()<br class="calibre7" />66. waitForPlayerToPressKey()</p>
<p class="indent">We pass this function five arguments:</p>
<ol class="calibre12">
<li value="1" class="calibre13"><p class="noindenta">The string of the text you want to appear</p></li>
<li value="2" class="calibre13"><p class="noindenta">The font in which you want the string to appear</p></li>
<li value="3" class="calibre13"><p class="noindenta">The <span class="literal1">Surface</span> object onto which the text will be rendered</p></li>
<li value="4" class="calibre13"><p class="noindenta">The x-coordinate on the <span class="literal1">Surface</span> object at which to draw the text</p></li>
<li value="5" class="calibre13"><p class="noindenta">The y-coordinate on the <span class="literal1">Surface</span> object at which to draw the text</p></li>
</ol>
<p class="indent">This may seem like a lot of arguments to pass for a function call, but keep in mind that this function call replaces five lines of code each time you call it. This shortens the program and makes it easier to find bugs since there’s less code to check.</p>
<p class="indent">The <span class="literal1">waitForPlayerToPressKey()</span> function pauses the game by looping until a <span class="literal1">KEYDOWN</span> event is generated. Then the execution breaks out of the loop and the program continues to run.</p>
<h3 class="h2" id="calibre_link-778"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-282" class="calibre1"></span><strong class="calibre2">Starting the Game</strong></h3>
<p class="noindent">With all the functions now defined, we can start writing the main game code. Lines 68 and on will call the functions that we defined earlier. The value in the <span class="literal1">topScore</span> variable starts at <span class="literal1">0</span> when the program first runs. Whenever the player loses and has a score larger than the current top score, the top score is replaced with this larger score.</p>
<p class="programs">68. topScore = 0<br class="calibre7" />69. while True:</p>
<p class="indent">The infinite loop started on line 69 is technically not the game loop. The game loop handles events and drawing the window while the game is running. Instead, this <span class="literal1">while</span> loop iterates each time the player starts a new game. When the player loses and the game resets, the program’s execution loops back to line 69.</p>
<p class="indent">At the beginning, you also want to set <span class="literal1">baddies</span> to an empty list:</p>
<p class="programs">70.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Set up the start of the game.<br class="calibre7" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies = []<br class="calibre7" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0</p>
<p class="indentb">The <span class="literal1">baddies</span> variable is a list of dictionary objects with the following keys:</p>
<p class="hang"><span class="literal1"><span class="codestrong">'rect'</span></span> The <span class="literal1">Rect</span> object that describes where and what size the baddie is.</p>
<p class="hang"><span class="literal1"><span class="codestrong">'speed'</span></span> How fast the baddie falls down the screen. This integer represents pixels per iteration through the game loop.</p>
<p class="hang"><span class="literal1"><span class="codestrong">'surface'</span></span> The <span class="literal1">Surface</span> object that has the scaled baddie image drawn on it. This is the <span class="literal1">Surface</span> that is drawn to the <span class="literal1">Surface</span> object returned by <span class="literal1">pygame.display.set_mode()</span>.</p>
<p class="indentt">Line 72 resets the player’s score to <span class="literal1">0</span>.</p>
<p class="indent">The starting location of the player is in the center of the screen and 50 pixels up from the bottom, which is set by line 73:</p>
<p class="programs">73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.topleft = (WINDOWWIDTH / 2, WINDOWHEIGHT - 50)</p>
<p class="indent">The first item in line 73’s tuple is the x-coordinate of the left edge, and the second item is the y-coordinate of the top edge.</p>
<p class="indent">Next we set up variables for the player movements and the cheats:</p>
<p class="programs">74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveLeft = moveRight = moveUp = moveDown = False<br class="calibre7" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = slowCheat = False<br class="calibre7" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter = 0</p>
<p class="indent">The movement variables <span class="literal1">moveLeft</span>, <span class="literal1">moveRight</span>, <span class="literal1">moveUp</span>, and <span class="literal1">moveDown</span> are set to <span class="literal1">False</span>. The <span class="literal1">reverseCheat</span> and <span class="literal1">slowCheat</span> variables are also set to <span class="literal1">False</span>. They will be set to <span class="literal1">True</span> only when the player enables these cheats by holding down the Z and X keys, respectively.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-199"></span>The <span class="literal1">baddieAddCounter</span> variable is a counter to tell the program when to add a new baddie at the top of the screen. The value in <span class="literal1">baddieAddCounter</span> increments by 1 each time the game loop iterates. (This is similar to the code in “<a href="#calibre_link-140" class="calibre4">Adding New Food Squares</a>” on <a href="#calibre_link-141" class="calibre4">page 295</a>.)</p>
<p class="indent">When <span class="literal1">baddieAddCounter</span> is equal to <span class="literal1">ADDNEWBADDIERATE</span>, then <span class="literal1">baddieAddCounter</span> resets to <span class="literal1">0</span> and a new baddie is added to the top of the screen. (This check is done later on line 130.)</p>
<p class="indent">The background music starts playing on line 77 with a call to the <span class="literal1">pygame.mixer.music.play()</span> function:</p>
<p class="programs">77.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.mixer.music.play(-1, 0.0)</p>
<p class="indent">Because the first argument is <span class="literal1">-1</span>, <span class="literal1">pygame</span> repeats the music endlessly. The second argument is a float that says how many seconds into the music you want it to start playing. Passing <span class="literal1">0.0</span> means the music starts playing from the beginning.</p>
<h3 class="h2" id="calibre_link-779"><strong class="calibre2">The Game Loop</strong></h3>
<p class="noindent">The game loop’s code constantly updates the state of the game world by changing the position of the player and baddies, handling events generated by <span class="literal1">pygame</span>, and drawing the game world on the screen. All of this happens several dozen times a second, which makes the game run in real time.</p>
<p class="indent">Line 79 is the start of the main game loop:</p>
<p class="programs">79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while True: # The game loop runs while the game part is playing.<br class="calibre7" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score += 1 # Increase score.</p>
<p class="indent">Line 80 increases the player’s score on each iteration of the game loop. The longer the player can go without losing, the higher their score. The loop will exit only when the player either loses the game or quits the program.</p>
<h4 class="h3" id="calibre_link-780"><em class="calibre10"><strong class="calibre2">Handling Keyboard Events</strong></em></h4>
<p class="noindenta">There are four types of events the program will handle: <span class="literal1">QUIT</span>, <span class="literal1">KEYDOWN</span>, <span class="literal1">KEYUP</span>, and <span class="literal1">MOUSEMOTION</span>.</p>
<p class="indent">Line 82 is the start of the event-handling code:</p>
<p class="programs">82.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for event in pygame.event.get():<br class="calibre7" />83.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == QUIT:<br class="calibre7" />84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()</p>
<p class="indent">It calls <span class="literal1">pygame.event.get()</span>, which returns a list of <span class="literal1">Event</span> objects. Each <span class="literal1">Event</span> object represents an event that has happened since the last call to <span class="literal1">pygame.event.get()</span>. The code checks the <span class="literal1">type</span> attribute of the <span class="literal1">Event</span> object to see what type of event it is, and then handles it accordingly.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-299"></span>If the <span class="literal1">type</span> attribute of the <span class="literal1">Event</span> object is equal to <span class="literal1">QUIT</span>, then the user has closed the program. The <span class="literal1">QUIT</span> constant variable was imported from the <span class="literal1">pygame.locals</span> module.</p>
<p class="indent">If the event’s type is <span class="literal1">KEYDOWN</span>, the player has pressed a key:</p>
<p class="programs">86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYDOWN:<br class="calibre7" />87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_z:<br class="calibre7" />88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = True<br class="calibre7" />89.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_x:<br class="calibre7" />90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowCheat = True</p>
<p class="indent">Line 87 checks whether the event describes the Z key being pressed with <span class="literal1">event.key == K_z</span>. If this condition is <span class="literal1">True</span>, Python sets the <span class="literal1">reverseCheat</span> variable to <span class="literal1">True</span> to activate the reverse cheat. Similarly, line 89 checks whether the X key has been pressed to activate the slow cheat.</p>
<p class="indent">Lines 91 to 102 check whether the event was generated by the player pressing one of the arrow or WASD keys. This code is similar to the keyboard-related code in the previous chapters.</p>
<p class="indent">If the event’s type is <span class="literal1">KEYUP</span>, the player has released a key:</p>
<p class="programs">104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == KEYUP:<br class="calibre7" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_z:<br class="calibre7" />106.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverseCheat = False<br class="calibre7" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0<br class="calibre7" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_x:<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slowCheat = False<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score = 0</p>
<p class="indent">Line 105 checks whether the player has released the Z key, which will deactivate the reverse cheat. In that case, line 106 sets <span class="literal1">reverseCheat</span> to <span class="literal1">False</span>, and line 107 resets the score to <span class="literal1">0</span>. The score reset is to discourage the player from using the cheats.</p>
<p class="indent">Lines 108 to 110 do the same thing for the X key and the slow cheat. When the X key is released, <span class="literal1">slowCheat</span> is set to <span class="literal1">False</span>, and the player’s score is reset to <span class="literal1">0</span>.</p>
<p class="indent">At any time during the game, the player can press <small class="calibre11">ESC</small> to quit:</p>
<p class="programs">111.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.key == K_ESCAPE:<br class="calibre7" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminate()</p>
<p class="indent">Line 111 determines whether the key that was released was <small class="calibre11">ESC</small> by checking <span class="literal1">event.key == K_ESCAPE</span>. If so, line 112 calls the <span class="literal1">terminate()</span> function to exit the program.</p>
<p class="indent">Lines 114 to 121 check whether the player has stopped holding down one of the arrow or WASD keys. In that case, the code sets the corresponding movement variable to <span class="literal1">False</span>. This is similar to the movement code in <a href="#calibre_link-97" class="calibre4">Chapter 19</a>’s and <a href="#calibre_link-98" class="calibre4">Chapter 20</a>’s programs.</p>
<h4 class="h3" id="calibre_link-781"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-275" class="calibre1"></span><em class="calibre10"><strong class="calibre2">Handling Mouse Movement</strong></em></h4>
<p class="noindenta">Now that you’ve handled the keyboard events, let’s handle any mouse events that may have been generated. The Dodger game doesn’t do anything if the player has clicked a mouse button, but it does respond when the player moves the mouse. This gives the player two ways of controlling the character in the game: the keyboard or the mouse.</p>
<p class="indent">The <span class="literal1">MOUSEMOTION</span> event is generated whenever the mouse is moved:</p>
<p class="programs">123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if event.type == MOUSEMOTION:<br class="calibre7" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# If the mouse moves, move the player to the cursor.<br class="calibre7" />125.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.centerx = event.pos[0]<br class="calibre7" />126.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.centery = event.pos[1]</p>
<p class="indent"><span class="literal1">Event</span> objects with a <span class="literal1">type</span> set to <span class="literal1">MOUSEMOTION</span> also have an attribute named <span class="literal1">pos</span> for the position of the mouse event. The <span class="literal1">pos</span> attribute stores a tuple of the x- and y-coordinates of where the mouse cursor moved in the window. If the event’s type is <span class="literal1">MOUSEMOTION</span>, the player’s character moves to the position of the mouse cursor.</p>
<p class="indent">Lines 125 and 126 set the center x- and y-coordinate of the player’s character to the x- and y-coordinates of the mouse cursor.</p>
<h3 class="h2" id="calibre_link-782"><strong class="calibre2">Adding New Baddies</strong></h3>
<p class="noindent">On each iteration of the game loop, the code increments the <span class="literal1">baddieAddCounter</span> variable by one:</p>
<p class="programs">127.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Add new baddies at the top of the screen, if needed.<br class="calibre7" />128.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not reverseCheat and not slowCheat:<br class="calibre7" />129.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter += 1</p>
<p class="indent">This happens only if the cheats are not enabled. Remember that <span class="literal1">reverseCheat</span> and <span class="literal1">slowCheat</span> are set to <span class="literal1">True</span> as long as the Z and X keys are being held down, respectively. While the Z and X keys are being held down, <span class="literal1">baddieAddCounter</span> isn’t incremented. Therefore, no new baddies will appear at the top of the screen.</p>
<p class="indent">When the <span class="literal1">baddieAddCounter</span> reaches the value in <span class="literal1">ADDNEWBADDIERATE</span>, it’s time to add a new baddie to the top of the screen. First, <span class="literal1">baddieAddCounter</span> is reset to <span class="literal1">0</span>:</p>
<p class="programs">130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if baddieAddCounter == ADDNEWBADDIERATE:<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieAddCounter = 0<br class="calibre7" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieSize = random.randint(BADDIEMINSIZE, BADDIEMAXSIZE)<br class="calibre7" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newBaddie = {'rect': pygame.Rect(random.randint(0,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WINDOWWIDTH - baddieSize), 0 - baddieSize,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddieSize, baddieSize),<br class="calibre7" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'speed': random.randint(BADDIEMINSPEED,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BADDIEMAXSPEED),<br class="calibre7" />135.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'surface':pygame.transform.scale(baddieImage,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(baddieSize, baddieSize)),<br class="calibre7" />136.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-276"></span>Line 132 generates a size for the baddie in pixels. The size will be a random integer between <span class="literal1">BADDIEMINSIZE</span> and <span class="literal1">BADDIEMAXSIZE</span>, which are constants set to <span class="literal1">10</span> and <span class="literal1">40</span> on lines 9 and 10, respectively.</p>
<p class="indent">Line 133 is where a new baddie data structure is created. Remember, the data structure for <span class="literal1">baddies</span> is simply a dictionary with keys <span class="literal1">'rect'</span>, <span class="literal1">'speed'</span>, and <span class="literal1">'surface'</span>. The <span class="literal1">'rect'</span> key holds a reference to a <span class="literal1">Rect</span> object that stores the location and size of the baddie. The call to the <span class="literal1">pygame.Rect()</span> constructor function has four parameters: the x-coordinate of the top edge of the area, the y-coordinate of the left edge of the area, the width in pixels, and the height in pixels.</p>
<p class="indent">The baddie needs to appear at a random point along the top of the window, so pass <span class="literal1">random.randint(0, WINDOWWIDTH - baddieSize)</span> for the x-coordinate of the left edge of the baddie. The reason you pass <span class="literal1">WINDOWWIDTH - baddieSize</span> instead of <span class="literal1">WINDOWWIDTH</span> is that if the left edge of the baddie is too far to the right, then part of the baddie will be off the edge of the window and not visible onscreen.</p>
<p class="indent">The bottom edge of the baddie should be just above the top edge of the window. The y-coordinate of the top edge of the window is <span class="literal1">0</span>. To put the baddie’s bottom edge there, set the top edge to <span class="literal1">0 - baddieSize</span>.</p>
<p class="indent">The baddie’s width and height should be the same (the image is a square), so pass <span class="literal1">baddieSize</span> for the third and fourth arguments.</p>
<p class="indent">The speed at which the baddie moves down the screen is set in the <span class="literal1">'speed'</span> key. Set it to a random integer between <span class="literal1">BADDIEMINSPEED</span> and <span class="literal1">BADDIEMAXSPEED</span>.</p>
<p class="indent">Line 138 will then add the newly created baddie data structure to the list of baddie data structures:</p>
<p class="programs">138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies.append(newBaddie)</p>
<p class="indent">The program uses this list to check whether the player has collided with any of the baddies and to determine where to draw baddies on the window.</p>
<h3 class="h2" id="calibre_link-783"><strong class="calibre2">Moving the Player’s Character and the Baddies</strong></h3>
<p class="noindent">The four movement variables <span class="literal1">moveLeft</span>, <span class="literal1">moveRight</span>, <span class="literal1">moveUp</span>, and <span class="literal1">moveDown</span> are set to <span class="literal1">True</span> and <span class="literal1">False</span> when <span class="literal1">pygame</span> generates the <span class="literal1">KEYDOWN</span> and <span class="literal1">KEYUP</span> events, respectively.</p>
<p class="indent">If the player’s character is moving left and the left edge of the player’s character is greater than <span class="literal1">0</span> (which is the left edge of the window), then <span class="literal1">playerRect</span> should move to the left:</p>
<p class="programs">140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the player around.<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveLeft and playerRect.left &gt; 0:<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(-1 * PLAYERMOVERATE, 0)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-278"></span>The <span class="literal1">move_ip()</span> method will move the location of the <span class="literal1">Rect</span> object horizontally or vertically by a number of pixels. The first argument to <span class="literal1">move_ip()</span> is how many pixels to move the <span class="literal1">Rect</span> object to the right (to move it to the left, pass a negative integer). The second argument is how many pixels to move the <span class="literal1">Rect</span> object down (to move it up, pass a negative integer). For example, <span class="literal1">playerRect.move_ip(10, 20)</span> would move the <span class="literal1">Rect</span> object 10 pixels to the right and 20 pixels down and <span class="literal1">playerRect.move_ip(-5, -15)</span> would move the <span class="literal1">Rect</span> object 5 pixels to the left and 15 pixels up.</p>
<p class="indent">The <em class="calibre6">ip</em> at the end of <span class="literal1">move_ip()</span> stands for “in place.” This is because the method changes the <span class="literal1">Rect</span> object itself, rather than returning a new <span class="literal1">Rect</span> object with the changes. There is also a <span class="literal1">move()</span> method, which doesn’t change the <span class="literal1">Rect</span> object but instead creates and returns a new <span class="literal1">Rect</span> object in the new location.</p>
<p class="indent">You’ll always move the <span class="literal1">playerRect</span> object by the number of pixels in <span class="literal1">PLAYERMOVERATE</span>. To get the negative form of an integer, multiply it by <span class="literal1">-1</span>. On line 142, since <span class="literal1">5</span> is stored in <span class="literal1">PLAYERMOVERATE</span>, the expression <span class="literal1">-1 * PLAYERMOVERATE</span> evaluates to <span class="literal1">-5</span>. Therefore, calling <span class="literal1">playerRect.move_ip(-1 * PLAYERMOVERATE, 0)</span> will change the location of <span class="literal1">playerRect</span> by 5 pixels to the left of its current location.</p>
<p class="indent">Lines 143 to 148 do the same thing for the other three directions: right, up, and down.</p>
<p class="programs">143.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveRight and playerRect.right &lt; WINDOWWIDTH:<br class="calibre7" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(PLAYERMOVERATE, 0)<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveUp and playerRect.top &gt; 0:<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(0, -1 * PLAYERMOVERATE)<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if moveDown and playerRect.bottom &lt; WINDOWHEIGHT:<br class="calibre7" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerRect.move_ip(0, PLAYERMOVERATE)</p>
<p class="indent">Each of the three <span class="literal1">if</span> statements in lines 143 to 148 checks that its movement variable is set to <span class="literal1">True</span> and that the edge of the <span class="literal1">Rect</span> object of the player is inside the window. Then it calls <span class="literal1">move_ip()</span> to move the <span class="literal1">Rect</span> object.</p>
<p class="indent">Now the code loops through each baddie data structure in the <span class="literal1">baddies</span> list to move them down a little:</p>
<p class="programs">150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move the baddies down.<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not reverseCheat and not slowCheat:<br class="calibre7" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, b['speed'])</p>
<p class="indent">If neither of the cheats has been activated, then the baddie’s location moves down a number of pixels equal to its speed (stored in the <span class="literal1">'speed'</span> key).</p>
<h3 class="h2" id="calibre_link-784"><strong class="calibre2">Implementing the Cheat Codes</strong></h3>
<p class="noindent">If the reverse cheat is activated, then the baddie should move up by 5 pixels:</p>
<p class="programs">154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif reverseCheat:<br class="calibre7" />155.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, -5)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-277"></span>Passing <span class="literal1">-5</span> for the second argument to <span class="literal1">move_ip()</span> will move the <span class="literal1">Rect</span> object upward by 5 pixels.</p>
<p class="indent">If the slow cheat has been activated, then the baddie should still move downward, but at the slow speed of 1 pixel per iteration through the game loop:</p>
<p class="programs">156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif slowCheat:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b['rect'].move_ip(0, 1)</p>
<p class="indent">The baddie’s normal speed (again, this is stored in the <span class="literal1">'speed'</span> key of the baddie’s data structure) is ignored when the slow cheat is activated.</p>
<h3 class="h2" id="calibre_link-785"><strong class="calibre2">Removing the Baddies</strong></h3>
<p class="noindent">Any baddies that fall below the bottom edge of the window should be removed from the <span class="literal1">baddies</span> list. Remember that you shouldn’t add or remove list items while also iterating through the list. Instead of iterating through the <span class="literal1">baddies</span> list with the <span class="literal1">for</span> loop, iterate through a <em class="calibre6">copy</em> of the <span class="literal1">baddies</span> list. To make this copy, use the blank slicing operator <span class="literal1">[:]</span>:</p>
<p class="programs">159.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Delete baddies that have fallen past the bottom.<br class="calibre7" />160.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies[:]:</p>
<p class="indent">The <span class="literal1">for</span> loop on line 160 uses the variable <span class="literal1">b</span> for the current item in the iteration through <span class="literal1">baddies[:]</span>. If the baddie is below the bottom edge of the window, we should remove it, which we do on line 162:</p>
<p class="programs">161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if b['rect'].top &gt; WINDOWHEIGHT:<br class="calibre7" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;baddies.remove(b)</p>
<p class="indent">The <span class="literal1">b</span> dictionary is the current baddie data structure from the <span class="literal1">baddies[:]</span> list. Each baddie data structure in the list is a dictionary with a <span class="literal1">'rect'</span> key, which stores a <span class="literal1">Rect</span> object. So <span class="literal1">b['rect']</span> is the <span class="literal1">Rect</span> object for the baddie. Finally, the <span class="literal1">top</span> attribute is the y-coordinate of the top edge of the rectangular area. Remember that the y-coordinates increase going down. So <span class="literal1">b['rect'].top &gt; WINDOWHEIGHT</span> will check whether the top edge of the baddie is below the bottom of the window. If this condition is <span class="literal1">True</span>, then line 162 removes the baddie data structure from the <span class="literal1">baddies</span> list.</p>
<h3 class="h2" id="calibre_link-786"><strong class="calibre2">Drawing the Window</strong></h3>
<p class="noindent">After all the data structures have been updated, the game world should be drawn using <span class="literal1">pygame</span>’s image functions. Because the game loop is executed several times a second, when the baddies and player are drawn in new positions, they look like they’re moving smoothly.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-211"></span>Before anything else is drawn, line 165 fills the entire screen to erase anything drawn on it previously:</p>
<p class="programs">164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the game world on the window.<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.fill(BACKGROUNDCOLOR)</p>
<p class="indent">Remember that the <span class="literal1">Surface</span> object in <span class="literal1">windowSurface</span> is special because it is the one returned by <span class="literal1">pygame.display.set_mode()</span>. Therefore, anything drawn on that <span class="literal1">Surface</span> object will appear on the screen after <span class="literal1">pygame.display.update()</span> is called.</p>
<h4 class="h3" id="calibre_link-787"><em class="calibre10"><strong class="calibre2">Drawing the Player’s Score</strong></em></h4>
<p class="noindenta">Lines 168 and 169 render the text for the current score and top score to the top-left corner of the window.</p>
<p class="programs">167.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the score and top score.<br class="calibre7" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Score: %s' % (score), font, windowSurface, 10, 0)<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Top Score: %s' % (topScore), font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10, 40)</p>
<p class="indent">The <span class="literal1">'Score: %s' % (score)</span> expression uses string interpolation to insert the value in the <span class="literal1">score</span> variable into the string. This string, the <span class="literal1">Font</span> object stored in the <span class="literal1">font</span> variable, the <span class="literal1">Surface</span> object to draw the text on, and the x- and y-coordinates of where the text should be placed are passed to the <span class="literal1">drawText()</span> method, which will handle the call to the <span class="literal1">render()</span> and <span class="literal1">blit()</span> methods.</p>
<p class="indent">For the top score, do the same thing. Pass <span class="literal1">40</span> for the y-coordinate instead of <span class="literal1">0</span> so that the top score’s text appears beneath the current score’s text.</p>
<h4 class="h3" id="calibre_link-788"><em class="calibre10"><strong class="calibre2">Drawing the Player’s Character and Baddies</strong></em></h4>
<p class="noindenta">Information about the player is kept in two different variables. <span class="literal1">playerImage</span> is a <span class="literal1">Surface</span> object that contains all the colored pixels that make up the player character’s image. <span class="literal1">playerRect</span> is a <span class="literal1">Rect</span> object that stores the size and location of the player’s character.</p>
<p class="indent">The <span class="literal1">blit()</span> method draws the player character’s image (in <span class="literal1">playerImage</span>) on <span class="literal1">windowSurface</span> at the location in <span class="literal1">playerRect</span>:</p>
<p class="programs">171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw the player's rectangle.<br class="calibre7" />172.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.blit(playerImage, playerRect)</p>
<p class="indent">Line 175’s <span class="literal1">for</span> loop draws every baddie on the <span class="literal1">windowSurface</span> object:</p>
<p class="programs">174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Draw each baddie.<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for b in baddies:<br class="calibre7" />176.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;windowSurface.blit(b['surface'], b['rect'])</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-279"></span>Each item in the <span class="literal1">baddies</span> list is a dictionary. The dictionaries’ <span class="literal1">'surface'</span> and <span class="literal1">'rect'</span> keys contain the <span class="literal1">Surface</span> object with the baddie image and the <span class="literal1">Rect</span> object with the position and size information, respectively.</p>
<p class="indent">Now that everything has been drawn to <span class="literal1">windowSurface</span>, we need to update the screen so the player can see what’s there:</p>
<p class="programs">178.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()</p>
<p class="indent">Draw this <span class="literal1">Surface</span> object to the screen by calling <span class="literal1">update()</span>.</p>
<h3 class="h2" id="calibre_link-789"><strong class="calibre2">Checking for Collisions</strong></h3>
<p class="noindent">Line 181 checks whether the player has collided with any baddies by calling <span class="literal1">playerHasHitBaddie()</span>. This function will return <span class="literal1">True</span> if the player’s character has collided with any of the baddies in the <span class="literal1">baddies</span> list. Otherwise, the function returns <span class="literal1">False</span>.</p>
<p class="programs">180.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check if any of the baddies have hit the player.<br class="calibre7" />181.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if playerHasHitBaddie(playerRect, baddies):<br class="calibre7" />182.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if score &gt; topScore:<br class="calibre7" />183.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;topScore = score # Set new top score.<br class="calibre7" />184.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">If the player’s character has hit a baddie and if the current score is higher than the top score, then lines 182 and 183 update the top score. The program’s execution breaks out of the game loop at line 184 and moves to line 189, ending the game.</p>
<p class="indent">To keep the computer from running through the game loop as fast as possible (which would be much too fast for the player to keep up with), call <span class="literal1">mainClock.tick()</span> to pause the game very briefly:</p>
<p class="programs">186.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainClock.tick(FPS)</p>
<p class="indent">This pause will be long enough to ensure that about <span class="literal1">40</span> (the value stored inside the <span class="literal1">FPS</span> variable) iterations through the game loop occur each second.</p>
<h3 class="h2" id="calibre_link-790"><strong class="calibre2">The Game Over Screen</strong></h3>
<p class="noindent">When the player loses, the game stops playing the background music and plays the “game over” sound effect:</p>
<p class="programs">188.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Stop the game and show the "Game Over" screen.<br class="calibre7" />189.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.mixer.music.stop()<br class="calibre7" />190.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameOverSound.play()</p>
<p class="indent">Line 189 calls the <span class="literal1">stop()</span> function in the <span class="literal1">pygame.mixer.music</span> module to stop the background music. Line 190 calls the <span class="literal1">play()</span> method on the <span class="literal1">Sound</span> object stored in <span class="literal1">gameOverSound</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-284"></span>Then lines 192 and 193 call the <span class="literal1">drawText()</span> function to draw the “game over” text to the <span class="literal1">windowSurface</span> object:</p>
<p class="programs">192.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('GAME OVER', font, windowSurface, (WINDOWWIDTH / 3),<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWHEIGHT / 3))<br class="calibre7" />193.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawText('Press a key to play again.', font, windowSurface,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(WINDOWWIDTH / 3) - 80, (WINDOWHEIGHT / 3) + 50)<br class="calibre7" />194.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pygame.display.update()<br class="calibre7" />195.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitForPlayerToPressKey()</p>
<p class="indent">Line 194 calls <span class="literal1">update()</span> to draw this <span class="literal1">Surface</span> object to the screen. After displaying this text, the game stops until the player presses a key by calling the <span class="literal1">waitForPlayerToPressKey()</span> function.</p>
<p class="indent">After the player presses a key, the program execution returns from the <span class="literal1">waitForPlayerToPressKey()</span> call on line 195. Depending on how long the player takes to press a key, the “game over” sound effect may or may not still be playing. To stop this sound effect before a new game starts, line 197 calls <span class="literal1">gameOverSound.stop()</span>:</p>
<p class="programs">197.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameOverSound.stop()</p>
<p class="indent">That’s it for our graphical game!</p>
<h3 class="h2" id="calibre_link-791"><strong class="calibre2">Modifying the Dodger Game</strong></h3>
<p class="noindent">You may find that the game is too easy or too hard. Fortunately, the game is easy to modify because we took the time to use constant variables instead of entering the values directly. Now all we need to do to change the game is modify the values set in the constant variables.</p>
<p class="indent">For example, if you want the game to run slower in general, change the <span class="literal1">FPS</span> variable on line 8 to a smaller value, such as <span class="literal1">20</span>. This will make both the baddies and the player’s character move slower, since the game loop will be executed only <span class="literal1">20</span> times a second instead of <span class="literal1">40</span>.</p>
<p class="indent">If you just want to slow down the baddies and not the player, then change <span class="literal1">BADDIEMAXSPEED</span> to a smaller value, such as <span class="literal1">4</span>. This will make all the baddies move between 1 (the value in <span class="literal1">BADDIEMINSPEED</span>) and 4 pixels per iteration through the game loop, instead of between 1 and 8.</p>
<p class="indent">If you want the game to have fewer but larger baddies instead of many smaller baddies, then increase <span class="literal1">ADDNEWBADDIERATE</span> to <span class="literal1">12</span>, <span class="literal1">BADDIEMINSIZE</span> to <span class="literal1">40</span>, and <span class="literal1">BADDIEMAXSIZE</span> to <span class="literal1">80</span>. Now baddies are being added every 12 iterations through the game loop instead of every 6 iterations, so there will be half as many baddies as before. But to keep the game interesting, the baddies are much larger.</p>
<p class="indent">Keeping the basic game the same, you can modify any of the constant variables to dramatically affect how the game plays. Keep trying out new values for the constant variables until you find the set of values you like best.</p>
<h3 class="h2" id="calibre_link-792"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-941" class="calibre1"></span><strong class="calibre2">Summary</strong></h3>
<p class="noindent">Unlike our text-based games, Dodger really looks like a modern computer game. It has graphics and music and uses the mouse. While <span class="literal1">pygame</span> provides functions and data types as building blocks, it’s you the programmer who puts them together to create fun, interactive games.</p>
<p class="indent">And you can do all of this because you know how to instruct the computer to do it, step by step, line by line. By speaking the computer’s language, you can get it to do the number crunching and drawing for you. This is a useful skill, and I hope you’ll continue to learn more about Python programming. (And there’s still much more to learn!)</p>
<p class="indent">Now get going and invent your own games. Good luck!</p>
</div>


<a href="chapter20.html">Prev: Chapter 20: Using Sounds and Images</a>

</body></html>