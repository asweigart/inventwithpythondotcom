<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>Chapter 10: Tic-Tac-Toe</title></head><body>
<script type="text/javascript">
//<![CDATA[

var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-5459430-3']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

//]]>
</script>


<a href="chapter9.html">Prev: Chapter 9: Extending Hangman</a> | <a href="chapter11.html">Next: Chapter 11: The Bagels Deduction Game</a>


<div id="calibre_link-110" class="calibre">
<h2 class="h1" id="calibre_link-12"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-191" class="calibre1"></span><span class="big"><strong class="calibre2">10</strong></span><br class="calibre9" /><strong class="calibre2">TIC-TAC-TOE</strong></h2>
<div class="imagec"><img src="images/00016.jpeg" alt="image" class="calibre3" /></div>
<p class="noindent">This chapter features a Tic-Tac-Toe game. Tic-Tac-Toe is normally played with two people. One player is <em class="calibre6">X</em> and the other player is <em class="calibre6">O</em>. Players take turns placing their <em class="calibre6">X</em> or <em class="calibre6">O</em>. If a player gets three of their marks on the board in a row, column, or diagonal, they win. When the board fills up with neither player winning, the game ends in a draw.</p>
<p class="indent">This chapter doesn’t introduce many new programming concepts. The user will play against a simple artificial intelligence, which we will write using our existing programming knowledge. An <em class="calibre6">artificial intelligence (AI)</em> is a computer program that can intelligently respond to the player’s moves. The AI that plays Tic-Tac-Toe isn’t complicated; it’s really just a few lines of code.</p>
<p class="indent">Let’s get started by looking at a sample run of the program. The player makes their move by entering the number of the space they want to take. To help us remember which index in the list is for which space, we’ll number the board like a keyboard’s number pad, as shown in <a href="#calibre_link-111" class="calibre4">Figure 10-1</a>.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-394"></span><img src="images/00108.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-111" class="calibre4"></a><em class="calibre6">Figure 10-1: The board is numbered like the keyboard’s number pad.</em></p>
<div class="sidebar">
<p class="sidebart"><strong class="calibre2">TOPICS COVERED IN THIS CHAPTER</strong></p>
<p class="bull">• Artificial intelligence</p>
<p class="bull">• List references</p>
<p class="bull">• Short-circuit evaluation</p>
<p class="bull">• The <span class="literal1">None</span> value</p>
</div>
<h3 class="h2" id="calibre_link-548"><strong class="calibre2">Sample Run of Tic-Tac-Toe</strong></h3>
<p class="noindent">Here’s what the user sees when they run the Tic-Tac-Toe program. The text the player enters is in bold.</p>
<p class="programs">Welcome to Tic-Tac-Toe!<br class="calibre7" />Do you want to be X or O?<br class="calibre7" /><span class="codestrong">X</span><br class="calibre7" />The computer will go first.<br class="calibre7" />O| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |<br class="calibre7" />What is your next move? (1-9)<br class="calibre7" /><span class="codestrong">3</span><br class="calibre7" />O| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |<br class="calibre7" />-+-+-<br class="calibre7" />O| |X<br class="calibre7" /><br class="calibre7" />What is your next move? (1-9)<br class="calibre7" /><span class="codestrong">4</span><br class="calibre7" />O| |O<br class="calibre7" />-+-+-<br class="calibre7" />X| |<br class="calibre7" />-+-+-<br class="calibre7" />O| |X<br class="calibre7" />What is your next move? (1-9)<br class="calibre7" /><span class="codestrong">5</span><br class="calibre7" />O|O|O<br class="calibre7" />-+-+-<br class="calibre7" />X|X|<br class="calibre7" />-+-+-<br class="calibre7" />O| |X<br class="calibre7" />The computer has beaten you! You lose.<br class="calibre7" />Do you want to play again? (yes or no)<br class="calibre7" /><span class="codestrong">no</span></p>
<h3 class="h2" id="calibre_link-549"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-377" class="calibre1"></span><strong class="calibre2">Source Code for Tic-Tac-Toe</strong></h3>
<p class="noindent">In a new file, enter the following source code and save it as <em class="calibre6">tictactoe.py</em>. Then run the game by pressing F5. If you get errors, compare the code you typed to the book’s code with the online diff tool at <em class="calibre6"><a href="https://www.nostarch.com/inventwithpython#diff" class="calibre4">https://www.nostarch.com/inventwithpython#diff</a></em>.</p>
<div class="image"><img src="images/00020.jpeg" alt="image" class="calibre3" /></div>
<p class="sidenote"><em class="calibre6">tictactoe.py</em></p>
<p class="programs">&nbsp;&nbsp;1. # Tic-Tac-Toe<br class="calibre7" />&nbsp;&nbsp;2.<br class="calibre7" />&nbsp;&nbsp;3. import random<br class="calibre7" />&nbsp;&nbsp;4.<br class="calibre7" />&nbsp;&nbsp;5. def drawBoard(board):<br class="calibre7" />&nbsp;&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# This function prints out the board that it was passed.<br class="calibre7" />&nbsp;&nbsp;7.<br class="calibre7" />&nbsp;&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# "board" is a list of 10 strings representing the board (ignore<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index 0).<br class="calibre7" />&nbsp;&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[7] + '|' + board[8] + '|' + board[9])<br class="calibre7" />&nbsp;10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('-+-+-')<br class="calibre7" />&nbsp;11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[4] + '|' + board[5] + '|' + board[6])<br class="calibre7" />&nbsp;12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('-+-+-')<br class="calibre7" />&nbsp;13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[1] + '|' + board[2] + '|' + board[3])<br class="calibre7" />&nbsp;14.<br class="calibre7" />&nbsp;15. def inputPlayerLetter():<br class="calibre7" />&nbsp;16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Lets the player type which letter they want to be.<br class="calibre7" />&nbsp;17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a list with the player's letter as the first item and the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computer's letter as the second.<br class="calibre7" />&nbsp;18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letter = ''<br class="calibre7" />&nbsp;19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while not (letter == 'X' or letter == 'O'):<br class="calibre7" />&nbsp;20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to be X or O?')<br class="calibre7" />&nbsp;21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letter = input().upper()<br class="calibre7" />&nbsp;22.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-885"></span> 23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The first element in the list is the player's letter; the second is<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the computer's letter.<br class="calibre7" />&nbsp;24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letter == 'X':<br class="calibre7" />&nbsp;25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['X', 'O']<br class="calibre7" />&nbsp;26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />&nbsp;27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['O', 'X']<br class="calibre7" />&nbsp;28.<br class="calibre7" />&nbsp;29. def whoGoesFirst():<br class="calibre7" />&nbsp;30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Randomly choose which player goes first.<br class="calibre7" />&nbsp;31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if random.randint(0, 1) == 0:<br class="calibre7" />&nbsp;32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'computer'<br class="calibre7" />&nbsp;33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />&nbsp;34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'player'<br class="calibre7" />&nbsp;35.<br class="calibre7" />&nbsp;36. def makeMove(board, letter, move):<br class="calibre7" />&nbsp;37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[move] = letter<br class="calibre7" />&nbsp;38.<br class="calibre7" />&nbsp;39. def isWinner(bo, le):<br class="calibre7" />&nbsp;40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and a player's letter, this function returns True if<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that player has won.<br class="calibre7" />&nbsp;41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# We use "bo" instead of "board" and "le" instead of "letter" so we<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;don't have to type as much.<br class="calibre7" />&nbsp;42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ((bo[7] == le and bo[8] == le and bo[9] == le) or # Across the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top<br class="calibre7" />&nbsp;43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[4] == le and bo[5] == le and bo[6] == le) or # Across the middle<br class="calibre7" />&nbsp;44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[1] == le and bo[2] == le and bo[3] == le) or # Across the bottom<br class="calibre7" />&nbsp;45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[7] == le and bo[4] == le and bo[1] == le) or # Down the left side<br class="calibre7" />&nbsp;46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[8] == le and bo[5] == le and bo[2] == le) or # Down the middle<br class="calibre7" />&nbsp;47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[9] == le and bo[6] == le and bo[3] == le) or # Down the right<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;side<br class="calibre7" />&nbsp;48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[7] == le and bo[5] == le and bo[3] == le) or # Diagonal<br class="calibre7" />&nbsp;49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[9] == le and bo[5] == le and bo[1] == le)) # Diagonal<br class="calibre7" />&nbsp;50.<br class="calibre7" />&nbsp;51. def getBoardCopy(board):<br class="calibre7" />&nbsp;52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make a copy of the board list and return it.<br class="calibre7" />&nbsp;53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = []<br class="calibre7" />&nbsp;54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in board:<br class="calibre7" />&nbsp;55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy.append(i)<br class="calibre7" />&nbsp;56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy<br class="calibre7" />&nbsp;57.<br class="calibre7" />&nbsp;58. def isSpaceFree(board, move):<br class="calibre7" />&nbsp;59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the passed move is free on the passed board.<br class="calibre7" />&nbsp;60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board[move] == ' '<br class="calibre7" />&nbsp;61.<br class="calibre7" />&nbsp;62. def getPlayerMove(board):<br class="calibre7" />&nbsp;63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter their move.<br class="calibre7" />&nbsp;64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = ' '<br class="calibre7" />&nbsp;65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while move not in '1 2 3 4 5 6 7 8 9'.split() or not<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSpaceFree(board, int(move)):<br class="calibre7" />&nbsp;66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('What is your next move? (1-9)')<br class="calibre7" />&nbsp;67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = input()<br class="calibre7" />&nbsp;68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return int(move)<br class="calibre7" />&nbsp;69.<br class="calibre7" />&nbsp;70. def chooseRandomMoveFromList(board, movesList):<br class="calibre7" />&nbsp;71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a valid move from the passed list on the passed board.<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-886"></span> 72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns None if there is no valid move.<br class="calibre7" />&nbsp;73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = []<br class="calibre7" />&nbsp;74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in movesList:<br class="calibre7" />&nbsp;75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, i):<br class="calibre7" />&nbsp;76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves.append(i)<br class="calibre7" />&nbsp;77.<br class="calibre7" />&nbsp;78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(possibleMoves) != 0:<br class="calibre7" />&nbsp;79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return random.choice(possibleMoves)<br class="calibre7" />&nbsp;80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />&nbsp;81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None<br class="calibre7" />&nbsp;82.<br class="calibre7" />&nbsp;83. def getComputerMove(board, computerLetter):<br class="calibre7" />&nbsp;84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and the computer's letter, determine where to move<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and return that move.<br class="calibre7" />&nbsp;85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if computerLetter == 'X':<br class="calibre7" />&nbsp;86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter = 'O'<br class="calibre7" />&nbsp;87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />&nbsp;88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter = 'X'<br class="calibre7" />&nbsp;89.<br class="calibre7" />&nbsp;90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Here is the algorithm for our Tic-Tac-Toe AI:<br class="calibre7" />&nbsp;91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, check if we can win in the next move.<br class="calibre7" />&nbsp;92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />&nbsp;93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />&nbsp;94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(boardCopy, i):<br class="calibre7" />&nbsp;95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, computerLetter, i)<br class="calibre7" />&nbsp;96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(boardCopy, computerLetter):<br class="calibre7" />&nbsp;97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i<br class="calibre7" />&nbsp;98.<br class="calibre7" />&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check if the player could win on their next move and block them.<br class="calibre7" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(boardCopy, i):<br class="calibre7" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, playerLetter, i)<br class="calibre7" />104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(boardCopy, playerLetter):<br class="calibre7" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i<br class="calibre7" />106.<br class="calibre7" />107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try to take one of the corners, if they are free.<br class="calibre7" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = chooseRandomMoveFromList(board, [1, 3, 7, 9])<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move != None:<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return move<br class="calibre7" />111.<br class="calibre7" />112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try to take the center, if it is free.<br class="calibre7" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, 5):<br class="calibre7" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 5<br class="calibre7" />115.<br class="calibre7" />116.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move on one of the sides.<br class="calibre7" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return chooseRandomMoveFromList(board, [2, 4, 6, 8])<br class="calibre7" />118.<br class="calibre7" />119. def isBoardFull(board):<br class="calibre7" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if every space on the board has been taken. Otherwise,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False.<br class="calibre7" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, i):<br class="calibre7" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True<br class="calibre7" /><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-887"></span>125.<br class="calibre7" />126.<br class="calibre7" />127. print('Welcome to Tic-Tac-Toe!')<br class="calibre7" />128.<br class="calibre7" />129. while True:<br class="calibre7" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Reset the board.<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theBoard = [' '] * 10<br class="calibre7" />132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter, computerLetter = inputPlayerLetter()<br class="calibre7" />133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = whoGoesFirst()<br class="calibre7" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The ' + turn + ' will go first.')<br class="calibre7" />135.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = True<br class="calibre7" />136.<br class="calibre7" />137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while gameIsPlaying:<br class="calibre7" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if turn == 'player':<br class="calibre7" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Player's turn<br class="calibre7" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getPlayerMove(theBoard)<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(theBoard, playerLetter, move)<br class="calibre7" />143.<br class="calibre7" />144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(theBoard, playerLetter):<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hooray! You have won the game!')<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = False<br class="calibre7" />148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isBoardFull(theBoard):<br class="calibre7" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game is a tie!')<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'computer'<br class="calibre7" />155.<br class="calibre7" />156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Computer's turn<br class="calibre7" />158.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getComputerMove(theBoard, computerLetter)<br class="calibre7" />159.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(theBoard, computerLetter, move)<br class="calibre7" />160.<br class="calibre7" />161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(theBoard, computerLetter):<br class="calibre7" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />163.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The computer has beaten you! You lose.')<br class="calibre7" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = False<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />166.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isBoardFull(theBoard):<br class="calibre7" />167.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game is a tie!')<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'<br class="calibre7" />172.<br class="calibre7" />173.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to play again? (yes or no)')<br class="calibre7" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not input().lower().startswith('y'):<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<h3 class="h2" id="calibre_link-550"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-265" class="calibre1"></span><strong class="calibre2">Designing the Program</strong></h3>
<p class="noindent"><a href="#calibre_link-112" class="calibre4">Figure 10-2</a> shows a flowchart of the Tic-Tac-Toe program. The program starts by asking the player to choose their letter, <em class="calibre6">X</em> or <em class="calibre6">O</em>. Who takes the first turn is randomly chosen. Then the player and computer take turns making moves.</p>
<div class="image"><img src="images/00110.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-112" class="calibre4"></a><em class="calibre6">Figure 10-2: Flowchart for Tic-Tac-Toe</em></p>
<p class="indent">The boxes on the left side of the flowchart show what happens during the player’s turn, and the ones on the right side show what happens during the computer’s turn. After the player or computer makes a move, the program checks whether they won or caused a tie, and then the game switches turns. After the game is over, the program asks the player if they want to play again.</p>
<h4 class="h3" id="calibre_link-551"><em class="calibre10"><strong class="calibre2">Representing the Board as Data</strong></em></h4>
<p class="noindenta">First, you must figure out how to represent the board as data in a variable. On paper, the Tic-Tac-Toe board is drawn as a pair of horizontal lines and a pair of vertical lines, with an <em class="calibre6">X</em>, <em class="calibre6">O</em>, or empty space in each of the nine spaces.</p>
<p class="indent">In the program, the Tic-Tac-Toe board is represented as a list of strings like the ASCII art of Hangman. Each string represents one of the nine spaces on the board. The strings are either <span class="literal1">'X'</span> for the <em class="calibre6">X</em> player, <span class="literal1">'O'</span> for the <em class="calibre6">O</em> player, or a single space <span class="literal1">' '</span> for a blank space.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-180"></span>Remember that we’re laying out our board like a number pad on a keyboard. So if a list with 10 strings was stored in a variable named <span class="literal1">board</span>, then <span class="literal1">board[7]</span> would be the top-left space on the board, <span class="literal1">board[8]</span> would be the top-middle space, <span class="literal1">board[9]</span> would be the top-right space, and so on. The program ignores the string at index <span class="literal1">0</span> in the list. The player will enter a number from 1 to 9 to tell the game which space they want to move on.</p>
<h4 class="h3" id="calibre_link-552"><em class="calibre10"><strong class="calibre2">Strategizing with the Game AI</strong></em></h4>
<p class="noindenta">The AI needs to be able to look at the board and decide which types of spaces it will move on. To be clear, we will label three types of spaces on the Tic-Tac-Toe board: corners, sides, and the center. The chart in <a href="#calibre_link-113" class="calibre4">Figure 10-3</a> shows what each space is.</p>
<p class="indent">The AI’s strategy for playing Tic-Tac-Toe will follow a simple <em class="calibre6">algorithm</em>&mdash;a finite series of instructions to compute a result. A single program can make use of several different algorithms. An algorithm can be represented with a flowchart. The Tic-Tac-Toe AI’s algorithm will compute the best move to make, as shown in <a href="#calibre_link-114" class="calibre4">Figure 10-4</a>.</p>
<div class="image"><img src="images/00111.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-113" class="calibre4"></a><em class="calibre6">Figure 10-3: Locations of the side, corner, and center spaces</em></p>
<div class="image"><img src="images/00112.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-114" class="calibre4"></a><em class="calibre6">Figure 10-4: The boxes represent the five steps of the “Get computer’s move” algorithm. The arrows pointing to the left go to the “Check if computer won” box.</em></p>
<p class="indent">The AI’s algorithm has the following steps:</p>
<ol class="calibre12">
<li value="1" class="calibre13"><p class="noindenta">See if there’s a move the computer can make that will win the game. If there is, make that move. Otherwise, go to step 2.</p></li>
<li value="2" class="calibre13"><p class="noindenta">See if there’s a move the player can make that will cause the computer to lose the game. If there is, move there to block the player. Otherwise, go to step 3.</p></li>
<li value="3" class="calibre13"><p class="noindenta">Check if any of the corner spaces (spaces 1, 3, 7, or 9) are free. If so, move there. If no corner space is free, go to step 4.</p></li>
<li value="4" class="calibre13"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-392"></span><p class="noindenta">Check if the center is free. If so, move there. If it isn’t, go to step 5.</p></li>
<li value="5" class="calibre13"><p class="noindenta">Move on any of the side spaces (spaces 2, 4, 6, or 8). There are no more steps because the side spaces are all that’s left if the execution reaches step 5.</p></li>
</ol>
<p class="indent">This all takes place in the Get computer’s move box on the flowchart in <a href="#calibre_link-112" class="calibre4">Figure 10-2</a>. You could add this information to the flowchart with the boxes in <a href="#calibre_link-114" class="calibre4">Figure 10-4</a>.</p>
<p class="indent">This algorithm is implemented in <span class="literal1">getComputerMove()</span> and the other functions that <span class="literal1">getComputerMove()</span> calls.</p>
<h3 class="h2" id="calibre_link-553"><strong class="calibre2">Importing the random Module</strong></h3>
<p class="noindent">The first couple of lines are made up of a comment and a line importing the <span class="literal1">random</span> module so that you can call the <span class="literal1">randint()</span> function later on:</p>
<p class="programs">1. # Tic-Tac-Toe<br class="calibre7" />2.<br class="calibre7" />3. import random</p>
<p class="indent">You’ve seen both these concepts before, so let’s move on to the next part of the program.</p>
<h3 class="h2" id="calibre_link-554"><strong class="calibre2">Printing the Board on the Screen</strong></h3>
<p class="noindent">In the next part of the code, we define a function to draw the board:</p>
<p class="programs">&nbsp;5. def drawBoard(board):<br class="calibre7" />&nbsp;6.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# This function prints out the board that it was passed.<br class="calibre7" />&nbsp;7.<br class="calibre7" />&nbsp;8.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# "board" is a list of 10 strings representing the board (ignore<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index 0).<br class="calibre7" />&nbsp;9.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[7] + '|' + board[8] + '|' + board[9])<br class="calibre7" />10.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('-+-+-')<br class="calibre7" />11.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[4] + '|' + board[5] + '|' + board[6])<br class="calibre7" />12.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('-+-+-')<br class="calibre7" />13.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(board[1] + '|' + board[2] + '|' + board[3])</p>
<p class="indent">The <span class="literal1">drawBoard()</span> function prints the game board represented by the <span class="literal1">board</span> parameter. Remember that the board is represented as a list of 10 strings, where the string at index <span class="literal1">1</span> is the mark on space 1 on the Tic-Tac-Toe board, and so on. The string at index <span class="literal1">0</span> is ignored. Many of the game’s functions work by passing a list of 10 strings as the board.</p>
<p class="indent">Be sure to get the spacing right in the strings; otherwise, the board will look funny when printed on the screen. Here are some example calls (with an argument for <span class="literal1">board</span>) to <span class="literal1">drawBoard()</span> and what the function would print.</p>
<p class="programs"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-390"></span>&gt;&gt;&gt; <span class="codestrong">drawBoard([' ', ' ', ' ', ' ', 'X', 'O', ' ', 'X', ' ', 'O'])</span><br class="calibre7" />X| |<br class="calibre7" />-+-+-<br class="calibre7" />X|O|<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">drawBoard([' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '])</span><br class="calibre7" />&nbsp;| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;| |</p>
<p class="indent">The program takes each string and places it on the board in number order according to the keyboard number pad from <a href="#calibre_link-111" class="calibre4">Figure 10-1</a>, so the first three strings are the bottom row of the board, the next three strings are the middle, and the last three strings are the top.</p>
<h3 class="h2" id="calibre_link-555"><strong class="calibre2">Letting the Player Choose X or O</strong></h3>
<p class="noindent">Next, we’ll define a function to assign <em class="calibre6">X</em> or <em class="calibre6">O</em> to the player:</p>
<p class="programs">15. def inputPlayerLetter():<br class="calibre7" />16.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Lets the player enter which letter they want to be.<br class="calibre7" />17.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a list with the player's letter as the first item and the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;computer's letter as the second.<br class="calibre7" />18.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letter = ''<br class="calibre7" />19.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while not (letter == 'X' or letter == 'O'):<br class="calibre7" />20.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to be X or O?')<br class="calibre7" />21.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;letter = input().upper()</p>
<p class="indent">The <span class="literal1">inputPlayerLetter()</span> function asks whether the player wants to be <em class="calibre6">X</em> or <em class="calibre6">O</em>. The <span class="literal1">while</span> loop’s condition contains parentheses, which means the expression inside the parentheses is evaluated first. If the <span class="literal1">letter</span> variable was set to <span class="literal1">'X'</span>, the expression would evaluate like this:</p>
<div class="image"><img src="images/00114.jpeg" alt="image" class="calibre3" /></div>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-388"></span>If <span class="literal1">letter</span> has the value <span class="literal1">'X'</span> or <span class="literal1">'O'</span>, then the loop’s condition is <span class="literal1">False</span> and lets the program execution continue past the <span class="literal1">while</span> block. If the condition is <span class="literal1">True</span>, the program will keep asking the player to choose a letter until the player enters an <em class="calibre6">X</em> or <em class="calibre6">O</em>. Line 21 automatically changes the string returned by the call to <span class="literal1">input()</span> to uppercase letters with the <span class="literal1">upper()</span> string method.</p>
<p class="indent">The next function returns a list with two items:</p>
<p class="programs">23.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# The first element in the list is the player's letter; the second is<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the computer's letter.<br class="calibre7" />24.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if letter == 'X':<br class="calibre7" />25.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['X', 'O']<br class="calibre7" />26.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />27.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ['O', 'X']</p>
<p class="indent">The first item (the string at index <span class="literal1">0</span>) is the player’s letter, and the second item (the string at index <span class="literal1">1</span>) is the computer’s letter. The <span class="literal1">if</span> and <span class="literal1">else</span> statements choose the appropriate list to return.</p>
<h3 class="h2" id="calibre_link-556"><strong class="calibre2">Deciding Who Goes First</strong></h3>
<p class="noindent">Next we create a function that uses <span class="literal1">randint()</span> to choose whether the player or computer plays first:</p>
<p class="programs">29. def whoGoesFirst():<br class="calibre7" />30.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Randomly choose which player goes first.<br class="calibre7" />31.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if random.randint(0, 1) == 0:<br class="calibre7" />32.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'computer'<br class="calibre7" />33.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />34.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 'player'</p>
<p class="indent">The <span class="literal1">whoGoesFirst()</span> function does a virtual coin flip to determine whether the computer or the player goes first. The coin flip is done with a call to <span class="literal1">random.randint(0, 1)</span>. There is a 50 percent chance the function returns <span class="literal1">0</span> and a 50 percent chance the function returns <span class="literal1">1</span>. If this function call returns a <span class="literal1">0</span>, the <span class="literal1">whoGoesFirst()</span> function returns the string <span class="literal1">'computer'</span>. Otherwise, the function returns the string <span class="literal1">'player'</span>. The code that calls this function will use the return value to determine who will make the first move of the game.</p>
<h3 class="h2" id="calibre_link-557"><strong class="calibre2">Placing a Mark on the Board</strong></h3>
<p class="noindent">The <span class="literal1">makeMove()</span> function is simple:</p>
<p class="programs">36. def makeMove(board, letter, move):<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[move] = letter</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-104"></span>The parameters are <span class="literal1">board</span>, <span class="literal1">letter</span>, and <span class="literal1">move</span>. The variable <span class="literal1">board</span> is the list with 10 strings that represents the state of the board. The variable <span class="literal1">letter</span> is the player’s letter (either <span class="literal1">'X'</span> or <span class="literal1">'O'</span>). The variable <span class="literal1">move</span> is the place on the board where that player wants to go (which is an integer from <span class="literal1">1</span> to <span class="literal1">9</span>).</p>
<p class="indent">But wait&mdash;in line 37, this code seems to change one of the items in the <span class="literal1">board</span> list to the value in <span class="literal1">letter</span>. Because this code is in a function, though, the <span class="literal1">board</span> parameter will be forgotten when the function returns. So shouldn’t the change to <span class="literal1">board</span> be forgotten as well?</p>
<p class="indent">Actually, this isn’t the case, because lists are special when you pass them as arguments to functions. You are actually passing a <em class="calibre6">reference</em> to the list, not the list itself. Let’s learn about the difference between lists and references to lists.</p>
<h4 class="h3" id="calibre_link-103"><em class="calibre10"><strong class="calibre2">List References</strong></em></h4>
<p class="noindenta">Enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">spam = 42</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese = spam</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam = 100</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre7" />100<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre7" />42</p>
<p class="indent">These results make sense from what you know so far. You assign <span class="literal1">42</span> to the <span class="literal1">spam</span> variable, then assign the value in <span class="literal1">spam</span> to the variable <span class="literal1">cheese</span>. When you later overwrite <span class="literal1">spam</span> to <span class="literal1">100</span>, this doesn’t affect the value in <span class="literal1">cheese</span>. This is because <span class="literal1">spam</span> and <span class="literal1">cheese</span> are different variables that store different values.</p>
<p class="indent">But lists don’t work this way. When you assign a list to a variable, you are actually assigning a list reference to the variable. A <em class="calibre6">reference</em> is a value that points to the location where some bit of data is stored. Let’s look at some code that will make this easier to understand. Enter this into the interactive shell:</p>
<p class="programs"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5]</span><br class="calibre7" /><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong">cheese = spam</span><br class="calibre7" /><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong">cheese[1] = 'Hello!'</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;[0, 'Hello!', 2, 3, 4, 5]<br class="calibre7" />&nbsp;&nbsp;&nbsp;&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre7" />&nbsp;&nbsp;&nbsp;[0, 'Hello!', 2, 3, 4, 5]</p>
<p class="indent">The code only changed the <span class="literal1">cheese</span> list, but it seems that both the <span class="literal1">cheese</span> and <span class="literal1">spam</span> lists have changed. This is because the <span class="literal1">spam</span> variable doesn’t contain the list value itself but rather a reference to the list, as shown in <a href="#calibre_link-115" class="calibre4">Figure 10-5</a>. The list itself is not contained in any variable but rather exists outside of them.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-888"></span><img src="images/00009.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-115" class="calibre4"></a><em class="calibre6">Figure 10-5: The</em> <span class="literal"><span class="codeitalic">spam</span></span> <em class="calibre6">list created at</em> <span class="ent">➊</span><em class="calibre6">. Variables don’t store lists but rather references to lists.</em></p>
<p class="indent">Notice that <span class="literal1">cheese = spam</span> copies the <em class="calibre6">list reference</em> in <span class="literal1">spam</span> to <span class="literal1">cheese</span> <span class="ent">➋</span>, instead of copying the list value itself. Now both <span class="literal1">spam</span> and <span class="literal1">cheese</span> store a reference that refers to the same list value. But there is only one list because the list itself wasn’t copied. <a href="#calibre_link-116" class="calibre4">Figure 10-6</a> shows this copying.</p>
<div class="image"><img src="images/00010.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-116" class="calibre4"></a><em class="calibre6">Figure 10-6: The</em> <span class="literal"><span class="codeitalic">spam</span></span> <em class="calibre6">and</em> <span class="literal"><span class="codeitalic">cheese</span></span> <em class="calibre6">variables store two references to the same list.</em></p>
<p class="indent">So the <span class="literal1">cheese[1] = 'Hello!'</span> line at <span class="ent">➌</span> changes the same list that <span class="literal1">spam</span> refers to. This is why <span class="literal1">spam</span> returns the same list value that <span class="literal1">cheese</span> does. They both have references that refer to the same list, as shown in <a href="#calibre_link-117" class="calibre4">Figure 10-7</a>.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-273"></span><img src="images/00002.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-117" class="calibre4"></a><em class="calibre6">Figure 10-7: Changing the list changes all variables with references to that list.</em></p>
<p class="indent">If you want <span class="literal1">spam</span> and <span class="literal1">cheese</span> to store two different lists, you have to create two lists instead of copying a reference:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5]</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese = [0, 1, 2, 3, 4, 5]</span></p>
<p class="indent">In the preceding example, <span class="literal1">spam</span> and <span class="literal1">cheese</span> store two different lists (even though these lists are identical in content). Now if you modify one of the lists, it won’t affect the other because <span class="literal1">spam</span> and <span class="literal1">cheese</span> have references to two different lists:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">spam = [0, 1, 2, 3, 4, 5]</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese = [0, 1, 2, 3, 4, 5]</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese[1] = 'Hello!'</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam</span><br class="calibre7" />[0, 1, 2, 3, 4, 5]<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">cheese</span><br class="calibre7" />[0, 'Hello!', 2, 3, 4, 5]</p>
<p class="indent"><a href="#calibre_link-118" class="calibre4">Figure 10-8</a> shows how the variables and list values are set up in this example.</p>
<p class="indent">Dictionaries work the same way. Variables don’t store dictionaries; they store <em class="calibre6">references</em> to dictionaries.</p>
<div class="image"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-385"></span><img src="images/00036.jpeg" alt="image" class="calibre3" /></div>
<p class="figcap"><a id="calibre_link-118" class="calibre4"></a><em class="calibre6">Figure 10-8: The</em> <span class="literal"><span class="codeitalic">spam</span></span> <em class="calibre6">and</em> <span class="literal"><span class="codeitalic">cheese</span></span> <em class="calibre6">variables now each store references to two different lists.</em></p>
<h4 class="h3" id="calibre_link-558"><em class="calibre10"><strong class="calibre2">Using List References in makeMove()</strong></em></h4>
<p class="noindenta">Let’s go back to the <span class="literal1">makeMove()</span> function:</p>
<p class="programs">36. def makeMove(board, letter, move):<br class="calibre7" />37.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;board[move] = letter</p>
<p class="indent">When a list value is passed for the <span class="literal1">board</span> parameter, the function’s local variable is really a copy of the reference to the list, not a copy of the list itself. So any changes to <span class="literal1">board</span> in this function will also be made to the original list. Even though <span class="literal1">board</span> is a local variable, the <span class="literal1">makeMove()</span> function modifies the original list.</p>
<p class="indent">The <span class="literal1">letter</span> and <span class="literal1">move</span> parameters are copies of the string and integer values that you pass. Since they are copies of values, if you modify <span class="literal1">letter</span> or <span class="literal1">move</span> in this function, the original variables you used when you called <span class="literal1">makeMove()</span> aren’t modified.</p>
<h3 class="h2" id="calibre_link-559"><strong class="calibre2">Checking Whether the Player Won</strong></h3>
<p class="noindent">Lines 42 to 49 in the <span class="literal1">isWinner()</span> function are actually one long <span class="literal1">return</span> statement:</p>
<p class="programs">39. def isWinner(bo, le):<br class="calibre7" />40.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and a player's letter, this function returns True if<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;that player has won.<br class="calibre7" />41.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# We use "bo" instead of "board" and "le" instead of "letter" so we<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;don't have to type as much.<br class="calibre7" />42.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ((bo[7] == le and bo[8] == le and bo[9] == le) or # Across the<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;top<br class="calibre7" />43.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[4] == le and bo[5] == le and bo[6] == le) or # Across the middle<br class="calibre7" />44.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[1] == le and bo[2] == le and bo[3] == le) or # Across the bottom<br class="calibre7" />45.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[7] == le and bo[4] == le and bo[1] == le) or # Down the left side<br class="calibre7" />46.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[8] == le and bo[5] == le and bo[2] == le) or # Down the middle<br class="calibre7" />47.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[9] == le and bo[6] == le and bo[3] == le) or # Down the right<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;side<br class="calibre7" />48.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[7] == le and bo[5] == le and bo[3] == le) or # Diagonal<br class="calibre7" />49.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(bo[9] == le and bo[5] == le and bo[1] == le)) # Diagonal</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-216"></span>The <span class="literal1">bo</span> and <span class="literal1">le</span> names are shortcuts for the <span class="literal1">board</span> and <span class="literal1">letter</span> parameters. These shorter names mean you have less to type in this function. Remember, Python doesn’t care what you name your variables.</p>
<p class="indent">There are eight possible ways to win at Tic-Tac-Toe: you can have a line across the top, middle, or bottom rows; you can have a line down the left, middle, or right columns; or you can have a line across either of the two diagonals.</p>
<p class="indent">Each line of the condition checks whether the three spaces for a given line are equal to the letter provided (combined with the <span class="literal1">and</span> operator). You combine each line using the <span class="literal1">or</span> operator to check for the eight different ways to win. This means only one of the eight ways must be <span class="literal1">True</span> in order for us to say that the player who owns the letter in <span class="literal1">le</span> is the winner.</p>
<p class="indent">Let’s pretend that <span class="literal1">le</span> is <span class="literal1">'O'</span> and <span class="literal1">bo</span> is <span class="literal1">[' ', 'O', 'O', 'O', ' ', 'X', ' ', 'X', ' ', ' ']</span>. The board would look like this:</p>
<p class="programs">X| |<br class="calibre7" />-+-+-<br class="calibre7" />&nbsp;|X|<br class="calibre7" />-+-+-<br class="calibre7" />O|O|O</p>
<p class="indent">Here is how the expression after the <span class="literal1">return</span> keyword on line 42 would evaluate. First Python replaces the variables <span class="literal1">bo</span> and <span class="literal1">le</span> with the values in each variable:</p>
<p class="programs1">return (('X' == 'O' and ' ' == 'O' and ' ' == 'O') or<br class="calibre7" />(' ' == 'O' and 'X' == 'O' and ' ' == 'O') or<br class="calibre7" />('O' == 'O' and 'O' == 'O' and 'O' == 'O') or<br class="calibre7" />('X' == 'O' and ' ' == 'O' and 'O' == 'O') or<br class="calibre7" />(' ' == 'O' and 'X' == 'O' and 'O' == 'O') or<br class="calibre7" />(' ' == 'O' and ' ' == 'O' and 'O' == 'O') or<br class="calibre7" />('X' == 'O' and 'X' == 'O' and 'O' == 'O') or<br class="calibre7" />(' ' == 'O' and 'X' == 'O' and 'O' == 'O'))</p>
<p class="indent">Next, Python evaluates all those <span class="literal1">==</span> comparisons inside the parentheses to Boolean values:</p>
<p class="programs1">return ((False and False and False) or<br class="calibre7" />(False and False and False) or<br class="calibre7" />(True and True and True) or<br class="calibre7" />(False and False and True) or<br class="calibre7" />(False and False and True) or<br class="calibre7" />(False and False and True) or<br class="calibre7" />(False and False and True) or<br class="calibre7" />(False and False and True))</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-389"></span>Then the Python interpreter evaluates all the expressions inside the parentheses:</p>
<p class="programs1">return ((False) or<br class="calibre7" />(False) or<br class="calibre7" />(True) or<br class="calibre7" />(False) or<br class="calibre7" />(False) or<br class="calibre7" />(False) or<br class="calibre7" />(False) or<br class="calibre7" />(False))</p>
<p class="indent">Since now there’s only one value inside each of the inner parentheses, you can get rid of them:</p>
<p class="programs1">return (False or<br class="calibre7" />False or<br class="calibre7" />True or<br class="calibre7" />False or<br class="calibre7" />False or<br class="calibre7" />False or<br class="calibre7" />False or<br class="calibre7" />False)</p>
<p class="indent">Now Python evaluates the expression connected by all those <span class="literal1">or</span> operators:</p>
<p class="programs1">return (True)</p>
<p class="indent">Once again, get rid of the parentheses, and you are left with one value:</p>
<p class="programs1">return True</p>
<p class="indent">So given those values for <span class="literal1">bo</span> and <span class="literal1">le</span>, the expression would evaluate to <span class="literal1">True</span>. This is how the program can tell if one of the players has won the game.</p>
<h3 class="h2" id="calibre_link-560"><strong class="calibre2">Duplicating the Board Data</strong></h3>
<p class="noindent">The <span class="literal1">getBoardCopy()</span> function allows you to easily make a copy of a given 10-string list that represents a Tic-Tac-Toe board in the game.</p>
<p class="programs">51. def getBoardCopy(board):<br class="calibre7" />52.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Make a copy of the board list and return it.<br class="calibre7" />53.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = []<br class="calibre7" />54.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in board:<br class="calibre7" />55.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy.append(i)<br class="calibre7" />56.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return boardCopy</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-384"></span>When the AI algorithm is planning its moves, it will sometimes need to make modifications to a temporary copy of the board without changing the actual board. In those cases, we call this function to make a copy of the board’s list. The new list is created on line 53.</p>
<p class="indent">Right now, the list stored in <span class="literal1">boardCopy</span> is just an empty list. The <span class="literal1">for</span> loop will iterate over the <span class="literal1">board</span> parameter, appending a copy of the string values in the actual board to the duplicate board. After the <span class="literal1">getBoardCopy()</span> function builds up a copy of the actual board, it returns a reference to this new board in <span class="literal1">boardCopy</span>, not to the original one in <span class="literal1">board</span>.</p>
<h3 class="h2" id="calibre_link-561"><strong class="calibre2">Checking Whether a Space on the Board Is Free</strong></h3>
<p class="noindent">Given a Tic-Tac-Toe board and a possible move, the simple <span class="literal1">isSpaceFree()</span> function returns whether that move is available or not:</p>
<p class="programs">58. def isSpaceFree(board, move):<br class="calibre7" />59.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if the passed move is free on the passed board.<br class="calibre7" />60.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return board[move] == ' '</p>
<p class="indent">Remember that free spaces in the board lists are marked as a single-space string. If the item at the space’s index is not equal to <span class="literal1">' '</span>, then the space is taken.</p>
<h3 class="h2" id="calibre_link-562"><strong class="calibre2">Letting the Player Enter a Move</strong></h3>
<p class="noindent">The <span class="literal1">getPlayerMove()</span> function asks the player to enter the number for the space they want to move on:</p>
<p class="programs">62. def getPlayerMove(board):<br class="calibre7" />63.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Let the player enter their move.<br class="calibre7" />64.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = ' '<br class="calibre7" />65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while move not in '1 2 3 4 5 6 7 8 9'.split() or not<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSpaceFree(board, int(move)):<br class="calibre7" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('What is your next move? (1-9)')<br class="calibre7" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = input()<br class="calibre7" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return int(move)</p>
<p class="indent">The condition on line 65 is <span class="literal1">True</span> if either of the expressions on the left or right side of the <span class="literal1">or</span> operator is <span class="literal1">True</span>. The loop makes sure the execution doesn’t continue until the player has entered an integer between 1 and 9. It also checks that the space entered isn’t already taken, given the Tic-Tac-Toe board passed to the function for the <span class="literal1">board</span> parameter. The two lines of code inside the <span class="literal1">while</span> loop simply ask the player to enter a number from 1 to 9.</p>
<p class="indent">The expression on the left side checks whether the player’s move is equal to <span class="literal1">'1'</span>, <span class="literal1">'2'</span>, <span class="literal1">'3'</span>, and so on up to <span class="literal1">'9'</span> by creating a list with these strings (with the <span class="literal1">split()</span> method) and checking whether <span class="literal1">move</span> is in this list. In this expression, <span class="literal1">'1 2 3 4 5 6 7 8 9'.split()</span> evaluates to <span class="literal1">['1', '2', '3', '4', '5', '6', '7', '8', '9']</span>, but the former is easier to type.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-81"></span>The expression on the right side checks whether the move the player entered is a free space on the board by calling <span class="literal1">isSpaceFree()</span>. Remember that <span class="literal1">isSpaceFree()</span> returns <span class="literal1">True</span> if the move you pass is available on the board. Note that <span class="literal1">isSpaceFree()</span> expects an integer for <span class="literal1">move</span>, so the <span class="literal1">int()</span> function returns an integer form of <span class="literal1">move</span>.</p>
<p class="indent">The <span class="literal1">not</span> operators are added to both sides so that the condition is <span class="literal1">True</span> when either of these requirements is unfulfilled. This causes the loop to ask the player again and again for a number until they enter a proper move.</p>
<p class="indent">Finally, line 68 returns the integer form of whatever move the player entered. <span class="literal1">input()</span> returns strings, so the <span class="literal1">int()</span> function is called to return an integer form of the string.</p>
<h3 class="h2" id="calibre_link-80"><strong class="calibre2">Short-Circuit Evaluation</strong></h3>
<p class="noindent">You may have noticed there’s a possible problem in the <span class="literal1">getPlayerMove()</span> function. What if the player entered <span class="literal1">'Z'</span> or some other noninteger string? The expression <span class="literal1">move not in '1 2 3 4 5 6 7 8 9'.split()</span> on the left side of <span class="literal1">or</span> would return <span class="literal1">False</span> as expected, and then Python would evaluate the expression on the right side of the <span class="literal1">or</span> operator.</p>
<p class="indent">But calling <span class="literal1">int('Z')</span> would cause Python to give an error, because the <span class="literal1">int()</span> function can take only strings of number characters like <span class="literal1">'9'</span> or <span class="literal1">'0'</span>, not strings like <span class="literal1">'Z'</span>.</p>
<p class="indent">To see an example of this kind of error, enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">int('42')</span><br class="calibre7" />42<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">int('Z')</span><br class="calibre7" />Traceback (most recent call last):<br class="calibre7" />&nbsp;&nbsp;File "&lt;pyshell#3&gt;", line 1, in &lt;module&gt;<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;int('Z')<br class="calibre7" />ValueError: invalid literal for int() with base 10: 'Z'</p>
<p class="indent">But when you play the Tic-Tac-Toe game and try entering <span class="literal1">'Z'</span> for your move, this error doesn’t happen. This is because the <span class="literal1">while</span> loop’s condition is being short-circuited.</p>
<p class="indent"><em class="calibre6">Short-circuiting</em> means that an expression evaluates only part of the way, since the rest of the expression doesn’t change what the expression evaluates to. Here’s a short program that gives a good example of short-circuiting. Enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">def ReturnsTrue():<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('ReturnsTrue() was called.')<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">def ReturnsFalse():<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('ReturnsFalse() was called.')<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False</span><br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">ReturnsTrue()</span><br class="calibre7" />ReturnsTrue() was called.<br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">ReturnsFalse()</span><br class="calibre7" />ReturnsFalse() was called.<br class="calibre7" />False</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-183"></span>When <span class="literal1">ReturnsTrue()</span> is called, it prints <span class="literal1">'ReturnsTrue() was called.'</span> and then also displays the return value of <span class="literal1">ReturnsTrue()</span>. The same goes for <span class="literal1">ReturnsFalse()</span>.</p>
<p class="indent">Now enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">ReturnsFalse() or ReturnsTrue()</span><br class="calibre7" />ReturnsFalse() was called.<br class="calibre7" />ReturnsTrue() was called.<br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">ReturnsTrue() or ReturnsFalse()</span><br class="calibre7" />ReturnsTrue() was called.<br class="calibre7" />True</p>
<p class="indent">The first part makes sense: the expression <span class="literal1">ReturnsFalse() or ReturnsTrue()</span> calls both of the functions, so you see both of the printed messages.</p>
<p class="indent">But the second expression only shows <span class="literal1">'ReturnsTrue() was called.'</span>, not <span class="literal1">'ReturnsFalse() was called.'</span>. This is because Python didn’t call <span class="literal1">ReturnsFalse()</span> at all. Since the left side of the <span class="literal1">or</span> operator is <span class="literal1">True</span>, it doesn’t matter what <span class="literal1">ReturnsFalse()</span> returns, so Python doesn’t bother calling it. The evaluation was short-circuited.</p>
<p class="indent">The same applies for the <span class="literal1">and</span> operator. Now enter the following into the interactive shell:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">ReturnsTrue() and ReturnsTrue()</span><br class="calibre7" />ReturnsTrue() was called.<br class="calibre7" />ReturnsTrue() was called.<br class="calibre7" />True<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">ReturnsFalse() and ReturnsFalse()</span><br class="calibre7" />ReturnsFalse() was called.<br class="calibre7" />False</p>
<p class="indent">Again, if the left side of the <span class="literal1">and</span> operator is <span class="literal1">False</span>, then the entire expression is <span class="literal1">False</span>. It doesn’t matter whether the right side of <span class="literal1">and</span> is <span class="literal1">True</span> or <span class="literal1">False</span>, so Python doesn’t bother evaluating it. Both <span class="literal1">False and True</span> and <span class="literal1">False and False</span> evaluate to <span class="literal1">False</span>, so Python short-circuits the evaluation.</p>
<p class="indent">Let’s return to lines 65 to 68 of the Tic-Tac-Toe program:</p>
<p class="programs">65.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while move not in '1 2 3 4 5 6 7 8 9'.split() or not<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isSpaceFree(board, int(move)):<br class="calibre7" />66.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('What is your next move? (1-9)')<br class="calibre7" />67.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = input()<br class="calibre7" />68.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return int(move)</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-386"></span>Since the part of the condition on the left side of the <span class="literal1">or</span> operator (<span class="literal1">move not in '1 2 3 4 5 6 7 8 9'.split()</span>) evaluates to <span class="literal1">True</span>, the Python interpreter knows that the entire expression will evaluate to <span class="literal1">True</span>. It doesn’t matter if the expression on the right side of <span class="literal1">or</span> evaluates to <span class="literal1">True</span> or <span class="literal1">False</span>, because only one value on either side of the <span class="literal1">or</span> operator needs to be <span class="literal1">True</span> for the whole expression to be <span class="literal1">True</span>.</p>
<p class="indent">So Python stops checking the rest of the expression and doesn’t even bother evaluating the <span class="literal1">not isSpaceFree(board, int(move))</span> part. This means the <span class="literal1">int()</span> and the <span class="literal1">isSpaceFree()</span> functions are never called as long as <span class="literal1">move not in '1 2 3 4 5 6 7 8 9'.split()</span> is <span class="literal1">True</span>.</p>
<p class="indent">This works out well for the program, because if the right side of the condition is <span class="literal1">True</span>, then <span class="literal1">move</span> isn’t a string of a single-digit number. That would cause <span class="literal1">int()</span> to give us an error. But if <span class="literal1">move not in '1 2 3 4 5 6 7 8 9'.split()</span> evaluates to <span class="literal1">True</span>, Python short-circuits <span class="literal1">not isSpaceFree(board, int(move))</span> and <span class="literal1">int(move)</span> is not called.</p>
<h3 class="h2" id="calibre_link-563"><strong class="calibre2">Choosing a Move from a List of Moves</strong></h3>
<p class="noindent">Now let’s look at the <span class="literal1">chooseRandomMoveFromList()</span> function, which is useful for the AI code later in the program:</p>
<p class="programs">70. def chooseRandomMoveFromList(board, movesList):<br class="calibre7" />71.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns a valid move from the passed list on the passed board.<br class="calibre7" />72.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Returns None if there is no valid move.<br class="calibre7" />73.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves = []<br class="calibre7" />74.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in movesList:<br class="calibre7" />75.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, i):<br class="calibre7" />76.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;possibleMoves.append(i)</p>
<p class="indent">Remember that the <span class="literal1">board</span> parameter is a list of strings that represents a Tic-Tac-Toe board. The second parameter, <span class="literal1">movesList</span>, is a list of integers of possible spaces from which to choose. For example, if <span class="literal1">movesList</span> is <span class="literal1">[1, 3, 7, 9]</span>, that means <span class="literal1">chooseRandomMoveFromList()</span> should return the integer for one of the corner spaces.</p>
<p class="indent">However, <span class="literal1">chooseRandomMoveFromList()</span> first checks that the space is valid to make a move on. The <span class="literal1">possibleMoves</span> list starts as a blank list. The <span class="literal1">for</span> loop then iterates over <span class="literal1">movesList</span>. The moves that cause <span class="literal1">isSpaceFree()</span> to return <span class="literal1">True</span> are added to <span class="literal1">possibleMoves</span> with the <span class="literal1">append()</span> method.</p>
<p class="indent">At this point, the <span class="literal1">possibleMoves</span> list has all of the moves that were in <span class="literal1">movesList</span> that are also free spaces. The program then checks whether the list is empty:</p>
<p class="programs">78.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(possibleMoves) != 0:<br class="calibre7" />79.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return random.choice(possibleMoves)<br class="calibre7" />80.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />81.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return None</p>
<p class="indent">If the list isn’t empty, then there’s at least one possible move that can be made on the board.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-194"></span>But this list could be empty. For example, if <span class="literal1">movesList</span> was <span class="literal1">[1, 3, 7, 9]</span> but the board represented by the <span class="literal1">board</span> parameter had all the corner spaces already taken, the <span class="literal1">possibleMoves</span> list would be <span class="literal1">[]</span>. In that case, <span class="literal1">len(possibleMoves)</span> evaluates to <span class="literal1">0</span>, and the function returns the value <span class="literal1">None</span>.</p>
<h3 class="h2" id="calibre_link-564"><strong class="calibre2">The None Value</strong></h3>
<p class="noindent">The <span class="literal1">None</span> value represents the lack of a value. <span class="literal1">None</span> is the only value of the data type <span class="literal1">NoneType</span>. You might use the <span class="literal1">None</span> value when you need a value that means “does not exist” or “none of the above.”</p>
<p class="indent">For example, say you had a variable named <span class="literal1">quizAnswer</span> that holds the user’s answer to some true/false pop quiz question. The variable could hold <span class="literal1">True</span> or <span class="literal1">False</span> for the user’s answer. But if the user didn’t answer the question, you wouldn’t want to set <span class="literal1">quizAnswer</span> to <span class="literal1">True</span> or <span class="literal1">False</span>, because then it would look like the user answered the question. Instead, you could set <span class="literal1">quizAnswer</span> to <span class="literal1">None</span> if the user skipped the question.</p>
<p class="indent">As a side note, <span class="literal1">None</span> is not displayed in the interactive shell like other values are:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">2 + 2</span><br class="calibre7" />4<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">'This is a string value.'</span><br class="calibre7" />'This is a string value.'<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">None</span><br class="calibre7" />&gt;&gt;&gt;</p>
<p class="indent">The values of the first two expressions are printed as output on the next line, but <span class="literal1">None</span> has no value, so it is not printed.</p>
<p class="indent">Functions that don’t seem to return anything actually return the <span class="literal1">None</span> value. For example, <span class="literal1">print()</span> returns <span class="literal1">None</span>:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong">spam = print('Hello world!')</span><br class="calibre7" />Hello world!<br class="calibre7" />&gt;&gt;&gt; <span class="codestrong">spam == None</span><br class="calibre7" />True</p>
<p class="indent">Here we assigned <span class="literal1">print('Hello world!')</span> to <span class="literal1">spam</span>. The <span class="literal1">print()</span> function, like all functions, has a return value. Even though <span class="literal1">print()</span> prints an output, the function call returns <span class="literal1">None</span>. IDLE doesn’t show <span class="literal1">None</span> in the interactive shell, but you can tell <span class="literal1">spam</span> is set to <span class="literal1">None</span> because <span class="literal1">spam == None</span> evaluates as <span class="literal1">True</span>.</p>
<h3 class="h2" id="calibre_link-565"><strong class="calibre2">Creating the Computer’s AI</strong></h3>
<p class="noindent">The <span class="literal1">getComputerMove()</span> function contains the AI’s code:</p>
<p class="programs">83. def getComputerMove(board, computerLetter):<br class="calibre7" />84.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Given a board and the computer's letter, determine where to move<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and return that move.<br class="calibre7" />85.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if computerLetter == 'X':<br class="calibre7" />86.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter = 'O'<br class="calibre7" />87.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />88.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter = 'X'</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-381"></span>The first argument is a Tic-Tac-Toe board for the <span class="literal1">board</span> parameter. The second argument is the letter the computer uses&mdash;either <span class="literal1">'X'</span> or <span class="literal1">'O'</span> in the <span class="literal1">computerLetter</span> parameter. The first few lines simply assign the other letter to a variable named <span class="literal1">playerLetter</span>. This way, the same code can be used whether the computer is <em class="calibre6">X</em> or <em class="calibre6">O</em>.</p>
<p class="indent">Remember how the Tic-Tac-Toe AI algorithm works:</p>
<ol class="calibre12">
<li value="1" class="calibre13"><p class="noindenta">See if there’s a move the computer can make that will win the game. If there is, take that move. Otherwise, go to step 2.</p></li>
<li value="2" class="calibre13"><p class="noindenta">See if there’s a move the player can make that will cause the computer to lose the game. If there is, the computer should move there to block the player. Otherwise, go to step 3.</p></li>
<li value="3" class="calibre13"><p class="noindenta">Check if any of the corners (spaces 1, 3, 7, or 9) are free. If no corner space is free, go to step 4.</p></li>
<li value="4" class="calibre13"><p class="noindenta">Check if the center is free. If so, move there. If it isn’t, go to step 5.</p></li>
<li value="5" class="calibre13"><p class="noindenta">Move on any of the sides (spaces 2, 4, 6, or 8). There are no more steps, because the side spaces are the only spaces left if the execution has reached this step.</p></li>
</ol>
<p class="indent">The function will return an integer from <span class="literal1">1</span> to <span class="literal1">9</span> representing the computer’s move. Let’s walk through how each of these steps is implemented in the code.</p>
<h4 class="h3" id="calibre_link-566"><em class="calibre10"><strong class="calibre2">Checking Whether the Computer Can Win in One Move</strong></em></h4>
<p class="noindenta">Before anything else, if the computer can win in the next move, it should make that winning move immediately.</p>
<p class="programs">90.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Here is the algorithm for our Tic-Tac-Toe AI:<br class="calibre7" />91.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# First, check if we can win in the next move.<br class="calibre7" />92.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />93.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />94.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(boardCopy, i):<br class="calibre7" />95.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, computerLetter, i)<br class="calibre7" />96.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(boardCopy, computerLetter):<br class="calibre7" />97.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i</p>
<p class="indent">The <span class="literal1">for</span> loop that starts on line 92 iterates over every possible move from 1 to 9. The code inside the loop simulates what would happen if the computer made that move.</p>
<p class="indent">The first line in the loop (line 93) makes a copy of the <span class="literal1">board</span> list. This is so the simulated move inside the loop doesn’t modify the real Tic-Tac-Toe board stored in the <span class="literal1">board</span> variable. The <span class="literal1">getBoardCopy()</span> returns an identical but separate board list value.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-383"></span>Line 94 checks whether the space is free and, if so, simulates making the move on the copy of the board. If this move results in the computer winning, the function returns that move’s integer.</p>
<p class="indent">If none of the spaces results in winning, the loop ends, and the program execution continues to line 100.</p>
<h4 class="h3" id="calibre_link-567"><em class="calibre10"><strong class="calibre2">Checking Whether the Player Can Win in One Move</strong></em></h4>
<p class="noindenta">Next, the code will simulate the human player moving on each of the spaces:</p>
<p class="programs">&nbsp;99.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Check if the player could win on their next move and block them.<br class="calibre7" />100.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />101.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boardCopy = getBoardCopy(board)<br class="calibre7" />102.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(boardCopy, i):<br class="calibre7" />103.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(boardCopy, playerLetter, i)<br class="calibre7" />104.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(boardCopy, playerLetter):<br class="calibre7" />105.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return i</p>
<p class="indent">The code is similar to the loop on line 92 except the player’s letter is put on the board copy. If the <span class="literal1">isWinner()</span> function shows that the player would win with a move, then the computer will return that same move to block this from happening.</p>
<p class="indent">If the human player cannot win in one more move, the <span class="literal1">for</span> loop finishes, and the execution continues to line 108.</p>
<h4 class="h3" id="calibre_link-568"><em class="calibre10"><strong class="calibre2">Checking the Corner, Center, and Side Spaces (in That Order)</strong></em></h4>
<p class="noindenta">If the computer can’t make a winning move and doesn’t need to block the player’s move, it will move to a corner, center, or side space, depending on the spaces available.</p>
<p class="indent">The computer first tries to move to one of the corner spaces:</p>
<p class="programs">107.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try to take one of the corners, if they are free.<br class="calibre7" />108.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = chooseRandomMoveFromList(board, [1, 3, 7, 9])<br class="calibre7" />109.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if move != None:<br class="calibre7" />110.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return move</p>
<p class="indent">The call to the <span class="literal1">chooseRandomMoveFromList()</span> function with the list <span class="literal1">[1, 3, 7, 9]</span> ensures that the function returns the integer for one of the corner spaces: 1, 3, 7, or 9.</p>
<p class="indent">If all the corner spaces are taken, the <span class="literal1">chooseRandomMoveFromList()</span> function returns <span class="literal1">None</span>, and the execution moves on to line 113:</p>
<p class="programs">112.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Try to take the center, if it is free.<br class="calibre7" />113.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, 5):<br class="calibre7" />114.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 5</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-382"></span>If none of the corners is available, line 114 moves on the center space if it is free. If the center space isn’t free, the execution moves on to line 117:</p>
<p class="programs">116.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Move on one of the sides.<br class="calibre7" />117.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return chooseRandomMoveFromList(board, [2, 4, 6, 8])</p>
<p class="indent">This code also makes a call to <span class="literal1">chooseRandomMoveFromList()</span>, except you pass it a list of the side spaces:<span class="literal1">[2, 4, 6, 8]</span>. This function won’t return <span class="literal1">None</span> because the side spaces are the only spaces that can possibly be left. This ends the <span class="literal1">getComputerMove()</span> function and the AI algorithm.</p>
<h4 class="h3" id="calibre_link-569"><em class="calibre10"><strong class="calibre2">Checking Whether the Board Is Full</strong></em></h4>
<p class="noindenta">The last function is <span class="literal1">isBoardFull()</span>:</p>
<p class="programs">119. def isBoardFull(board):<br class="calibre7" />120.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Return True if every space on the board has been taken. Otherwise,<br class="calibre7" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False.<br class="calibre7" />121.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, 10):<br class="calibre7" />122.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isSpaceFree(board, i):<br class="calibre7" />123.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return False<br class="calibre7" />124.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</p>
<p class="indent">This function returns <span class="literal1">True</span> if the 10-string list in the <span class="literal1">board</span> argument it was passed has an <span class="literal1">'X'</span> or <span class="literal1">'O'</span> in every index (except for index <span class="literal1">0</span>, which is ignored). The <span class="literal1">for</span> loop lets us check indexes <span class="literal1">1</span> through <span class="literal1">9</span> on the <span class="literal1">board</span> list. As soon as it finds a free space on the board (that is, when <span class="literal1">isSpaceFree(board, i)</span> returns <span class="literal1">True</span>), the <span class="literal1">isBoardFull()</span> function will return <span class="literal1">False</span>.</p>
<p class="indent">If the execution manages to go through every iteration of the loop, then none of the spaces is free. Line 124 will then execute <span class="literal1">return True</span>.</p>
<h3 class="h2" id="calibre_link-570"><strong class="calibre2">The Game Loop</strong></h3>
<p class="noindent">Line 127 is the first line that isn’t inside of a function, so it’s the first line of code that executes when you run this program.</p>
<p class="programs">127. print('Welcome to Tic-Tac-Toe!')</p>
<p class="indent">This line greets the player before the game starts. The program then enters a <span class="literal1">while</span> loop at line 129:</p>
<p class="programs">129. while True:<br class="calibre7" />130.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Reset the board.<br class="calibre7" />131.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;theBoard = [' '] * 10</p>
<p class="indent">The <span class="literal1">while</span> loop keeps looping until the execution encounters a <span class="literal1">break</span> statement. Line 131 sets up the main Tic-Tac-Toe board in a variable named <span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-387"></span><span class="literal1">theBoard</span>. The board starts empty, which we represent with a list of 10 single space strings. Rather than type out this full list, line 131 uses list replication. It’s shorter to type <span class="literal1">[' '] * 10</span> than <span class="literal1">[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']</span>.</p>
<h4 class="h3" id="calibre_link-571"><em class="calibre10"><strong class="calibre2">Choosing the Player’s Mark and Who Goes First</strong></em></h4>
<p class="noindenta">Next, the <span class="literal1">inputPlayerLetter()</span> function lets the player enter whether they want to be the <em class="calibre6">X</em> or <em class="calibre6">O</em>:</p>
<p class="programs">132.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;playerLetter, computerLetter = inputPlayerLetter()</p>
<p class="indent">The function returns a two-string list, either <span class="literal1">['X', 'O']</span> or <span class="literal1">['O', 'X']</span>. We use multiple assignment to set <span class="literal1">playerLetter</span> to the first item in the returned list and <span class="literal1">computerLetter</span> to the second.</p>
<p class="indent">From there, the <span class="literal1">whoGoesFirst()</span> function randomly decides who goes first, returning either the string <span class="literal1">'player'</span> or the string <span class="literal1">'computer'</span>, and then line 134 tells the player who will go first:</p>
<p class="programs">133.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = whoGoesFirst()<br class="calibre7" />134.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The ' + turn + ' will go first.')<br class="calibre7" />135.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = True</p>
<p class="indent">The <span class="literal1">gameIsPlaying</span> variable keeps track of whether the game is still being played or if someone has won or tied.</p>
<h4 class="h3" id="calibre_link-572"><em class="calibre10"><strong class="calibre2">Running the Player’s Turn</strong></em></h4>
<p class="noindenta">Line 137’s loop will keep going back and forth between the code for the player’s turn and the computer’s turn, as long as <span class="literal1">gameIsPlaying</span> is set to <span class="literal1">True</span>:</p>
<p class="programs">137.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while gameIsPlaying:<br class="calibre7" />138.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if turn == 'player':<br class="calibre7" />139.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Player's turn<br class="calibre7" />140.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />141.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getPlayerMove(theBoard)<br class="calibre7" />142.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(theBoard, playerLetter, move)</p>
<p class="indent">The <span class="literal1">turn</span> variable was originally set to either <span class="literal1">'player'</span> or <span class="literal1">'computer'</span> by the <span class="literal1">whoGoesFirst()</span> call on line 133. If <span class="literal1">turn</span> equals <span class="literal1">'computer'</span>, then line 138’s condition is <span class="literal1">False</span>, and the execution jumps to line 156.</p>
<p class="indent">But if line 138 evaluates to <span class="literal1">True</span>, line 140 calls <span class="literal1">drawBoard()</span> and passes the <span class="literal1">theBoard</span> variable to print the Tic-Tac-Toe board on the screen. Then <span class="literal1">getPlayerMove()</span> lets the player enter their move (and also makes sure it is a valid move). The <span class="literal1">makeMove()</span> function adds the player’s <em class="calibre6">X</em> or <em class="calibre6">O</em> to <span class="literal1">theBoard</span>.</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-393"></span>Now that the player has made their move, the program should check whether they have won the game:</p>
<p class="programs">144.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(theBoard, playerLetter):<br class="calibre7" />145.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />146.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Hooray! You have won the game!')<br class="calibre7" />147.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = False</p>
<p class="indent">If the <span class="literal1">isWinner()</span> function returns <span class="literal1">True</span>, the <span class="literal1">if</span> block’s code displays the winning board and prints a message telling the player they have won. The <span class="literal1">gameIsPlaying</span> variable is also set to <span class="literal1">False</span> so that the execution doesn’t continue on to the computer’s turn.</p>
<p class="indent">If the player didn’t win with their last move, maybe their move filled up the entire board and tied the game. The program checks that condition next with an <span class="literal1">else</span> statement:</p>
<p class="programs">148.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />149.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isBoardFull(theBoard):<br class="calibre7" />150.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />151.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game is a tie!')<br class="calibre7" />152.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">In this <span class="literal1">else</span> block, the <span class="literal1">isBoardFull()</span> function returns <span class="literal1">True</span> if there are no more moves to make. In that case, the <span class="literal1">if</span> block starting at line 149 displays the tied board and tells the player a tie has occurred. The execution then breaks out of the <span class="literal1">while</span> loop and jumps to line 173.</p>
<p class="indent">If the player hasn’t won or tied the game, the program enters another <span class="literal1">else</span> statement:</p>
<p class="programs">153.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />154.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'computer'</p>
<p class="indent">Line 154 sets the <span class="literal1">turn</span> variable to <span class="literal1">'computer'</span> so that the program will execute the code for the computer’s turn on the next iteration.</p>
<h4 class="h3" id="calibre_link-573"><em class="calibre10"><strong class="calibre2">Running the Computer’s Turn</strong></em></h4>
<p class="noindenta">If the <span class="literal1">turn</span> variable wasn’t <span class="literal1">'player'</span> for the condition on line 138, then it must be the computer’s turn. The code in this <span class="literal1">else</span> block is similar to the code for the player’s turn:</p>
<p class="programs">156.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />157.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# Computer's turn<br class="calibre7" />158.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move = getComputerMove(theBoard, computerLetter)<br class="calibre7" />159.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;makeMove(theBoard, computerLetter, move)<br class="calibre7" />160.<br class="calibre7" />161.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isWinner(theBoard, computerLetter):<br class="calibre7" />162.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />163.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The computer has beaten you! You lose.')<br class="calibre7" />164.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gameIsPlaying = False<br class="calibre7" />165.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />166.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if isBoardFull(theBoard):<br class="calibre7" />167.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawBoard(theBoard)<br class="calibre7" />168.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('The game is a tie!')<br class="calibre7" />169.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break<br class="calibre7" />170.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:<br class="calibre7" />171.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn = 'player'</p>
<p class="indent"><span {http://www.idpf.org/2007/ops}type="pagebreak" id="calibre_link-391"></span>Lines 157 to 171 are almost identical to the code for the player’s turn on lines 139 to 154. The only difference is that this code uses the computer’s letter and calls <span class="literal1">getComputerMove()</span>.</p>
<p class="indent">If the game isn’t won or tied, line 171 sets <span class="literal1">turn</span> to the player’s turn. There are no more lines of code inside the <span class="literal1">while</span> loop, so the execution jumps back to the <span class="literal1">while</span> statement on line 137.</p>
<h4 class="h3" id="calibre_link-574"><em class="calibre10"><strong class="calibre2">Asking the Player to Play Again</strong></em></h4>
<p class="noindenta">Finally, the program asks the player if they want to play another game:</p>
<p class="programs">173.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('Do you want to play again? (yes or no)')<br class="calibre7" />174.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if not input().lower().startswith('y'):<br class="calibre7" />175.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break</p>
<p class="indent">Lines 173 to 175 are executed immediately after the <span class="literal1">while</span> block started by the <span class="literal1">while</span> statement on line 137. <span class="literal1">gameIsPlaying</span> is set to <span class="literal1">False</span> when the game has ended, so at this point the game asks the player if they want to play again.</p>
<p class="indent">The <span class="literal1">not input().lower().startswith('y')</span> expression will be <span class="literal1">True</span> if the player enters anything that doesn’t start with a <span class="literal1">'y'</span>. In that case, the <span class="literal1">break</span> statement executes. That breaks the execution out of the <span class="literal1">while</span> loop that was started on line 129. But since there are no more lines of code after that <span class="literal1">while</span> block, the program terminates and the game ends.</p>
<h3 class="h2" id="calibre_link-575"><strong class="calibre2">Summary</strong></h3>
<p class="noindent">Creating a program with AI comes down to carefully considering all the possible situations the AI can encounter and how it should respond in each of those situations. The Tic-Tac-Toe AI is simple because not as many moves are possible in Tic-Tac-Toe as in a game like chess or checkers.</p>
<p class="indent">Our computer AI checks for any possible winning moves. Otherwise, it checks whether it must block the player’s move. Then the AI simply chooses any available corner space, then the center space, then the side spaces. This is a simple algorithm for the computer to follow.</p>
<p class="indent">The key to implementing our AI is to make copies of the board data and simulate moves on the copy. That way, the AI code can see whether a move results in a win or loss. Then the AI can make that move on the real board. This type of simulation is effective at predicting what is or isn’t a good move.</p>
</div>


<a href="chapter9.html">Prev: Chapter 9: Extending Hangman</a> | <a href="chapter11.html">Next: Chapter 11: The Bagels Deduction Game</a>

</body></html>